#ifndef SRC_ANALYSIS_SOUFFLE_ANALYZE_TAG_CHECKS_TEST_HELPER_DL_
#define SRC_ANALYSIS_SOUFFLE_ANALYZE_TAG_CHECKS_TEST_HELPER_DL_

#include "taint.dl"

.type TestAspectName <: symbol

// Any tests in this rule have passed. Should usually be populated by TEST_RULE rather than
// directly used. If it is directly used, the test must be "declared" using an allTests fact on the
// aspect.
.decl testPasses(testAspectName: TestAspectName)

// All test aspects tested by a particular test. Should usually be populated by TEST_RULE rather
// than directly used.
.decl allTests(testAspectName: TestAspectName)
.output allTests(IO=stdout, delimiter=",")

// If a the testFails relation has any contents, then the test has failed. Should not be populated
// directly.
.decl testFails(testAspectName: TestAspectName)
.output testFails(IO=stdout, delimiter=",")

testFails(testAspectName) :- allTests(testAspectName), !testPasses(testAspectName).

// TEST_RULE is constructed so that it can take the place of a rule head. It "declares" a test
// aspect via the allTests fact and sets up a testPasses head for the aspect in question. Example
// usage:
//
// TEST_RULE("my_test_aspect") :- MyRelation(x), !MyOtherRelation(x).
//
// All recipes with a TEST_RULE head shall be seen as a condition that must be met for the test to
// pass.
#define TEST_RULE(test_aspect_name) \
  allTests(test_aspect_name). \
  testPasses(test_aspect_name)


#endif // SRC_ANALYSIS_SOUFFLE_ANALYZE_TAG_CHECKS_TEST_HELPER_DL_
