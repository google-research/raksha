//-----------------------------------------------------------------------------
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-----------------------------------------------------------------------------

#ifndef SRC_ANALYSIS_SOUFFLE_EPSILON_ANALYSIS_DL_
#define SRC_ANALYSIS_SOUFFLE_EPSILON_ANALYSIS_DL_

// This file tracks the epsilon and delta parameters, global and local, and
// throws a violationPolicy when the global parameters are strictly smaller
// than the local ones

#include "src/analysis/souffle/sensitivity_analysis.dl"
#include "src/analysis/souffle/math.dl"

#define PRIVACY_MECHANISM_OPERATOR as("privacy_mechanism", Operator)

.type GlobalDPParameter <: symbol

.type Epsilon <: number

.type Delta <: number

.type kThreshold <: number

// Type representing different differential privacy parameters (such as epsilon
// and delta).
.type DPParameterValue = EpsilonValue { value: Epsilon }
    | DeltaValue { value: Delta }


.decl isDPParameter(rule: DPParameterValue)

// Global epsilon is a value determined by users of Raksha.
// We could eventually set one as the default.
.decl isGlobalEpsilon(epsilon: Epsilon)
isGlobalEpsilon(epsilon) :- isDPParameter($EpsilonValue(epsilon)).

.decl isGlobalDelta(delta: Delta)

isGlobalDelta(delta) :- isDPParameter($DeltaValue(delta)).

// We track every mechanism that adds noise.
// Right now, we are not tracking the type of noise (e.g. via Laplace or
// Gaussian mechanisms).
.decl isDiffPrivacyMechanism(operation: Operation)
isDiffPrivacyMechanism(operation) :- isOperation(operation),
    operationHasOperator(operation, PRIVACY_MECHANISM_OPERATOR).

// The epsilon of each privacy mechanism is tracked and later attached
// to values.
.decl diffPrivacyMechanismHasEpsilon(operation: Operation, epsilon: Epsilon)
diffPrivacyMechanismHasEpsilon(operation, as(epsilon, Epsilon)) :-
    isDiffPrivacyMechanism(operation),
    operationHasAttribute(
        operation,
        ["epsilon", $NumberAttributePayload(epsilon)]).


.decl diffPrivacyMechanismHasDelta(operation: Operation, delta: Delta)
diffPrivacyMechanismHasDelta(operation, as(delta, Delta)) :-
    isDiffPrivacyMechanism(operation),
    operationHasAttribute(operation, ["delta", $NumberAttributePayload(delta)]).

.decl diffPrivacyMechanismHasKThreshold(
    operation: Operation, k_threshold: kThreshold)
diffPrivacyMechanismHasKThreshold(operation, as(k_threshold, kThreshold)) :-
    isDiffPrivacyMechanism(Operation),
    operationHasAttribute(
        operation, ["k_threshold", $NumberAttributePayload(k_threshold)]).

// We propagate privacy mechanisms backwards to inputs as per the PINQ paper.
// This relation tracks every input to its (direct and indirect) outputs.
.decl sqlPath(sql_input: AccessPath, sql_output: AccessPath)

sqlPath(sql_input, sql_input):- isSqlInput(operation, sql_input).

sqlPath(dp_input, dp_input) :- isDiffPrivacyMechanism(operation),
    operationHasOperandList(operation, input_list),
    flatten(input_list, dp_input).

sqlPath(path_start, path_end) :- sqlPath(path_start, intermediate),
    operationHasOperandList(operation, input_list),
    flatten(input_list, intermediate),
    operationHasResult(operation, path_end).

// Sequential composition: the epsilons of differential privacy mechanisms on
// input value are added.
.decl epsilonDiffPrivacy(value: AccessPath, epsilon: Epsilon)
epsilonDiffPrivacy(value, epsilon) :- sqlPath(value, _),
    epsilon = sum y: { epsilonDiffPrivacyIntermediate(value, _, y)}.

// Intermediate relation used to grab all the privacy mechanisms that go back
// to any given sqlInput
.decl epsilonDiffPrivacyIntermediate(value: AccessPath,
    sql_output: AccessPath,
    epsilon: Epsilon)
epsilonDiffPrivacyIntermediate(value, sql_output, epsilon) :-
    sqlPath(value, sql_output),
    isDiffPrivacyMechanism(operation),
    operationHasResult(operation, sql_output),
    diffPrivacyMechanismHasEpsilon(operation, epsilon).


// The deltas of differential privacy are also added as per Dwork and Roth
// (https://www.cis.upenn.edu/~aaroth/Papers/privacybook.pdf). In addition,
// Abuah, Darais, and Near describe the role of delta in advanced composition
// (https://arxiv.org/pdf/2105.01632.pdf)
.decl deltaDiffPrivacy(value: AccessPath, delta: Delta)
deltaDiffPrivacy(value, delta) :- sqlPath(value, _),
    delta = sum y : {deltaDiffPrivacyIntermediate(value, _, y)}.

// Intermediate relation used to grab all the privacy mechanisms that go back
// to any given sqlInput
.decl deltaDiffPrivacyIntermediate(value: AccessPath,
    sql_output: AccessPath,
    delta: Delta)
deltaDiffPrivacyIntermediate(value, sql_output, delta) :-
    sqlPath(value, sql_output),
    isDiffPrivacyMechanism(operation),
    operationHasResult(operation, sql_output),
    diffPrivacyMechanismHasDelta(operation, delta).

sqlValueSensitivity(value, sensitivity) :- isDiffPrivacyMechanism(operation),
    operationHasResult(operation, value),
    // assuming isDiffPrivacyMechanism always has one input
    operationHasOperandAtIndex(operation, sql_input, 0),
    sqlValueSensitivity(sql_input, sensitivity).

// When we get a mechanism with both delta and k_threshold, we pass 2 * delta
// as input to the log_wrapper.
// TODO: need to verify if delta automatically implies a need for k.
 isLogInput(to_string(2 * delta)) :- isDiffPrivacyMechanism(operation),
    diffPrivacyMechanismHasDelta(operation, delta),
    diffPrivacyMechanismHasKThreshold(operation, _).

// DP Policies are violated when:
// 1. The global epsilon is less than the local epsilon for a value used in an
//    aggregation operation as input (the value in isSqlPath)
//    times the sensitivity of said agregation operation.
// 2. The global epsilon is less than the local epsilon for an input to an
//    aggregation operation.
// 3. The global delta for an input to an aggregation operation is smaller than
//    the local delta.
violatesPolicy(value) :- isAggregationOperation(operation),
    operationHasResult(operation, sql_output),
    sqlPath(value, sql_output),
    epsilonDiffPrivacy(value, epsilon),
    isGlobalEpsilon(global_epsilon),
    (
        (sqlValueSensitivity(sql_output, sensitivity),
        global_epsilon < epsilon * sensitivity);
        global_epsilon < epsilon
    );
    isAggregationOperation(operation),
    operationHasResult(operation, sql_output),
    sqlPath(value, sql_output),
    deltaDiffPrivacy(value, delta),
    isGlobalDelta(global_delta),
    global_delta < delta;
    isDiffPrivacyMechanism(operation),
    operationHasResult(operation, value),
    diffPrivacyMechanismHasDelta(operation, delta),
    diffPrivacyMechanismHasEpsilon(operation, epsilon),
    diffPrivacyMechanismHasKThreshold(operation, k_threshold),
    logResult(to_float(2*delta), result),
    // the actual formula is preceeded by a negation sign but because we are
    // still using the type number and not float that does not make sense
    // testing wise.
    // TODO: need to fix when floats are incorporated.
    to_float(k_threshold) < (1 / to_float(epsilon)) * result.

#endif //SRC_ANALYSIS_SOUFFLE_EPSILON_ANALYSIS_DL_
