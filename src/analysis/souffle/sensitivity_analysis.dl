#ifndef SENSITIVITY_ANALYSIS_DL_
#define SENSITIVITY_ANALYSIS_DL_
//this file defines the calculations for sensitivity analysis 
//to be used in dp calculations

#include "src/analysis/souffle/taint.dl"
#include "src/analysis/souffle/sql_output.dl"

//one isSqlOperator fact per each sql operator, currently supporting one output
//referring to results as 'value' (sqlValue declared below) as per the discussion in the doc 
.decl isSqlOperator(sqlOperator: Operation)
isSqlOperator([owner, operator, result, input_list, attribute_list]) :- isOperation([owner, operator, result, input_list, attribute_list]), match("sql.*", operator). 


.decl isSqlValue(value: AccessPath)
isSqlValue(value) :- isSqlOperator([_, _, value, _, _]).

//keeping track of all initial inputs as they all have sensitivity score 1
.decl isInitialInput (ingress_point: AccessPath)
isInitialInput(as(ingress_point, AccessPath)) :- isOperation([_, "core.input", ingress_point, _, [[_, $StringAttributePayload(_)], _]]).

//helper functions to flatten input lists
.decl intermediateFlatten(list:OperandList, sublist:OperandList, list_element:AccessPath)

intermediateFlatten(list, sublist, list_element) :- isSqlOperator([_, _, _, list, _]), list = [list_element, sublist].
intermediateFlatten(list, sublist, list_element) :- intermediateFlatten(list, [list_element, sublist], _).

.decl flatten(list:OperandList, list_element:AccessPath)
flatten(list, list_element) :- intermediateFlatten(list, _, list_element).

//flattening each individual input per value
.decl isSqlInput(value: AccessPath, sql_input: AccessPath)

isSqlInput(value, sql_input) :- isSqlOperator([_, _, value, input_list, _]), 
                              flatten(input_list, sql_input). 

//keeping track of sensitivity score per each input at index 
//used to calculate the maximum input sensitivity 
.decl sqlValueHasSensitivityScoreAtIndex(value: AccessPath, sensitivity_score: number, index: number) 

//base cases (index 0)
//for initial inputs, sensitivity is 1
sqlValueHasSensitivityScoreAtIndex(value, 1, 0) :- isSqlOperator(operation), 
      operation = [_, _, value, _, _],
      operationHasOperandAtIndex(operation, sql_input, 0),
      isInitialInput(sql_input).

//for all others, get the final sensitivity score
sqlValueHasSensitivityScoreAtIndex(value, sensitivity_score, 0) :- isSqlOperator(operation), 
      operation = [_, _, value, _, _],
      operationHasOperandAtIndex(operation, sql_input, 0),
      sqlValueSensitivity(sql_input, sensitivity_score).      

//inductive cases 
//keep track at the score at each index, only update if the new input score is higher
sqlValueHasSensitivityScoreAtIndex(value, sensitivity_score, index) :- 
      isSqlValue(value),
      isSqlOperator(operation), 
      operation = [_, _, value, _, _],
      operationHasOperandAtIndex(operation, sql_input, index),
      isSqlInput(value, sql_input), 
      sqlValueSensitivity(sql_input, input_sensitivity_score), 
      sqlValueHasSensitivityScoreAtIndex(value, sensitivity_score, index-1),
      sensitivity_score >= input_sensitivity_score. 


sqlValueHasSensitivityScoreAtIndex(value, sensitivity_score, index) :- 
      isSqlValue(value),
      isSqlOperator(operation), 
      operation = [_, _, value, _, _],
      operationHasOperandAtIndex(operation, sql_input, index),
      isSqlInput(value, sql_input), 
      sqlValueSensitivity(sql_input, sensitivity_score), 
      sqlValueHasSensitivityScoreAtIndex(value, prev_sensitivity_score, index-1), 
      sensitivity_score >= prev_sensitivity_score. 

//function sensitivity scores per each sql operator as defined in PINQ
//TODO: add other cases 
.decl sqlFunctionSensitivity(operator: symbol, sensitivity_score: number)

sqlFunctionSensitivity("sql.where", 1) :- isSqlOperator([_, "sql.where", _, _, _]). 
sqlFunctionSensitivity("sql.filter", 1) :- isSqlOperator([_, "sql.filter", _, _, _]). 
sqlFunctionSensitivity("sql.group_by", 2) :- isSqlOperator([_,"sql.group_by", _, _, _]). 
sqlFunctionSensitivity("sql.select", 1) :- isSqlOperator([_, "sql.select", _, _, _]). 
sqlFunctionSensitivity("sql.column_access", 1) :- isSqlOperator([_, "sql.column_access", _, _, _]). 
sqlFunctionSensitivity("sql.output", 1) :- isSqlOperator([_, "sql.output", _, _, _]). 

//final value sensitivity score, the max of input multiplied by the function sensitivity 
.decl sqlValueSensitivity(value: AccessPath, sensitivity_score: number)
sqlValueSensitivity(value, sensitivity_score) :- 
      isSqlOperator(operation), 
      operation = [_, operator, value, _, _], 
      sqlFunctionSensitivity(operator, function_sensitvity), 
      operationOperandListLength(operation, input_list_length), 
      sqlValueHasSensitivityScoreAtIndex(value, input_sensitivity, input_list_length-1), 
      sensitivity_score = input_sensitivity * function_sensitvity.

sqlValueSensitivity(value, 1) :- isDiffPrivacyMechanism(value, _).

.decl isGlobalEpsilon(epsilon: number)
//TODO: is there a way to set a deafault option?
isGlobalEpsilon(epsilon) :- isOperation([_, "global_epsilon", _, _, [["epsilon", $NumberAttributePayload(epsilon)], _]]).

.decl isDiffPrivacyMechanism(value: AccessPath, epsilon: number)
isDiffPrivacyMechanism(value, epsilon) :- isOperation([_, "privacy_mechanism", value, _, [["epsilon", $NumberAttributePayload(epsilon)], _]]). 

//propagate privacy mechanism for now
//not sure yet what the literature says how that should be done 

isDiffPrivacyMechanism(value, epsilon) :- isSqlInput(value, sqlInput),
      isDiffPrivacyMechanism(sqlInput, epsilon). 

//sequential composition
.decl epsilonDiffPrivacy(value: AccessPath, epsilon: number)
epsilonDiffPrivacy(value, epsilon) :- isDiffPrivacyMechanism(value, _),
      epsilon = sum y : { isDiffPrivacyMechanism(value, y)}. 

violatesPolicy(value) :- isSqlOperator([_, _, value, _, _]), 
      !sqlValueSensitivity(value, _),
      epsilonDiffPrivacy(value, number), 
      isGlobalEpsilon(global_epsilon),
      number > global_epsilon;
      isGlobalEpsilon(global_epsilon),  
      sqlValueSensitivity(value, sensitivity_score), 
      epsilonDiffPrivacy(value, epsilon), 
      global_epsilon <= epsilon * sensitivity_score; 
      isSqlOperator([_, _, value, _, _]),
      !epsilonDiffPrivacy(value, _).


#endif // SENSITIVITY_ANALYSIS_DL_
