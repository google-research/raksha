#include "taint.dl"
#include "fact_test_helper.dl"
#include "integrity_tag_prop_helper.dl"

// This file explores a simple policy that attempts to add integrity tags based
// upon the presence of other integrity tags. It has the following rules:
//
// 1. When a value tagged with TimestampMillis is divided by a value tagged as
//    being the constant 1000, the result is TimestampSeconds
//
// 2. When a value tagged with TimestampSeconds is multiplied by a value tagged
//    as being the constant 1000, the result is TimestampMillisRedacted.
//
// While we might use something like operators in the future, we are currently
// doing something a bit more ad-hoc for this test by indicating that certain
// access paths are the result of operation expressions with the isOperatorExpr
// relation.

.decl mult_op(result: AccessPath, operand1: AccessPath, operand2: AccessPath)
.decl div_op(result: AccessPath, dividend: AccessPath, divisor: AccessPath)

edge(op1, result), edge(op2, result) :- mult_op(result, op1, op2).
edge(dividend, result), edge(divisor, result) :- div_op(result, dividend, divisor).

isAccessPath("a").
isAccessPath("b").
isAccessPath("c").
isAccessPath("d").
isAccessPath("e").

div_op("c", "a", "b").
mult_op("e", "c", "d").

hasAppliedIntegrityTag("a", "defaultOwner", "TimestampMillis").
hasAppliedIntegrityTag("b", "defaultOwner", "Constant_1000").
hasAppliedIntegrityTag("d", "defaultOwner", "Constant_1000").

// This is the first policy rule.
isIntegrityTag("TimestampSeconds").
mayHaveIntegrityTag(ap, owner, "TimestampSeconds") :-
  div_op(ap, operand1, operand2),
  mayHaveIntegrityTag(operand1, owner, "TimestampMillis"),
  mayHaveIntegrityTag(operand2, owner, "Constant_1000").

// These rules propagating lacks of integrity tags across rules can only remove
// integrity tags. Remove them for now to illustrate issue.
// lacksIntegrityTag(ap, owner, "TimestampSeconds") :-
//  div_op(ap, operand1, operand2),
//  (lacksIntegrityTag(operand1, owner, "TimestampMillis");
//   lacksIntegrityTag(operand2, owner, "Constant_1000")).

// This is the second policy rule.
isIntegrityTag("TimestampMillisRedacted").
mayHaveIntegrityTag(ap, owner, "TimestampMillisRedacted") :-
  mult_op(ap, operand1, operand2),
  mayHaveIntegrityTag(operand1, owner, "TimestampSeconds"),
  mayHaveIntegrityTag(operand2, owner, "Constant_1000").

// lacksIntegrityTag(ap, owner, "TimestampMillisRedacted") :-
//  mult_op(ap, operand1, operand2),
//  (lacksIntegrityTag(operand1, owner, "TimestampSeconds");
//   lacksIntegrityTag(operand2, owner, "Constant_1000")).

expectHasIntegrityTag("a", "defaultOwner", "TimestampMillis").
expectHasIntegrityTag("b", "defaultOwner", "Constant_1000").
expectHasIntegrityTag("d", "defaultOwner", "Constant_1000").

// We expect these to be present, but they are not. They are not present
// because the lack of TimestampSeconds propagates in from "a" and "b" onto "c"
// and the lack of "TimestampMillisRedacted" propagates in from "a", "b", and
// "d" onto "e".
expectHasIntegrityTag("c", "defaultOwner", "TimestampSeconds").
expectHasIntegrityTag("e", "defaultOwner", "TimestampMillisRedacted").
