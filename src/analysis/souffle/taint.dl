//-----------------------------------------------------------------------------
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-----------------------------------------------------------------------------

#ifndef SRC_ANALYSIS_SOUFFLE_TAINT_DL_
#define SRC_ANALYSIS_SOUFFLE_TAINT_DL_

#include "access_path.dl"
#include "authorization_logic.dl"
#include "dataflow_graph.dl"
#include "tags.dl"

//-----------------------------------------------------------------------------
// Relation Declarations
//-----------------------------------------------------------------------------

// Indicates that an access path definitely has a tag. Differs from mayHaveTag
// below in that mayHaveTag indicates only that it is possible that an
// accessPath has a tag.
.decl hasTag(accessPath: AccessPath, tag: Tag)

// Declares that `accessPath` may have been tainted with `tag`.
// If false, `accessPath` *definitely* does not have `tag` taint at runtime.
// If true, `accessPath` may have the `tag` taint at runtime.
// NOTE: In practice there may be value in explicitly having a layer of
// indirection in which accessPaths have IFCLabels and just IFCLabels have Tags.
// In this formalization, accessPaths also act as IFCLabels (in the sense that
// they have Tags).
.decl mayHaveTag(accessPath: AccessPath, tag: Tag)

// There is a claim that `accessPath` definitely has `tag` taint. This claim
// is made by `principal`.
.decl claimHasTag(principal: Principal, accessPath: AccessPath, tag: Tag)

// Manifests can produce base facts of this form, where usually the principal 
// is a particle (and this fact is entered by a code reviewer with no knowledge 
// of the taint analysis).
.decl claimNotEdge(principal: Principal, src: AccessPath, dst: AccessPath)

//-----------------------------------------------------------------------------
// Rules
//-----------------------------------------------------------------------------

// This rule is meant to support the functionality of removing edges from 
// manifests:
//      - that clearly does not introduce an unsafe escape hatch that could
//      break policies (because it does not introduce downgrades that would not 
//      otherwise be possible).
//      - without data owners needing to know anything about the application 
//      structure
//      - without app behavior specification writers needing to know anything 
//      about the taint analysis or the tags that might appear on a handle


// claimNotEdge(p, src, tgt) is an _attempt_ to remove an edge from the 
// analysis (by principal p)
// saysDowngrades(p, path, tgt) is an _attempt_ to remove just one tag
// from a path (by principal p).
//
// The rule for downgrades(p, t) in authorization_logic.dl describes when 
// a downgrade is "safe" and the downgrade really happens (by consulting the
// owners).
//
// Because the analysis propagates the tags on source edges to dest edges, it is safe
// to remove an edge when ALL of the tags on the source edge can be downgraded.
// However, we do not want to interfere with other edges that may flow from
// that source path. Instead, we remove all of the tags on the source from the
// midpoint access path we add in the middle of each edge. This rule populates a
// request to downgrade each tag on the edge midpoint.
//      - it is safe because these requests are only accepted if they would 
//      normally be by the downgrades(_, _) rule
//      - it does not require the manifest writer to know anything about the 
//      tags in the analysis
//      - data owners do not need to know about paths, and they will grant 
//      permission for edge removal indirectly by granting permission to remove 
//      tags (abstract representations of their data).

saysDowngrades(principal, midpoint, tag) :-
  isTag(tag), claimNotEdge(principal, src, tgt), edgeToMidpointAccessPath(src, tgt, midpoint).

hasTag(tgt, tag) :- claimHasTag(principal, tgt, tag), ownsTag(principal, tag).

mayHaveTag(tgt, tag) :- hasTag(tgt, tag).

mayHaveTag(tgt, tag) :-
    resolvedEdge(src, tgt), mayHaveTag(src, tag), !downgrades(tgt, tag).

//-----------------------------------------------------------------------------
// Universe Populating Rules
//-----------------------------------------------------------------------------
// These rules add objects to the set of things that exist (i.e. relations like
// `isObject(..)`) whenever they are mentioned in other rules.

// Any Principal used in a claim is in the universe of isPrincipal.
isPrincipal(principal) :- claimHasTag(principal, _, _).

isAccessPath(path) :- claimHasTag(_, path, _).
isAccessPath(path) :- hasTag(path, _).
isAccessPath(path) :- mayHaveTag(path, _).

// Symbols used in hasTag or mayHaveTag are tags
isTag(tag) :- claimHasTag(_, _, tag).

// A pair of (base, member) is in this set if the base access path is a non-trivial subpath of the
// member access path.
.decl isMemberOf(base: AccessPath, member: AccessPath)

// The member is a member of the base if it starts with the base plus '.'.
isMemberOf(base, member) :-
  isAccessPath(base),
  isAccessPath(member),
  strlen(base) + 1 < strlen(member),
  cat(base, ".") = substr(member, 0, strlen(base) + 1).

// An access path may have a tag if some subpath to a member field has that tag. This allows
// checking for some inner node in the access path whether any leaf node of that node might have
// a particular tag.
mayHaveTag(base, tag) :-
  isAccessPath(base),
  isAccessPath(member),
  mayHaveTag(member, tag),
  isMemberOf(base, member).

#endif // SRC_ANALYSIS_SOUFFLE_TAINT_DL_
