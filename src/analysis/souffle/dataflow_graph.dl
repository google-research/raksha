//-----------------------------------------------------------------------------
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-----------------------------------------------------------------------------
#ifndef SRC_ANALYSIS_SOUFFLE_DATAFLOW_GRAPH_DL_
#define SRC_ANALYSIS_SOUFFLE_DATAFLOW_GRAPH_DL_

// We will use the access path abtraction to refer to data during analysis.
// Consider the following data schema (not a valid syntax):
//  schema A {
//    a: Integer
//    b: schema B {
//      bf: String
//    }
//  }
//
// Suppose that data with schema A is stored in a database that is accessible
// through a handle `h`. `h.a`, `h.b`, and `h.b.bf` are all examples of access
// paths. For the time being, we will use a `symbol` to represent access paths.
// However, in the long term, it would make sense to define an ADT for this.
//
.type AccessPath <: symbol
.decl isAccessPath(path: AccessPath)

// A data flow edge.
.decl edge(src: AccessPath, tgt: AccessPath)

// Use the previous relations to map an edge to a generated access path
// representing its midpoint.
.decl edgeToMidpointAccessPath(src: AccessPath, tgt: AccessPath, midpoint: AccessPath)

// An "resolvedEdge" is an internal concept. When the user requests an edge with an
// edge fact, we will expand that into resolvedEdges in one of two ways:
//
// 1. The edge is not the subject of a claimNotEdge, in which case an
// resolvedEdge directly corresponding to the edge is created.
//
// 2. The edge is the subject of a claimNotEdge, in which case three facts
// are created: a generated midway point AccessPath, an resolvedEdge going from the
// src of the original edge to the midway point, and the midway point AccessPath
// to the tgt. That allows us to effectively eliminate edges that are the
// subject of a claimNotEdge from the dataflow graph by eliminating all tags
// from the midway point. Paths are defined in terms of resolvedEdges.
.decl resolvedEdge(for: Principal, src: AccessPath, tgt: AccessPath)

// A direct or transitive data flow path.
.decl path(src: AccessPath, tgt: AccessPath)

//-----------------------------------------------------------------------------
// Rules
//-----------------------------------------------------------------------------
// Generate a midpoint access path for each edge that is the subject of a
// claimNotEdge from any principal.
// edgeToMidpointAccessPath(src, tgt, cat("##midpoint_", to_string($))) :-
//   edge(src, tgt), claimNotEdge(_, src, tgt).

// // Generate inner edges to and from that midpoint for each edge with a midpoint.
// resolvedEdge(src, midpoint), resolvedEdge(midpoint, tgt) :-
//   edgeToMidpointAccessPath(src, tgt, midpoint).

// // For edges for which a midpoint was not generated, generate an resolvedEdge
// // corresponding to the original edge.
// resolvedEdge(src, tgt) :- edge(src, tgt), !edgeToMidpointAccessPath(src, tgt, _).
resolvedEdge(principal, src, tgt) :-
   isPrincipal(principal),
   edge(src, tgt),
   !claimNotEdge(principal, src, tgt).

// Transitive paths
//TODO(bgogul): We don't use these at all.
path(from, to) :- resolvedEdge(_, from, to).
path(from, to) :- resolvedEdge(_, from, intermediate), path(intermediate, to).

// Symbols used in resolvedEdges are access paths
isAccessPath(x) :- resolvedEdge(_, x, _).
isAccessPath(y) :- resolvedEdge(_, _, y).

#endif // SRC_ANALYSIS_SOUFFLE_DATAFLOW_GRAPH_DL_
