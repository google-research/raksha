//-----------------------------------------------------------------------------
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-----------------------------------------------------------------------------

// This file defines the interface between authorization logic and taint
// tracking / information flow control.

#ifndef SRC_ANALYSIS_SOUFFLE_AUTHORIZATION_LOGIC_DL_
#define SRC_ANALYSIS_SOUFFLE_AUTHORIZATION_LOGIC_DL_

#include "access_path.dl"
#include "tags.dl"

// A Principal that makes assertions in authorization logic
.type Principal <: symbol

// Some party asserts the claim that the label of an access path should be
// downgraded by removing the referenced tag from the set.
// This relation needs to be in snake case because outputs from the 
// authorization logic will be in snake case.
.decl saysDowngrades(speaker: Principal, p: AccessPath, t: Tag)

.decl isPrincipal(p: Principal)

isPrincipal(speaker) :- saysDowngrades(speaker, _, _).

// This party is the owner of a taint Tag (they have the privilege to downgrade
// it).
.decl ownsTag(owner: Principal, tag: Tag)

// For now, all principals own all tags. This is a temporary workaround until
// we have something real for authorization logic here.
ownsTag(owner, tag) :- isPrincipal(owner), isTag(tag).

// Some accessPath is actually downgraded (by taking into consideration the
// privileges of a party trying to downgrade it, and as a result of that party
// deciding to downgrade it). Because here IFC labels are sets of tags (ordered
// by the subset or equals relation), the downgrade works by removing a tag
// from the set (making it "lower" in the order).
.decl downgrades(path: AccessPath, tag: Tag)

//-----------------------------------------------------------------------------
// Rules
//-----------------------------------------------------------------------------
downgrades(path, tag) :- ownsTag(owner, tag), saysDowngrades(owner, path, tag).

// TODO: Add this back in once ownsTag has a real implementation.
// isTag(tag) :- ownsTag(_, tag).
isTag(tag) :- saysDowngrades(_, _, tag).

#endif // SRC_ANALYSIS_SOUFFLE_AUTHORIZATION_LOGIC_DL_
