#ifndef SRC_ANALYSIS_SOUFFLE_VISION_PIPELINE_OUT_DL_
#define SRC_ANALYSIS_SOUFFLE_VISION_PIPELINE_OUT_DL_

// This file represents the expected output of converting
// //third_party/arcs/examples/VisionPipeline.arcs into
// datalog (presumably by converting it into protos in between)

#include "taint.dl"
#include "authorization_logic.dl"
#include "VisionPipelineTagOwners.dl"
#include "VisionPipelineAuthLogicOutput.dl"

// Particle 1: ImageDetector
// Dataflow edges
edge("sensor_data_packet.camera_feed", "detection_boxes").
edge("sensor_data_packet.video_resolution", "detection_boxes").
edge("image_detection_model", "detection_boxes").

claimHasTag("sensor_data_packet.camera_feed", "raw_video_tag").
claimHasTag("image_detection_model", "image_detection_model_tag").
claimHasTag("detection_boxes", "detected_images_tag").

// Particle 2: ImageSelector
// Dataflow edges
edge("detection_boxes", "selected_image_id").
edge("user_selection_action", "selected_image_id").

claimHasTag("user_selection_action", "user_selection_tag").
claimHasTag("selected_image_id", "product_id_tag").

//-----------------------------------------------------------------------------
// The part below this line is generated by:
// "check is_selected_image_id is product_id_tag"
// (Probably part of this code should actually be in our "analysis" rather than
// generated here)

// "dummy_check_path_product_id_tag" is not a real path. It is just needed
// to do this check because we use paths both as paths through graphs and as 
// labels (which are sets of tags).
claimHasTag("dummy_check_selected_image_id", "product_id_tag").

//------ this part should move into src/analysis/souffle/
// define subset or equals (flowsTo) by finding a counterexample
.decl isNotSubsetOrEquals(p1: AccessPath, p2: AccessPath)
.decl subsetOrEquals(p1: AccessPath, p2: AccessPath)

isNotSubsetOrEquals(p1, p2) :- 
    isAccessPath(p2),
    mayHaveTag(p1, t), !mayHaveTag(p2, t).
subsetOrEquals(p1, p2) :- 
    isAccessPath(p1), isAccessPath(p2),
    !isNotSubsetOrEquals(p1, p2).
// ----------------------------

// NOTE TODO:
// Some other code needs to check that the following can be proved
// to do the "check":
// This "Check" is only true if the label of selected_image_id from 
// DFA + downgrades from authorization logic 
// subsetOrEquals("selected_image_id", "dummy_check_selected_image_id").
// The following souffle-code is a hacky way to do this:

.decl theOneCheck(x: number)
theOneCheck(1) :- subsetOrEquals("selected_image_id",
    "dummy_check_selected_image_id").

.output mayHaveTag
.output theOneCheck
.output downgrades
.output saysDowngrades

// theOneCheck.csv should have just "1" in it

#endif // SRC_ANALYSIS_VISION_PIPELINE_OUT_DL_
