//-----------------------------------------------------------------------------
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-----------------------------------------------------------------------------

"EndUser" says {
    ownsTag("raw_video_tag").
    ownsTag("user_selection_tag").
    ownsTag("product_id_tag").
      
    // These lines say the end user trusts (i.e., delegates to) the TPPR to
    // faithfully say when a data transformation from raw camera video to the 
    // name of a product has taken place, but only when the user has selected 
    // an object.
    //
    // It might look like this ideally:
    //
    // "ThirdPartyPrivacyReviewer" canSay becomes(pathX, "raw_video_tag",
    //              "product_id_tag") :-
    //     objectSelected("EndUser", pathX),
    //     isAccessPath(pathX).
    //
    // For now it has to be done like this:
    "ThirdPartyPrivacyReviewer" canSay declassifies(pathX, "raw_video_tag") :-
        hasTag(pathX, "product_id_tag"),   // raw_video_tag is only removed if 
        objectSelected("EndUser", pathX),  // product_id_tag is added
        isAccessPath(pathX).

    "ThirdPartyPrivacyReviewer" canSay
        objectSelected("EndUser", "identified_product").

    // Delegates TPPR the ability to apply tags anywhere
    "ThirdPartyPrivacyReviewer" canSay hasTag(x, y) :- 
        isAccessPath(x), isTag(y).

    // Delegate the right to claim that particles are "Local" to TPPR.
    // (We can think of the principal "LocalDevice" as a group)
    "ThirdPartyPrivacyReviewer" canSay principalX canActAs "LocalDevice" :-
        isPrincipal(principalX).

    "LocalDevice" may("do_pure_computation", "raw_video_tag").


    // "EndUser" opts-in to a policy about data egress.
    // It delegates to this policy the right to decide what modules can egress
    // any of "EndUser's" data.
    "DataEgressPolicy1" canSay principalX may("egress_to_shopping_service", tagX) :-
        isPrincipal(principalX), isTag(tagX).
    // The EndUser also expresses a preference to this policy, which is 
    // "allowEgress":
    "EndUser" hasPrivacyPreference("allowEgress").
        
    "LocalDevice" may("egress_to_shopping_service", "product_id_tag").

    // Could also give different permissions to RemoteService for once it
    // has "product_id_tag".

    // These are rules we should get rid of in the real thing.
    // The universe relations probably don't need to be decentralized. We could
    // have rules that populate a "centralized" universe and passes this 
    // to all the principals. (Or there could be other ways to deal with this).
    isPrincipal("VideoDataSource").
    isPrincipal("ImageDetector").
    isPrincipal("ImageSelector").
    isPrincipal("ProductIdOutput").
    isPrincipal("LocalDevice").
}

"ServiceProvider" says {
    ownsTag("image_detection_model_tag").

    // ServiceProvider also opts-in to "DataEgressPolicy1"
    "DataEgressPolicy1" canSay principalX may("egress_to_shopping_service", tagX) :-
        isPrincipal(principalX), isTag(tagX).
    // ServiceProvider's preference is NOT to egress:
    "ServiceProvider" hasPreference("disallowEgress").

    // Delegates TPPR the ability to apply just the model tag anywhere
    "ThirdPartyPrivacyReviewer" canSay hasTag(x, "image_detection_model_tag") :- 
        isAccessPath(x).

    // Delegate the right to claim that particles are "Local" to TPPR.
    // (We can think of the principal "LocalDevice" as a group)
    "ThirdPartyPrivacyReviewer" canSay principalX canActAs "LocalDevice" :-
        isPrincipal(principalX).

    // Give permission to do pure computation on any local device
    "LocalDevice" may("do_pure_computation", "image_detection_model_tag").

    // These are rules we should get rid of in the real thing.
    // The universe relations probably don't need to be decentralized. We could
    // have rules that populate a "centralized" universe and passes this 
    // to all the principals. (Or there could be other ways to deal with this).
    isPrincipal("VideoDataSource").
    isPrincipal("ImageDetector").
    isPrincipal("ImageSelector").
    isPrincipal("ProductIdOutput").
}


"DataEgressPolicy1" says {
    // Gathers preferences from both stakeholders:
    "EndUser" canSay "EndUser" hasPreference(prefX) :-
        isPreference(prefX).
    "ServiceProvider" canSay "ServiceProvider" hasPreference(prefX) :-
        isPreference(prefX).

    // Egressing model data and video data is allowed EVEN if
    // ServiceProvider says "no" as long as EndUser says "yes"
    // (Both of these facts are used to make the same one decision about 
    // egressing a handle that depends on both of these tags)
    "ProductIdOutput" may("egress_to_shopping_service", "product_id_tag") :-
        "EndUser" hasPreference("allowEgress").
    "ProductIdOutput" may("egress_to_shopping_service", 
        "image_detection_model_tag"). // Doesn't care about ServiceProvider pref
}

// Similar to policy 1, but we need agreement from BOTH parties:
"DataEgressPolicy2" says {
    // Gathers preferences from both stakeholders:
    "EndUser" canSay "EndUser" hasPreference(prefX) :-
        isPreference(prefX).
    "ServiceProvider" canSay "ServiceProvider" hasPreference(prefX) :-
        isPreference(prefX).

    "ProductIdOutput" may("egress_to_shopping_service", "product_id_tag") :-
        "EndUser" hasPreference("allowEgress").
    "ProductIdOutput" may("egress_to_shopping_service",
        "image_detection_model_tag") :-
        // This policy DOES care about ServiceProvider's preference:
        "ServiceProvider" hasPreference("allowEgress").

}

"ThirdPartyPrivacyReviewer" says {
    "VideoDataSource" canActAs "LocalDevice".
    "ImageDetector" canActAs "LocalDevice".
    "ImageSelector" canActAs "LocalDevice".
    "ProductIdOutput" canActAs "LocalDevice".
    
    // TPPR delegates the data transformation to ImageSelector
    // "ImageSelector" canSay becomes(pathX, "raw_video_tag", "product_id_tag") :-
    //     isAccessPath(pathX).
    "ImageSelector" canSay declassifies(pathX, "raw_video_tag") :-
        hasTag(pathX, "product_id_tag"),   // raw_video_tag is only removed if 
        objectSelected("EndUser", pathX),  // product_id_tag is added
        isAccessPath(pathX).
    "ImageSelector" canSay hasTag(pathX, "product_id_tag") :- 
        isAccessPath(pathX).
    "ImageSelector" canSay objectSelected("EndUser", pathX) :-
        isAccessPath(pathX).
}

// Maybe we want this part of the policy to sit closer to the particles
// because sometimes relations will refer to path names ?
// (We can ostensibly do this as long as we can write
// `claim <RelationName(...)>` in manifests)
//
// NOTE: maybe the "will" relations should refer to handles rather than tags, 
// but the "may"s still refer to the tags, and we figure out which tags to
// get permissions about based on the taint analysis (for now both still 
// operate on the tags).
//
// Maybe it makes more sense if this speaker is TPPR
"ImageDetector" says {
    "ImageDetector" will("do_pure_computation", "id_sensor_data_packet").
    "ImageDetector" will("do_pure_computation", "id_image_detection_model").
}
"ImageSelector" says {
    "ImageSelector" will("do_pure_computation", "is_tracking_boxes").
    declassifies("is_select_image_id", "raw_video_tag").
    hasTag("is_select_image_id", "product_id_tag").
    objectSelected("EndUser", "is_selected_image_id").
}

"ProductIdOutput" says 
    "ProductIdOutput" will("egress_to_shopping_service", "product_id_tag").

// Some queries to test this policy:
video_is_local = query "EndUser" says   
    "VideoDataSource" canActAs "LocalDevice"?

local_can_do_computation = query "EndUser" says
    "LocalDevice" may("do_pure_computation", "raw_video_tag")?

// May / Will check:
// May describes actions data owners permit with their data.
// Will describes how data is used.
// The taint analysis tracks sensitive data as it moves, and this taint
// analysis is used to check that all the uses described with `will` are 
// permitted by the owners (using `may'). Roughly this is:
//
// For each particle P, for each tag t in union over tags in read edges of P,
//      for each statement of the form:
//          `P says will <RELATION> using <TAG>`
//      prove
//          `ownsTag(Q, <TAG>)`
//          `Q says may <RELATION> using <TAG>`

// These queries mechanically test the "checks" that should happen using the 
// data. The comments illustrate the taint analysis which is used to figure out
// what checks need to happen.

// Particle: VideoDataSource
// No read handles

// Particle: Image Detector
// taint of read handles: 
//    taint(id_sensor_packet.camera_feed) = { "raw_video_tag" }
//    taint(id_sensor_packet.video_resolution) = { }
//    taint(id_image_detection_model) = { "image_detection_model_tag" }
// usage:
//    will("do_pure_computation", "id_sensor_data_packet").
//    will("do_pure_computation", "id_image_detection_model")
// owner:
//    owner("raw_video_tag") = "EndUser"
//    taint(id_image_detection_model) = { }
// Usage:
//    will("do_pure_computation", "raw_video_tag").
//      Owner("raw_video_tag") = "EndUser"
may_video_do_computation = query "EndUser" says 
    "ImageDetector" may("do_pure_computation", "raw_video_tag")?

// Particle: UserSelectionActionSource
// No read handles

// Particle: ImageSelector
// taint of read handles:
//      taint(is_detection_boxes) = { "raw_video_tag",
//          "image_detection_model_tag" }
//      taint(is_user_selection_action) = { }
// usage: 
//      will("do_pure_computation", "raw_video_tag")
//      will("do_pure_computation", "image_detection_model_tag")
// owner
may_selector_do_computation = query "EndUser" says
    "ImageSelector" may("do_pure_computation", "raw_video_tag")?

// Particle: ProductIdOutput
// taint of read handles 
//   before declassification:
//      taint(pio_select_image_id) = { "raw_video_tag" }
//   after declassification:
//      taint(pio_select_image_id) = { "product_id_tag" }
// usage:
//      will("egress_to_shopping_service", "product_id_tag")

// This tests that the declassification is also permitted as expected:
may_selector_declassify = query "EndUser" says
    declassifies("is_selected_image_id", "raw_video_tag")?

may_shopping_service_egress = query "EndUser" says
    "ProductIdOutput" may("egress_to_shopping_service", "product_id_tag")?

////// Sanity check for some false thing
// expected: false
may_other_prin_do_computation = query "EndUser" says
    "SomeOtherPrincipal" may("do_pure_computation", "raw_video_tag")?

/// Some language features are just "imagined" at the moment. 
//
// Becomes:
// `becomes(path, oldTag, newTag)` which is the same as 
// declassify(path, oldTag, newTag) and claimHasTag(path, oldTag, newTag)
// (Maybe a more general way to implement this is macros in auth logic)
//
//
// Notably "may" is a keyword rather than just another relation itself because it 
// seems useful to let usages be arbitrary relations (with potentially varying 
// signatures).
