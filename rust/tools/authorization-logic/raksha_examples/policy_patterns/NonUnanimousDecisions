//-----------------------------------------------------------------------------
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-----------------------------------------------------------------------------
// This gives an example with a non-unanimous decision about
// what can be done with data belonging to multiple sources. It may be
// non-obvious that this is possible in our system because in order
// for data to be used, we need to prove that the owner of data allows this.
// To accomplish this:
//    - the data owners both delegate to a principal that represents a policy 
//    to make the decision (using canSay)
//    - the data owners each express their preference about what they'd like to 
//    happen (as an attribute of the form "DataOwner" hasPreference())
//    - The policy makes the decision using these preferences
// Exactly how the policy makes the decision is orthogonal and can be 
// application specific. In this case the policy is similar to role-based 
// access control. The policy allows whichever principal occupies a specific 
// role make the final decision.

"DataOwner1" says {
    owns("datum1").

    // Delegate to a policy to decide whether or not data can be sent.
    // The data owner opts-in to the policy by doing this delegation, even
    // though the decision might not be DataOwner1's preference because
    // opting in might be the only way to use this service.
    "RoleBasedDecisionPolicy" canSay 
        "ExampleParticle" may("send_remotely", "datum1").
                // (this names a specific particle, but for real policies,
                // this can be made generic).

    // DataOwner1 prefers that data depending on datum1 is not sent remotely
    // (This syntax is an attribute as described 
    // [here](https://github.com/aferr/raksha/tree/main/rust/tools/authorization-logic#attributes-and-canactas)).
    "DataOwner1" hasPreference("do_not_send_remotely").
}

"DataOwner2" says {
    owns("datum2").
    
    "RoleBasedDecisionPolicy" canSay 
        "ExampleParticle" may("send_remotely", "datum2").
   
    // Data Owner1 prefers that data depending on datum1 is not sent remotely
    "DataOwner2" hasPreference("do_send_remotely").
}

// This is a principal that is trusted by "RoleBasedDecisonPolicy" to
// determine if another principal can occupy a particular role. As in
// role-based access control, whether or not a principal occupies a role
// can be used to make access decisions. In this example the role is
// "DeviceOwner". Other roles are also possible, and it is also possible
// to make membership of a role conditional on other facts.
"RoleAuthority" says {
    "DataOwner2" canActAs "DeviceOwner".
}


// This is a policy that collects the preferences of both data owners
// on whether or not they are OK with data being sent. However, the 
// actual decision depends only on the preference of the principal
// in a specifc role (DeviceOwner).

// This role-based decision policy is one way of resolving the conflict,
// but the pattern of delegating 
"RoleBasedDecisionPolicy" says {
    // The "RoleAuthority" is trusted by the policy to decide who occupies
    // the device owner role.
    "RoleAuthority" canSay PrincipalX canActAs "DeviceOwner" :-
        isPrincipal(PrincipalX).

    // If there is a handle that depends on data from BOTH "datum1" and
    // "datum2", in order to permit the particle to "send_remotely"
    // (i.e. pass the check generated by "will("send_remotely", handleX),
    // we need to prove BOTH `"DO1" says may("send_remotely", "datum1")`
    // AND `"DO2" says may("send_remotely", "datum2"). Because both owners
    // have delegated the right to make this decision to this policy, both
    // owners will respect the outcome from the policy.
  
    // In this case, the preference of the device owner is the only one
    // that matters for both pieces of data.
    "ExampleParticle" may("send_remotely", "datum1") :-
        PrincipalX canActAs "DeviceOwner",
        PrincipalX hasPreference("do_send_remotely").
    "ExampleParticle" may("send_remotely", "datum2") :-
        PrincipalX canActAs "DeviceOwner",
        PrincipalX hasPreference("do_send_remotely").


    // This just allows the policy to "import" the preferences of the two
    // data owners. It means that the policy believes the owners about their
    // own preferences.
    PrincipalX canSay PrincipalX hasPreference(PrefX) :-
        isPrincipal(PrincipalX), isPreference(PrefX).
    
    // This is just boilerplate that populates the universes
    isPrincipal("DataOwner1").
    isPrincipal("DataOwner2").
    isPrincipal("RoleAuthority").
    isPreference("do_send_remotely").
    isPreference("do_not_send_remotely").
}

// These are the checks that would be generated by a particle
// called "ExampleParticle" with "will("send_remotely", "handleX")"
// and also hasTag("handleX", "datum1"), hasTag("handleX", "datum2").
will_check1 = query "DataOwner1" says
    "ExampleParticle" may("send_remotely", "datum1")?
will_check2 = query "DataOwner2" says
    "ExampleParticle" may("send_remotely", "datum2")?
// Both of the above checks should pass (produce nonempty CSVs),
// but these are some ways to make it fail:
//     - Remove the delegation to RoleBasedDecisionPolicy in "DatOwner2"s
//     policy. (Doing the same with "DataOwner1" has no effect).
//     - Change the device owner in RoleAuthority to "DataOwner1"
//     - Remove the "may" rules from the RoleBasedDecisionPolicy

