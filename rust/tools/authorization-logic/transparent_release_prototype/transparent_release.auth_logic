//-----------------------------------------------------------------------------
// Endorsement File Wrapper
//-----------------------------------------------------------------------------

// This is an output from the wrapper for endorsement files. This 
// wrapper is a standalone binary with a CLI that takes these arguments:
// - a path to an endorsement file
// - a name for the application
// and it outputs authorization that looks like the code below

// To work in comparisons in the generated authorization logic, the times need 
// to be integers that increase as the time advances. A way to do this is 
// to represent the time as "Unix Epoch Seconds". The wrapper for the 
// endorsement file needs to convert the times it parses into this format. This 
// URL gives code for doing this in many languages: https://www.epochconverter.com/
// under the header "Convert from human-readable date to epoch".

// For this output these arguments are:
// - endorsement file --> "endorsement_file.toml"
// - application name --> "OakFunctionsLoader"
// And the expiry time and release time are converted into epoch

// Endorsement File Wrapper Output
"EndorsementFile_OakFunctionsLoader" says {
    expected_hash("ProvenanceFile_OakFunctionsLoader",
        "6de656f11599c11548519af6b7385504ed845a4ff6600745cb3d9e174b8956af")
           :- RealTimeIs(real_time),        
              greater_than(real_time, "1634843697"),  // Release time
              less_than(real_time, "1637522097").     // expiry time

    expected_hash("Binary_OakFunctionsLoader",
        "cb255dbbea86b128379995ff7dc805fd026e2d21c997a8df688ba9e5cb98e1c1")
            :- RealTimeIs(real_time),
               greater_than(real_time, "1634843697"), 
               less_than(real_time, "1637522097").

    // Ideally, we would actually write the above two rules in the following 
    // way. We don't have support for numbers (the numbers above are actually
    // strings).
    // expected_hash("ProvenanceFile_OakFunctionsLoader",
    //     "6de656f11599c11548519af6b7385504ed845a4ff6600745cb3d9e174b8956af")
    //        :- RealTimeIs(real_time), 
    //           real_time > 1634843697, real_time < 1637522097
    //
    //  expected_hash("Binary_OakFunctionsLoader",
    //     "cb255dbbea86b128379995ff7dc805fd026e2d21c997a8df688ba9e5cb98e1c1")
    //         :- RealTimeIs(real_time),
    //            real_time > 1634843697, real_time < 1637522097.
 
    // This just links the application name principal to the provenance file
    // principal.
    // TODO maybe it makes more sense if the thing that builds binary
    // files emits "Binary_OakFunctionsLoader" hasProvenance(...)
    "OakFunctionsLoader" hasProvenance("ProvenanceFile_OakFunctionsLoader").

    // The endorsement file trusts the unix epoch time wrapper
    // to give the real time (because the endorsement file relies on this
    // to do revocation)
    "UnixEpochTime" canSay RealTimeIs(real_time) :- isSymbol(real_time).

    // This should go away after we fix the multiverse problem
    isSymbol("1634843698").

    // These should go away when we can support comparisons
    greater_than("1634843698", "1634843697").
    less_than("1634843698", "1637522097").
}

//-----------------------------------------------------------------------------
// Hash Check Wrapper (Checks hashes on files)
//-----------------------------------------------------------------------------
// We need a wrapper (another standalone program) that outputs a measurement
// (sha256) of various files as authorization logic (provenance file, binary).
// This wrapper will compute the sha256 directly (for example, using the CLI program
// "sha256sum"). An alternative design based on parsing hashes from other 
// sources is shown towards the end of this section.
// (Note that, if we use a wrapper that checks the hash, we just 
// need to write one and we can use it for both the provenance file and 
// endorsement file. Whereas, if we want to parse hashes from other sources, we 
// need to write one wrapper per souce).

// The arguments to this program are:
// - the name of the file to be measured (hash checked)
// - the name of the principal for the file being measured

// We will invoke this wrapper twice: once for the provenance file and once
// for the binary generated by executing the steps in the provenance file

// For the provenance file, the inputs are:
//    file name --> "provenance_file.toml"
//    principal name --> "ProvenanceFile_OakFunctionsLoader"
// The output looks like:
"Sha256Wrapper" says {
    measured_hash("ProvenanceFile_OakFunctionsLoader",
      "6de656f11599c11548519af6b7385504ed845a4ff6600745cb3d9e174b8956af").
}

// For the binary, the inputs are:
//    file name --> "oak_functions_loader.exe" (I don't have an example binary)
//    principal name --> "Binary_OakFunctionsLoader"

"Sha256Wrapper" says {
    measured_hash("Binary_OakFunctionsLoader",
      "cb255dbbea86b128379995ff7dc805fd026e2d21c997a8df688ba9e5cb98e1c1").
}

///// Alternative design for checking hashes of provenance file and binary
///// by parsing from souce.
// Instead, we may wish to parse the hash from some other source like a BUILD
// file that already has the hash for the binary. In this case, we would
// need to write one wrapper per source. (e.g. the source for the provenance 
// file and the source for the binary).
// 
// In this case the inputs would be:
//    - file_name_of_source (e.g. some BUILD)
//    - principal name of object being measured (e.g., 
//        "ProvenanceFile_OakFunctionsLoader")
// The outputs would be:
//  "BUILDHashParser" says {
//     measured_hash("ProvenanceFile_OakFunctionsLoader",
//       "6de656f11599c11548519af6b7385504ed845a4ff6600745cb3d9e174b8956af").
//  }
//  (where the principal of the "speaker" is specific to each "source".)
//
// The rest of this code is assuming the "sha256sum" wrapper is used.

//-----------------------------------------------------------------------------
// Unix Time Wrapper
//-----------------------------------------------------------------------------
// We need a wrapper that produces the real time in unix epoch seconds. A 
// command for doing this on UNIX systems is `date %s`. Assuming the time
// that this command is run is 2021-10-21, 19:14:58 the output from running
// this command is 1634843698.
//
// This wrapper is also a standalone binary. It takes no inputs and outputs
// authorization logic code that looks like this:

"UnixEpochTime" says {
  RealTimeIs("1634843698").
}

//-----------------------------------------------------------------------------
// Verification Policy
//-----------------------------------------------------------------------------
// This is the code that does the "verification" steps. We need a small CLI
// that takes just the application name (e.g. "OakFunctionsLoader") as an
// input (the names of the provenance file and endorsement file are just 
// concatenations with the application name).
// The output is this authorization logic code.

// "VerificationPolicy" says {
//    "RekorPublicInstanceChecker" canSay {
//      SomeAppEndorsementFile isIncludedIn("url/of/rekor/service", time) :-
//          isNumber(time).
//      SomeAppEndorsementFile hasIdentity EndorsementHash :-
//         isNumber(EndorsementHash).
//    }
//    "InclusionProofChecker" canSay {
//         Record includedViaInclusionProof(Log, EndorsementHash, Time) :-
//             isRecord(Record), isLog(Log),
//             isNumber(EndorsementHash), isNumber(Time).
//    }
// 
//    "path/to/serialized_endorsement_file" canActAs "EndorsementPrincipal" :-
//        "EndorsementPrincipal" includedViaInclusionProof("url/of/rekor/service", 
//           EndorsementHash, time1), 
//        "EndorsementPrincipal" includedIn("url/of/rekor/service", time2),
//        "path/to/serialized_endorsement_file" hasMeasurement     
//        "EndorsementPrincipal", time1 > time2.      
// }

"Verifier_OakFunctionsLoader" says {
    "EndorsementFile_OakFunctionsLoader" canSay
        expected_hash("ProvenanceFile_OakFunctionsLoader", some_hash) :-
            isSymbol(some_hash).
    
    "EndorsementFile_OakFunctionsLoader" canSay
        expected_hash("Binary_OakFunctionsLoader", some_hash) :-
            isSymbol(some_hash).

    "EndorsementFile_OakFunctionsLoader" canSay 
        "OakFunctionsLoader" hasProvenance(some_provenance_file) :-
            isSymbol(some_provenance_file).

    "Sha256Wrapper" canSay measured_hash(some_object, some_hash) :-
        isSymbol(some_object), isSymbol(some_hash).

    "Binary_OakFunctionsLoader" canActAs "OakFunctionsLoader" :-
        "OakFunctionsLoader" hasProvenance("ProvenanceFile_OakFunctionsLoader"),
        expected_hash("Binary_OakFunctionsLoader", binary_hash),
        measured_hash("Binary_OakFunctionsLoader", binary_hash),
        expected_hash("ProvenanceFile_OakFunctionsLoader", provenance_hash),
        measured_hash("ProvenanceFile_OakFunctionsLoader", provenance_hash).

    // This we hopefully can get rid of for the real version:
    isSymbol("6de656f11599c11548519af6b7385504ed845a4ff6600745cb3d9e174b8956af").
    isSymbol("cb255dbbea86b128379995ff7dc805fd026e2d21c997a8df688ba9e5cb98e1c1").
    isSymbol("ProvenanceFile_OakFunctionsLoader").
    isSymbol("Binary_OakFunctionsLoader").
}

//-----------------------------------------------------------------------------
// Top Level 
//-----------------------------------------------------------------------------
// TODO

top_level_test = query "Verifier_OakFunctionsLoader" says 
  "Binary_OakFunctionsLoader" canActAs "OakFunctionsLoader"?
