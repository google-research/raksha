/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 56);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = __webpack_require__(3);

var roots = __webpack_require__(27);

var Type, // cyclic
    Enum;

util.codegen = __webpack_require__(51);
util.fetch   = __webpack_require__(52);
util.path    = __webpack_require__(53);

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = __webpack_require__(15);

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = __webpack_require__(2);

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (__webpack_require__(20))());
    }
});


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(7);
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = __webpack_require__(9),
    util = __webpack_require__(0);

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this enum
 * @param {Object.<string,string>} [comments] The value comments for this enum
 */
function Enum(name, values, options, comment, comments) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Enum comment text.
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = comments || {};

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
};

/**
 * Converts this enum to an enum descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"  , this.options,
        "values"   , this.values,
        "reserved" , this.reserved && this.reserved.length ? this.reserved : undefined,
        "comment"  , keepComments ? this.comment : undefined,
        "comments" , keepComments ? this.comments : undefined
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];

    return this;
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(24);

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(42);

// base class of rpc.Service
util.EventEmitter = __webpack_require__(43);

// float handling accross browsers
util.float = __webpack_require__(44);

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(25);

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(45);

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(46);

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(47);

// global object reference
util.global = typeof window !== "undefined" && window
           || typeof global !== "undefined" && global
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 * @const
 */
util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Field;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(7);
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = __webpack_require__(2),
    types = __webpack_require__(8),
    util  = __webpack_require__(0);

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

// Sets up cyclic dependencies (called in index-light)
Field._configure = function configure(Type_) {
    Type = Type_;
};


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = __webpack_require__(0);

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

// Sets up cyclic dependencies (called in index-light)
ReflectionObject._configure = function(Root_) {
    Root = Root_;
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = __webpack_require__(0);

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(7);
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Field    = __webpack_require__(5),
    util     = __webpack_require__(0);

var Type,    // cyclic
    Service,
    Enum;

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Tests if the specified id is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] >= id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name)
                return true;
    return false;
};

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
 */
// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

/**
 * Converts this namespace to a namespace descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name]
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum: " + name);
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type: " + path);
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

// Sets up cyclic dependencies (called in index-light)
Namespace._configure = function(Type_, Service_, Enum_) {
    Type    = Type_;
    Service = Service_;
    Enum    = Enum_;
};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(7);
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = __webpack_require__(5),
    util  = __webpack_require__(0);

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};


/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(3);

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = util.Buffer
    ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    }
    /* istanbul ignore next */
    : function create_array() {
        return new Writer();
    };

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(3);

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = util.Buffer
    ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer)
                ? new BufferReader(buffer)
                /* istanbul ignore next */
                : create_array(buffer);
        })(buffer);
    }
    /* istanbul ignore next */
    : create_array;

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Type;

// extends Namespace
var Namespace = __webpack_require__(9);
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = __webpack_require__(2),
    OneOf     = __webpack_require__(10),
    Field     = __webpack_require__(5),
    MapField  = __webpack_require__(16),
    Service   = __webpack_require__(17),
    Message   = __webpack_require__(19),
    Reader    = __webpack_require__(14),
    Writer    = __webpack_require__(13),
    util      = __webpack_require__(0),
    encoder   = __webpack_require__(28),
    decoder   = __webpack_require__(29),
    verifier  = __webpack_require__(30),
    converter = __webpack_require__(31),
    wrappers  = __webpack_require__(32);

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {number[][]} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    if (json.comment)
        type.comment = json.comment;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined,
        "comment"    , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return this.fields[name]
        || this.oneofs && this.oneofs[name]
        || this.nested && this.nested[name]
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = MapField;

// extends Field
var Field = __webpack_require__(5);
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = __webpack_require__(8),
    util    = __webpack_require__(0);

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
};

/**
 * Converts this map field to a map field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Service;

// extends Namespace
var Namespace = __webpack_require__(9);
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = __webpack_require__(18),
    util   = __webpack_require__(0),
    rpc    = __webpack_require__(26);

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return this.methods[name]
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Method;

// extends ReflectionObject
var ReflectionObject = __webpack_require__(7);
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = __webpack_require__(0);

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this method
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;

    /**
     * Comment for this method
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment);
};

/**
 * Converts this method to a method descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options,
        "comment"        , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Message;

var util = __webpack_require__(3);

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object = object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Root;

// extends Namespace
var Namespace = __webpack_require__(9);
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = __webpack_require__(5),
    Enum    = __webpack_require__(2),
    OneOf   = __webpack_require__(10),
    util    = __webpack_require__(0);

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        var cb = callback;
        callback = null;
        if (sync)
            throw err;
        cb(err, root);
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {

        // Strip path if this file references a bundled definition
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common)
                filename = altname;
        }

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            util.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

// Sets up cyclic dependencies (called in index-light)
Root._configure = function(Type_, parse_, common_) {
    Type   = Type_;
    parse  = parse_;
    common = common_;
};


/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("vm");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(50);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = encoder;

var Enum     = __webpack_require__(2),
    types    = __webpack_require__(8),
    util     = __webpack_require__(0);

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&m.hasOwnProperty(%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = decoder;

var Enum    = __webpack_require__(2),
    types   = __webpack_require__(8),
    util    = __webpack_require__(0);

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i:", field.id);

        // Map fields
        if (field.map) { gen
                ("r.skip().pos++") // assumes id 1 + key wireType
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("k=r.%s()", field.keyType)
                ("r.pos++"); // assumes id 2 + value wireType
            if (types.long[field.keyType] !== undefined) {
                if (types.basic[type] === undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                else gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=r.%s()", ref, type);
            } else {
                if (types.basic[type] === undefined) gen
                ("%s[k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                else gen
                ("%s[k]=r.%s()", ref, type);
            }

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break");
    // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = verifier;

var Enum      = __webpack_require__(2),
    util      = __webpack_require__(0);

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ("{")
                ("var e=types[%i].verify(%s);", fieldIndex, ref)
                ("if(e)")
                    ("return%j+e", field.name + ".")
            ("}");
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = __webpack_require__(2),
    util = __webpack_require__(0);

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                if (field.repeated && values[keys[i]] === field.typeDefault) gen
                ("default:");
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) {
                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
                gen
        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
        ("else{")
            ("d%s=%s", prop, arrayDefault)
            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
        ("}");
            } else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = __webpack_require__(19);

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
            var type = this.lookup(object["@type"]);
            /* istanbul ignore else */
            if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].substr(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                return this.create({
                    type_url: "/" + type_url,
                    value: type.encode(type.fromObject(object)).finish()
                });
            }
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            var name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            object["@type"] = message.$type.fullName;
            return object;
        }

        return this.toObject(message, options);
    }
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = tokenize;

var delimRe        = /[\s{}=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentAltRe = /^\s*\*?\/*/,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = {
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
};

/**
 * Unescapes a string.
 * @param {string} str String to unescape
 * @returns {string} Unescaped string
 * @property {Object.<string,string>} map Special characters map
 * @memberof tokenize
 */
function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
        }
    });
}

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type {function}
 * @param {string} token Token
 * @returns {undefined}
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type {function}
 * @param {string} expected Expected token
 * @param {boolean} [optional=false] If optional
 * @returns {boolean} Whether the token matched
 * @throws {Error} If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type {function}
 * @param {number} [line] Line number
 * @returns {string|null} Comment text or `null` if none
 */

/**
 * Handle object returned from {@link tokenize}.
 * @interface ITokenizerHandle
 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
 * @property {TokenizerHandlePush} push Pushes a token back to the stack
 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property {number} line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param {string} source Source contents
 * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns {ITokenizerHandle} Tokenizer handle
 */
function tokenize(source, alternateCommentMode) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        commentType = null,
        commentText = null,
        commentLine = 0,
        commentLineEmpty = false;

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string} subject Subject
     * @returns {Error} Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
    }

    /**
     * Reads a string till its end.
     * @returns {string} String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    }

    /**
     * Gets the character at `pos` within the source.
     * @param {number} pos Position
     * @returns {string} Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
    }

    /**
     * Sets the current comment text.
     * @param {number} start Start offset
     * @param {number} end End offset
     * @returns {undefined}
     * @inner
     */
    function setComment(start, end) {
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        var lookback;
        if (alternateCommentMode) {
            lookback = 2;  // alternate comment parsing: "//" or "/*"
        } else {
            lookback = 3;  // "///" or "/**"
        }
        var commentOffset = start - lookback,
            c;
        do {
            if (--commentOffset < 0 ||
                    (c = source.charAt(commentOffset)) === "\n") {
                commentLineEmpty = true;
                break;
            }
        } while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i]
                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
                .trim();
        commentText = lines
            .join("\n")
            .trim();
    }

    function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);

        // see if remaining line matches comment pattern
        var lineText = source.substring(startOffset, endOffset);
        // look for 1 or 2 slashes since startOffset would already point past
        // the first slash that started the comment.
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
    }

    function findEndOfLine(cursor) {
        // find end of cursor's line
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
            endOffset++;
        }
        return endOffset;
    }

    /**
     * Obtains the next token.
     * @returns {string|null} Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n")
                    ++line;
                if (++offset === length)
                    return null;
            }

            if (charAt(offset) === "/") {
                if (++offset === length) {
                    throw illegal("comment");
                }
                if (charAt(offset) === "/") { // Line
                    if (!alternateCommentMode) {
                        // check for triple-slash comment
                        isDoc = charAt(start = offset + 1) === "/";

                        while (charAt(++offset) !== "\n") {
                            if (offset === length) {
                                return null;
                            }
                        }
                        ++offset;
                        if (isDoc) {
                            setComment(start, offset - 1);
                        }
                        ++line;
                        repeat = true;
                    } else {
                        // check for double-slash comments, consolidating consecutive lines
                        start = offset;
                        isDoc = false;
                        if (isDoubleSlashCommentLine(offset)) {
                            isDoc = true;
                            do {
                                offset = findEndOfLine(offset);
                                if (offset === length) {
                                    break;
                                }
                                offset++;
                            } while (isDoubleSlashCommentLine(offset));
                        } else {
                            offset = Math.min(length, findEndOfLine(offset) + 1);
                        }
                        if (isDoc) {
                            setComment(start, offset);
                        }
                        line++;
                        repeat = true;
                    }
                } else if ((curr = charAt(offset)) === "*") { /* Block */
                    // check for /** (regular comment mode) or /* (alternate comment mode)
                    start = offset + 1;
                    isDoc = alternateCommentMode || charAt(start) === "*";
                    do {
                        if (curr === "\n") {
                            ++line;
                        }
                        if (++offset === length) {
                            throw illegal("comment");
                        }
                        prev = curr;
                        curr = charAt(offset);
                    } while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) {
                        setComment(start, offset - 2);
                    }
                    repeat = true;
                } else {
                    return "/";
                }
            }
        } while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
    }

    /**
     * Pushes a token back to the stack.
     * @param {string} token Token
     * @returns {undefined}
     * @inner
     */
    function push(token) {
        stack.push(token);
    }

    /**
     * Peeks for the next token.
     * @returns {string|null} Token or `null` on eof
     * @inner
     */
    function peek() {
        if (!stack.length) {
            var token = next();
            if (token === null)
                return null;
            push(token);
        }
        return stack[0];
    }

    /**
     * Skips a token.
     * @param {string} expected Expected token
     * @param {boolean} [optional=false] Whether the token is optional
     * @returns {boolean} `true` when skipped, `false` if not
     * @throws {Error} When a required token is not present
     * @inner
     */
    function skip(expected, optional) {
        var actual = peek(),
            equals = actual === expected;
        if (equals) {
            next();
            return true;
        }
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
    }

    /**
     * Gets a comment.
     * @param {number} [trailingLine] Line number if looking for a trailing comment
     * @returns {string|null} Comment text
     * @inner
     */
    function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === undefined) {
            if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
                ret = commentText;
            }
        } else {
            /* istanbul ignore else */
            if (commentLine < trailingLine) {
                peek();
            }
            if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
                ret = commentText;
            }
        }
        return ret;
    }

    return Object.defineProperty({
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
    }, "line", {
        get: function() { return line; }
    });
    /* eslint-enable callback-return */
}


/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = function (args, opts) {
    if (!opts) opts = {};
    
    var flags = { bools : {}, strings : {}, unknownFn: null };

    if (typeof opts['unknown'] === 'function') {
        flags.unknownFn = opts['unknown'];
    }

    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
      flags.allBools = true;
    } else {
      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
          flags.bools[key] = true;
      });
    }
    
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function (key) {
        aliases[key] = [].concat(opts.alias[key]);
        aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
                return x !== y;
            }));
        });
    });

    [].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true;
        if (aliases[key]) {
            flags.strings[aliases[key]] = true;
        }
     });

    var defaults = opts['default'] || {};
    
    var argv = { _ : [] };
    Object.keys(flags.bools).forEach(function (key) {
        setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });
    
    var notFlags = [];

    if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--')+1);
        args = args.slice(0, args.indexOf('--'));
    }

    function argDefined(key, arg) {
        return (flags.allBools && /^--[^=]+$/.test(arg)) ||
            flags.strings[key] || flags.bools[key] || aliases[key];
    }

    function setArg (key, val, arg) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg) === false) return;
        }

        var value = !flags.strings[key] && isNumber(val)
            ? Number(val) : val
        ;
        setKey(argv, key.split('.'), value);
        
        (aliases[key] || []).forEach(function (x) {
            setKey(argv, x.split('.'), value);
        });
    }

    function setKey (obj, keys, value) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            if (o[key] === undefined) o[key] = {};
            o = o[key];
        });

        var key = keys[keys.length - 1];
        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
            o[key] = value;
        }
        else if (Array.isArray(o[key])) {
            o[key].push(value);
        }
        else {
            o[key] = [ o[key], value ];
        }
    }
    
    function aliasIsBoolean(key) {
      return aliases[key].some(function (x) {
          return flags.bools[x];
      });
    }

    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        
        if (/^--.+=/.test(arg)) {
            // Using [\s\S] instead of . because js doesn't support the
            // 'dotall' regex modifier. See:
            // http://stackoverflow.com/a/1068308/13216
            var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
            var key = m[1];
            var value = m[2];
            if (flags.bools[key]) {
                value = value !== 'false';
            }
            setArg(key, value, arg);
        }
        else if (/^--no-.+/.test(arg)) {
            var key = arg.match(/^--no-(.+)/)[1];
            setArg(key, false, arg);
        }
        else if (/^--.+/.test(arg)) {
            var key = arg.match(/^--(.+)/)[1];
            var next = args[i + 1];
            if (next !== undefined && !/^-/.test(next)
            && !flags.bools[key]
            && !flags.allBools
            && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i++;
            }
            else if (/^(true|false)$/.test(next)) {
                setArg(key, next === 'true', arg);
                i++;
            }
            else {
                setArg(key, flags.strings[key] ? '' : true, arg);
            }
        }
        else if (/^-[^-]+/.test(arg)) {
            var letters = arg.slice(1,-1).split('');
            
            var broken = false;
            for (var j = 0; j < letters.length; j++) {
                var next = arg.slice(j+2);
                
                if (next === '-') {
                    setArg(letters[j], next, arg)
                    continue;
                }
                
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split('=')[1], arg);
                    broken = true;
                    break;
                }
                
                if (/[A-Za-z]/.test(letters[j])
                && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                
                if (letters[j+1] && letters[j+1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j+2), arg);
                    broken = true;
                    break;
                }
                else {
                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                }
            }
            
            var key = arg.slice(-1)[0];
            if (!broken && key !== '-') {
                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                && !flags.bools[key]
                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i+1], arg);
                    i++;
                }
                else if (args[i+1] && /true|false/.test(args[i+1])) {
                    setArg(key, args[i+1] === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
        }
        else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(
                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                );
            }
            if (opts.stopEarly) {
                argv._.push.apply(argv._, args.slice(i + 1));
                break;
            }
        }
    }
    
    Object.keys(defaults).forEach(function (key) {
        if (!hasKey(argv, key.split('.'))) {
            setKey(argv, key.split('.'), defaults[key]);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), defaults[key]);
            });
        }
    });
    
    if (opts['--']) {
        argv['--'] = new Array();
        notFlags.forEach(function(key) {
            argv['--'].push(key);
        });
    }
    else {
        notFlags.forEach(function(key) {
            argv._.push(key);
        });
    }

    return argv;
};

function hasKey (obj, keys) {
    var o = obj;
    keys.slice(0,-1).forEach(function (key) {
        o = (o[key] || {});
    });

    var key = keys[keys.length - 1];
    return key in o;
}

function isNumber (x) {
    if (typeof x === 'number') return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}



/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// full library entry point.


module.exports = __webpack_require__(39);


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var protobuf = module.exports = __webpack_require__(40);

protobuf.build = "full";

// Parser
protobuf.tokenize         = __webpack_require__(33);
protobuf.parse            = __webpack_require__(54);
protobuf.common           = __webpack_require__(55);

// Configure parser
protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var protobuf = module.exports = __webpack_require__(41);

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = __webpack_require__(28);
protobuf.decoder          = __webpack_require__(29);
protobuf.verifier         = __webpack_require__(30);
protobuf.converter        = __webpack_require__(31);

// Reflection
protobuf.ReflectionObject = __webpack_require__(7);
protobuf.Namespace        = __webpack_require__(9);
protobuf.Root             = __webpack_require__(20);
protobuf.Enum             = __webpack_require__(2);
protobuf.Type             = __webpack_require__(15);
protobuf.Field            = __webpack_require__(5);
protobuf.OneOf            = __webpack_require__(10);
protobuf.MapField         = __webpack_require__(16);
protobuf.Service          = __webpack_require__(17);
protobuf.Method           = __webpack_require__(18);

// Runtime
protobuf.Message          = __webpack_require__(19);
protobuf.wrappers         = __webpack_require__(32);

// Utility
protobuf.types            = __webpack_require__(8);
protobuf.util             = __webpack_require__(0);

// Set up possibly cyclic reflection dependencies
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(13);
protobuf.BufferWriter = __webpack_require__(48);
protobuf.Reader       = __webpack_require__(14);
protobuf.BufferReader = __webpack_require__(49);

// Utility
protobuf.util         = __webpack_require__(3);
protobuf.rpc          = __webpack_require__(26);
protobuf.roots        = __webpack_require__(27);
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
}

// Set up buffer utility according to the environment
protobuf.Writer._configure(protobuf.BufferWriter);
configure();


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(3);

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(13);
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(3);

var Buffer = util.Buffer;

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Buffer} Buffer
 */
BufferWriter.alloc = function alloc_buffer(size) {
    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
};

var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set"
    ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                           // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
    };

/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else
        buf.utf8Write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(14);
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(3);

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

/* istanbul ignore else */
if (util.Buffer)
    BufferReader.prototype._slice = util.Buffer.prototype.slice;

/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Service;

var util = __webpack_require__(3);

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = codegen;

/**
 * Begins generating a function.
 * @memberof util
 * @param {string[]} functionParams Function parameter names
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 */
function codegen(functionParams, functionName) {

    /* istanbul ignore if */
    if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = undefined;
    }

    var body = [];

    /**
     * Appends code to the function's body or finishes generation.
     * @typedef Codegen
     * @type {function}
     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
     * @param {...*} [formatParams] Format parameters
     * @returns {Codegen|Function} Itself or the generated function if finished
     * @throws {Error} If format parameter counts do not match
     */

    function Codegen(formatStringOrScope) {
        // note that explicit array handling below makes this ~50% faster

        // finish the function
        if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose)
                console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
                var scopeKeys   = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;
                while (scopeOffset < scopeKeys.length) {
                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }
                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
        }

        // otherwise append to body
        var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
        while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
                case "d": case "f": return String(Number(value));
                case "i": return String(Math.floor(value));
                case "j": return JSON.stringify(value);
                case "s": return String(value);
            }
            return "%";
        });
        if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
    }

    function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }

    Codegen.toString = toString;
    return Codegen;
}

/**
 * Begins generating a function.
 * @memberof util
 * @function codegen
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 * @variation 2
 */

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 * @name util.codegen.verbose
 * @type {boolean}
 */
codegen.verbose = false;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = fetch;

var asPromise = __webpack_require__(24),
    inquire   = __webpack_require__(25);

var fs = inquire("fs");

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal path module to resolve Unix, Windows and URL paths alike.
 * @memberof util
 * @namespace
 */
var path = exports;

var isAbsolute =
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
path.isAbsolute = function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
};

var normalize =
/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
path.normalize = function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length;) {
        if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
};

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = parse;

parse.filename = null;
parse.defaults = { keepCase: false };

var tokenize  = __webpack_require__(33),
    Root      = __webpack_require__(20),
    Type      = __webpack_require__(15),
    Field     = __webpack_require__(5),
    MapField  = __webpack_require__(16),
    OneOf     = __webpack_require__(10),
    Enum      = __webpack_require__(2),
    Service   = __webpack_require__(17),
    Method    = __webpack_require__(18),
    types     = __webpack_require__(8),
    util      = __webpack_require__(0);

var base10Re    = /^[1-9][0-9]*$/,
    base10NegRe = /^-?[1-9][0-9]*$/,
    base16Re    = /^0[x][0-9a-fA-F]+$/,
    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
    base8Re     = /^0[0-7]+$/,
    base8NegRe  = /^-?0[0-7]+$/,
    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

/**
 * Result object returned from {@link parse}.
 * @interface IParserResult
 * @property {string|undefined} package Package name, if declared
 * @property {string[]|undefined} imports Imports, if any
 * @property {string[]|undefined} weakImports Weak imports, if any
 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
 * @property {Root} root Populated root instance
 */

/**
 * Options modifying the behavior of {@link parse}.
 * @interface IParseOptions
 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
 */

/**
 * Options modifying the behavior of JSON serialization.
 * @interface IToJSONOptions
 * @property {boolean} [keepComments=false] Serializes comments.
 */

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param {string} source Source contents
 * @param {Root} root Root to populate
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 */
function parse(source, root, options) {
    /* eslint-disable callback-return */
    if (!(root instanceof Root)) {
        options = root;
        root = new Root();
    }
    if (!options)
        options = parse.defaults;

    var tn = tokenize(source, options.alternateCommentMode || false),
        next = tn.next,
        push = tn.push,
        peek = tn.peek,
        skip = tn.skip,
        cmnt = tn.cmnt;

    var head = true,
        pkg,
        imports,
        weakImports,
        syntax,
        isProto3 = false;

    var ptr = root;

    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

    /* istanbul ignore next */
    function illegal(token, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
            parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }

    function readString() {
        var values = [],
            token;
        do {
            /* istanbul ignore if */
            if ((token = next()) !== "\"" && token !== "'")
                throw illegal(token);

            values.push(next());
            skip(token);
            token = peek();
        } while (token === "\"" || token === "'");
        return values.join("");
    }

    function readValue(acceptTypeRef) {
        var token = next();
        switch (token) {
            case "'":
            case "\"":
                push(token);
                return readString();
            case "true": case "TRUE":
                return true;
            case "false": case "FALSE":
                return false;
        }
        try {
            return parseNumber(token, /* insideTryCatch */ true);
        } catch (e) {

            /* istanbul ignore else */
            if (acceptTypeRef && typeRefRe.test(token))
                return token;

            /* istanbul ignore next */
            throw illegal(token, "value");
        }
    }

    function readRanges(target, acceptStrings) {
        var token, start;
        do {
            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
                target.push(readString());
            else
                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
        } while (skip(",", true));
        skip(";");
    }

    function parseNumber(token, insideTryCatch) {
        var sign = 1;
        if (token.charAt(0) === "-") {
            sign = -1;
            token = token.substring(1);
        }
        switch (token) {
            case "inf": case "INF": case "Inf":
                return sign * Infinity;
            case "nan": case "NAN": case "Nan": case "NaN":
                return NaN;
            case "0":
                return 0;
        }
        if (base10Re.test(token))
            return sign * parseInt(token, 10);
        if (base16Re.test(token))
            return sign * parseInt(token, 16);
        if (base8Re.test(token))
            return sign * parseInt(token, 8);

        /* istanbul ignore else */
        if (numberRe.test(token))
            return sign * parseFloat(token);

        /* istanbul ignore next */
        throw illegal(token, "number", insideTryCatch);
    }

    function parseId(token, acceptNegative) {
        switch (token) {
            case "max": case "MAX": case "Max":
                return 536870911;
            case "0":
                return 0;
        }

        /* istanbul ignore if */
        if (!acceptNegative && token.charAt(0) === "-")
            throw illegal(token, "id");

        if (base10NegRe.test(token))
            return parseInt(token, 10);
        if (base16NegRe.test(token))
            return parseInt(token, 16);

        /* istanbul ignore else */
        if (base8NegRe.test(token))
            return parseInt(token, 8);

        /* istanbul ignore next */
        throw illegal(token, "id");
    }

    function parsePackage() {

        /* istanbul ignore if */
        if (pkg !== undefined)
            throw illegal("package");

        pkg = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(pkg))
            throw illegal(pkg, "name");

        ptr = ptr.define(pkg);
        skip(";");
    }

    function parseImport() {
        var token = peek();
        var whichImports;
        switch (token) {
            case "weak":
                whichImports = weakImports || (weakImports = []);
                next();
                break;
            case "public":
                next();
                // eslint-disable-line no-fallthrough
            default:
                whichImports = imports || (imports = []);
                break;
        }
        token = readString();
        skip(";");
        whichImports.push(token);
    }

    function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";

        /* istanbul ignore if */
        if (!isProto3 && syntax !== "proto2")
            throw illegal(syntax, "syntax");

        skip(";");
    }

    function parseCommon(parent, token) {
        switch (token) {

            case "option":
                parseOption(parent, token);
                skip(";");
                return true;

            case "message":
                parseType(parent, token);
                return true;

            case "enum":
                parseEnum(parent, token);
                return true;

            case "service":
                parseService(parent, token);
                return true;

            case "extend":
                parseExtension(parent, token);
                return true;
        }
        return false;
    }

    function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
            obj.comment = cmnt(); // try block-type comment
            obj.filename = parse.filename;
        }
        if (skip("{", true)) {
            var token;
            while ((token = next()) !== "}")
                fnIf(token);
            skip(";", true);
        } else {
            if (fnElse)
                fnElse();
            skip(";");
            if (obj && typeof obj.comment !== "string")
                obj.comment = cmnt(trailingLine); // try line-type comment if no block
        }
    }

    function parseType(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "type name");

        var type = new Type(token);
        ifBlock(type, function parseType_block(token) {
            if (parseCommon(type, token))
                return;

            switch (token) {

                case "map":
                    parseMapField(type, token);
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                case "oneof":
                    parseOneOf(type, token);
                    break;

                case "extensions":
                    readRanges(type.extensions || (type.extensions = []));
                    break;

                case "reserved":
                    readRanges(type.reserved || (type.reserved = []), true);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);

                    push(token);
                    parseField(type, "optional");
                    break;
            }
        });
        parent.add(type);
    }

    function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
            parseGroup(parent, rule);
            return;
        }

        /* istanbul ignore if */
        if (!typeRefRe.test(type))
            throw illegal(type, "type");

        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        name = applyCase(name);
        skip("=");

        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);

        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
        // parsing proto2 descriptors without the option, where applicable. This must be done for
        // all known packable types and anything that could be an enum (= is not a basic type).
        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
            field.setOption("packed", false, /* ifNotSet */ true);
    }

    function parseGroup(parent, rule) {
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        var fieldName = util.lcFirst(name);
        if (name === fieldName)
            name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token) {
            switch (token) {

                case "option":
                    parseOption(type, token);
                    skip(";");
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                /* istanbul ignore next */
                default:
                    throw illegal(token); // there are no groups with proto3 semantics
            }
        });
        parent.add(type)
              .add(field);
    }

    function parseMapField(parent) {
        skip("<");
        var keyType = next();

        /* istanbul ignore if */
        if (types.mapKey[keyType] === undefined)
            throw illegal(keyType, "type");

        skip(",");
        var valueType = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(valueType))
            throw illegal(valueType, "type");

        skip(">");
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseMapField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);
    }

    function parseOneOf(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var oneof = new OneOf(applyCase(token));
        ifBlock(oneof, function parseOneOf_block(token) {
            if (token === "option") {
                parseOption(oneof, token);
                skip(";");
            } else {
                push(token);
                parseField(oneof, "optional");
            }
        });
        parent.add(oneof);
    }

    function parseEnum(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var enm = new Enum(token);
        ifBlock(enm, function parseEnum_block(token) {
          switch(token) {
            case "option":
              parseOption(enm, token);
              skip(";");
              break;

            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;

            default:
              parseEnumValue(enm, token);
          }
        });
        parent.add(enm);
    }

    function parseEnumValue(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token))
            throw illegal(token, "name");

        skip("=");
        var value = parseId(next(), true),
            dummy = {};
        ifBlock(dummy, function parseEnumValue_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(dummy, token); // skip
                skip(";");
            } else
                throw illegal(token);

        }, function parseEnumValue_line() {
            parseInlineOptions(dummy); // skip
        });
        parent.add(token, value, dummy.comment);
    }

    function parseOption(parent, token) {
        var isCustom = skip("(", true);

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "name");

        var name = token;
        if (isCustom) {
            skip(")");
            name = "(" + name + ")";
            token = peek();
            if (fqTypeRefRe.test(token)) {
                name += token;
                next();
            }
        }
        skip("=");
        parseOptionValue(parent, name);
    }

    function parseOptionValue(parent, name) {
        if (skip("{", true)) { // { a: "foo" b { c: "bar" } }
            do {
                /* istanbul ignore if */
                if (!nameRe.test(token = next()))
                    throw illegal(token, "name");

                if (peek() === "{")
                    parseOptionValue(parent, name + "." + token);
                else {
                    skip(":");
                    if (peek() === "{")
                        parseOptionValue(parent, name + "." + token);
                    else
                        setOption(parent, name + "." + token, readValue(true));
                }
                skip(",", true);
            } while (!skip("}", true));
        } else
            setOption(parent, name, readValue(true));
        // Does not enforce a delimiter to be universal
    }

    function setOption(parent, name, value) {
        if (parent.setOption)
            parent.setOption(name, value);
    }

    function parseInlineOptions(parent) {
        if (skip("[", true)) {
            do {
                parseOption(parent, "option");
            } while (skip(",", true));
            skip("]");
        }
        return parent;
    }

    function parseService(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "service name");

        var service = new Service(token);
        ifBlock(service, function parseService_block(token) {
            if (parseCommon(service, token))
                return;

            /* istanbul ignore else */
            if (token === "rpc")
                parseMethod(service, token);
            else
                throw illegal(token);
        });
        parent.add(service);
    }

    function parseMethod(parent, token) {
        var type = token;

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var name = token,
            requestType, requestStream,
            responseType, responseStream;

        skip("(");
        if (skip("stream", true))
            requestStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        requestType = token;
        skip(")"); skip("returns"); skip("(");
        if (skip("stream", true))
            responseStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        responseType = token;
        skip(")");

        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        ifBlock(method, function parseMethod_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(method, token);
                skip(";");
            } else
                throw illegal(token);

        });
        parent.add(method);
    }

    function parseExtension(parent, token) {

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "reference");

        var reference = token;
        ifBlock(null, function parseExtension_block(token) {
            switch (token) {

                case "required":
                case "repeated":
                case "optional":
                    parseField(parent, token, reference);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);
                    push(token);
                    parseField(parent, "optional", reference);
                    break;
            }
        });
    }

    var token;
    while ((token = next()) !== null) {
        switch (token) {

            case "package":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parsePackage();
                break;

            case "import":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseImport();
                break;

            case "syntax":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseSyntax();
                break;

            case "option":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseOption(ptr, token);
                skip(";");
                break;

            default:

                /* istanbul ignore else */
                if (parseCommon(ptr, token)) {
                    head = false;
                    continue;
                }

                /* istanbul ignore next */
                throw illegal(token);
        }
    }

    parse.filename = null;
    return {
        "package"     : pkg,
        "imports"     : imports,
         weakImports  : weakImports,
         syntax       : syntax,
         root         : root
    };
}

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @name parse
 * @function
 * @param {string} source Source contents
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 * @variation 2
 */


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = common;

var commonRe = /\/|\./;

/**
 * Provides common type definitions.
 * Can also be used to provide additional google types or your own custom types.
 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
 * @returns {undefined}
 * @property {INamespace} google/protobuf/any.proto Any
 * @property {INamespace} google/protobuf/duration.proto Duration
 * @property {INamespace} google/protobuf/empty.proto Empty
 * @property {INamespace} google/protobuf/field_mask.proto FieldMask
 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
 * @example
 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
 * protobuf.common("descriptor", descriptorJson);
 *
 * // manually provides a custom definition (uses my.foo namespace)
 * protobuf.common("my/foo/bar.proto", myFooBarJson);
 */
function common(name, json) {
    if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common[name] = json;
}

// Not provided because of limited use (feel free to discuss or to provide yourself):
//
// google/protobuf/descriptor.proto
// google/protobuf/source_context.proto
// google/protobuf/type.proto
//
// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
// the repository or package within the google/protobuf directory.

common("any", {

    /**
     * Properties of a google.protobuf.Any message.
     * @interface IAny
     * @type {Object}
     * @property {string} [typeUrl]
     * @property {Uint8Array} [bytes]
     * @memberof common
     */
    Any: {
        fields: {
            type_url: {
                type: "string",
                id: 1
            },
            value: {
                type: "bytes",
                id: 2
            }
        }
    }
});

var timeType;

common("duration", {

    /**
     * Properties of a google.protobuf.Duration message.
     * @interface IDuration
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Duration: timeType = {
        fields: {
            seconds: {
                type: "int64",
                id: 1
            },
            nanos: {
                type: "int32",
                id: 2
            }
        }
    }
});

common("timestamp", {

    /**
     * Properties of a google.protobuf.Timestamp message.
     * @interface ITimestamp
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Timestamp: timeType
});

common("empty", {

    /**
     * Properties of a google.protobuf.Empty message.
     * @interface IEmpty
     * @memberof common
     */
    Empty: {
        fields: {}
    }
});

common("struct", {

    /**
     * Properties of a google.protobuf.Struct message.
     * @interface IStruct
     * @type {Object}
     * @property {Object.<string,IValue>} [fields]
     * @memberof common
     */
    Struct: {
        fields: {
            fields: {
                keyType: "string",
                type: "Value",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Value message.
     * @interface IValue
     * @type {Object}
     * @property {string} [kind]
     * @property {0} [nullValue]
     * @property {number} [numberValue]
     * @property {string} [stringValue]
     * @property {boolean} [boolValue]
     * @property {IStruct} [structValue]
     * @property {IListValue} [listValue]
     * @memberof common
     */
    Value: {
        oneofs: {
            kind: {
                oneof: [
                    "nullValue",
                    "numberValue",
                    "stringValue",
                    "boolValue",
                    "structValue",
                    "listValue"
                ]
            }
        },
        fields: {
            nullValue: {
                type: "NullValue",
                id: 1
            },
            numberValue: {
                type: "double",
                id: 2
            },
            stringValue: {
                type: "string",
                id: 3
            },
            boolValue: {
                type: "bool",
                id: 4
            },
            structValue: {
                type: "Struct",
                id: 5
            },
            listValue: {
                type: "ListValue",
                id: 6
            }
        }
    },

    NullValue: {
        values: {
            NULL_VALUE: 0
        }
    },

    /**
     * Properties of a google.protobuf.ListValue message.
     * @interface IListValue
     * @type {Object}
     * @property {Array.<IValue>} [values]
     * @memberof common
     */
    ListValue: {
        fields: {
            values: {
                rule: "repeated",
                type: "Value",
                id: 1
            }
        }
    }
});

common("wrappers", {

    /**
     * Properties of a google.protobuf.DoubleValue message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    DoubleValue: {
        fields: {
            value: {
                type: "double",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.FloatValue message.
     * @interface IFloatValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FloatValue: {
        fields: {
            value: {
                type: "float",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int64Value message.
     * @interface IInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    Int64Value: {
        fields: {
            value: {
                type: "int64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt64Value message.
     * @interface IUInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    UInt64Value: {
        fields: {
            value: {
                type: "uint64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int32Value message.
     * @interface IInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    Int32Value: {
        fields: {
            value: {
                type: "int32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt32Value message.
     * @interface IUInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    UInt32Value: {
        fields: {
            value: {
                type: "uint32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BoolValue message.
     * @interface IBoolValue
     * @type {Object}
     * @property {boolean} [value]
     * @memberof common
     */
    BoolValue: {
        fields: {
            value: {
                type: "bool",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.StringValue message.
     * @interface IStringValue
     * @type {Object}
     * @property {string} [value]
     * @memberof common
     */
    StringValue: {
        fields: {
            value: {
                type: "string",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BytesValue message.
     * @interface IBytesValue
     * @type {Object}
     * @property {Uint8Array} [value]
     * @memberof common
     */
    BytesValue: {
        fields: {
            value: {
                type: "bytes",
                id: 1
            }
        }
    }
});

common("field_mask", {

    /**
     * Properties of a google.protobuf.FieldMask message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FieldMask: {
        fields: {
            paths: {
                rule: "repeated",
                type: "string",
                id: 1
            }
        }
    }
});

/**
 * Gets the root definition of the specified common proto file.
 *
 * Bundled definitions are:
 * - google/protobuf/any.proto
 * - google/protobuf/duration.proto
 * - google/protobuf/empty.proto
 * - google/protobuf/field_mask.proto
 * - google/protobuf/struct.proto
 * - google/protobuf/timestamp.proto
 * - google/protobuf/wrappers.proto
 *
 * @param {string} file Proto file name
 * @returns {INamespace|null} Root definition or `null` if not defined
 */
common.get = function get(file) {
    return common[file] || null;
};


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: /Users/sjmiles/Sites/projects/arcs/node_modules/minimist/index.js
var minimist = __webpack_require__(34);
var minimist_default = /*#__PURE__*/__webpack_require__.n(minimist);

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(6);
var external_fs_default = /*#__PURE__*/__webpack_require__.n(external_fs_);

// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(35);
var external_path_default = /*#__PURE__*/__webpack_require__.n(external_path_);

// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/tools/paths.oss.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// Path mappings to add to `new Runtime({urlMap})`
//
// This constant is overridden in Google internal repo to allow absolute imports
// in manifest files.
const PATHS = {};
//# sourceMappingURL=paths.oss.js.map
// EXTERNAL MODULE: external "assert"
var external_assert_ = __webpack_require__(22);
var external_assert_default = /*#__PURE__*/__webpack_require__.n(external_assert_);

// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/assert-node.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


//# sourceMappingURL=assert-node.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/arcs-types/modality.js
/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

var ModalityName;
(function (ModalityName) {
    ModalityName["Dom"] = "dom";
    ModalityName["DomTouch"] = "domTouch";
    ModalityName["Vr"] = "vr";
    ModalityName["Voice"] = "voice";
})(ModalityName || (ModalityName = {}));
class modality_Modality {
    // `all` true means modality is non restricted and any modality is compatible.
    // Otherwise, the `names` field in Modality contains the restrictive list of
    // modalities (an empty list stands for no suitable modalities being available).
    constructor(all, names = []) {
        this.all = all;
        this.names = names;
    }
    static create(names) {
        external_assert_default()(names != null);
        return new modality_Modality(false, names);
    }
    intersection(other) {
        if (this.all && other.all) {
            return new modality_Modality(true, []);
        }
        if (this.all) {
            return new modality_Modality(false, other.names);
        }
        return new modality_Modality(false, this.names.filter(name => other.all || other.names.includes(name)));
    }
    static intersection(modalities) {
        return modalities.reduce((modality, total) => modality.intersection(total), modality_Modality.all);
    }
    union(other) {
        if (this.all || other.all) {
            return modality_Modality.all;
        }
        return new modality_Modality(false, [...new Set(this.names.concat(other.names))]);
    }
    static union(modalities) {
        return modalities.length === 0
            ? modality_Modality.all
            : modalities.reduce((modality, total) => modality.union(total), modality_Modality.create([]));
    }
    isResolved() {
        return this.all || this.names.length > 0;
    }
    isCompatible(names) {
        return this.intersection(modality_Modality.create(names)).isResolved();
    }
    static get Name() { return ModalityName; }
}
modality_Modality.all = new modality_Modality(true, []);
modality_Modality.dom = new modality_Modality(false, [modality_Modality.Name.Dom]);
modality_Modality.domTouch = new modality_Modality(false, [modality_Modality.Name.DomTouch]);
modality_Modality.voice = new modality_Modality(false, [modality_Modality.Name.Voice]);
modality_Modality.vr = new modality_Modality(false, [modality_Modality.Name.Vr]);
//# sourceMappingURL=modality.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/manifest-ast-types/enums.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/** The different types of trust claims that particles can make. */
var ClaimType;
(function (ClaimType) {
    ClaimType["IsTag"] = "is-tag";
    ClaimType["DerivesFrom"] = "derives-from";
})(ClaimType || (ClaimType = {}));
/** The different types of trust checks that particles can make. */
var CheckType;
(function (CheckType) {
    CheckType["HasTag"] = "has-tag";
    CheckType["IsFromHandle"] = "is-from-handle";
    CheckType["IsFromOutput"] = "is-from-output";
    CheckType["IsFromStore"] = "is-from-store";
    CheckType["Implication"] = "implication";
})(CheckType || (CheckType = {}));
//# sourceMappingURL=enums.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/manifest-ast-types/manifest-ast-nodes.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


/**
 * A base token interface for the `kind` and `location` entries. This creates
 * a TypeScript Discriminated Union for most tokens.
 */
class BaseNode {
}
class BaseNodeWithRefinement extends BaseNode {
}
function isCollectionType(node) {
    return node.kind === 'collection-type';
}
function isTypeVariable(node) {
    return node.kind === 'variable-type';
}
function isSlotType(node) {
    return node.kind === 'slot-type';
}
function slandleType(arg) {
    if (isSlotType(arg.type)) {
        return arg.type;
    }
    if (isCollectionType(arg.type) && isSlotType(arg.type.type)) {
        return arg.type.type;
    }
    return undefined;
}
const RELAXATION_KEYWORD = 'someof';
var SchemaFieldKind;
(function (SchemaFieldKind) {
    SchemaFieldKind["Primitive"] = "schema-primitive";
    SchemaFieldKind["KotlinPrimitive"] = "kotlin-primitive";
    SchemaFieldKind["Collection"] = "schema-collection";
    SchemaFieldKind["Reference"] = "schema-reference";
    SchemaFieldKind["OrderedList"] = "schema-ordered-list";
    SchemaFieldKind["Union"] = "schema-union";
    SchemaFieldKind["Tuple"] = "schema-tuple";
    SchemaFieldKind["Nested"] = "schema-nested";
    SchemaFieldKind["Inline"] = "schema-inline";
    SchemaFieldKind["InlineField"] = "schema-inline-field";
    // TypeName is considered a 'partial' of Inline (the type checker will convert to Inline when the
    // fields are found during annotation of the AST with type info).
    SchemaFieldKind["TypeName"] = "type-name";
})(SchemaFieldKind || (SchemaFieldKind = {}));
var Op;
(function (Op) {
    Op["AND"] = "and";
    Op["OR"] = "or";
    Op["LT"] = "<";
    Op["GT"] = ">";
    Op["LTE"] = "<=";
    Op["GTE"] = ">=";
    Op["ADD"] = "+";
    Op["SUB"] = "-";
    Op["MUL"] = "*";
    Op["DIV"] = "/";
    Op["NOT"] = "not";
    Op["NEG"] = "neg";
    Op["EQ"] = "==";
    Op["NEQ"] = "!=";
})(Op || (Op = {}));
var BuiltInFuncs;
(function (BuiltInFuncs) {
    BuiltInFuncs["NOW"] = "now";
    BuiltInFuncs["CREATION_TIME"] = "creationTime";
    BuiltInFuncs["EXPIRATION_TIME"] = "expirationTime";
})(BuiltInFuncs || (BuiltInFuncs = {}));
const schemaPrimitiveTypes = [
    'Text',
    'URL',
    'Number',
    'BigInt',
    'Boolean',
    'Bytes',
    'Object',
    'Instant',
    'Duration',
];
const discreteTypes = [
    'BigInt',
    'Long',
    'Int',
    'Instant',
    'Duration',
];
const continuousTypes = [
    'Number',
    'Float',
    'Double',
    'Text',
];
const primitiveTypes = [
    'Boolean',
    // TODO: Add full support for Boolean as a Discrete value (it currently has it's own primitives).
    '~query_arg_type',
    ...continuousTypes,
    ...discreteTypes
];
const timeUnits = [
    'days',
    'hours',
    'minutes',
    'seconds',
    'milliseconds'
];
var PaxelFunctionName;
(function (PaxelFunctionName) {
    PaxelFunctionName["Now"] = "now";
    PaxelFunctionName["Min"] = "min";
    PaxelFunctionName["Max"] = "max";
    PaxelFunctionName["Average"] = "average";
    PaxelFunctionName["Sum"] = "sum";
    PaxelFunctionName["Count"] = "count";
    PaxelFunctionName["Union"] = "union";
    PaxelFunctionName["First"] = "first";
})(PaxelFunctionName || (PaxelFunctionName = {}));
// represents function(args) => number paxel functions
function makePaxelNumericFunction(name, arity, type) {
    return makePaxelFunction(name, arity, {
        kind: SchemaFieldKind.Primitive, type, location: INTERNAL_PAXEL_LOCATION
    });
}
// Used for builtin function nodes
const INTERNAL_PAXEL_LOCATION = {
    filename: 'internal_paxel_function_table',
    start: { offset: 0, column: 0, line: 0 },
    end: { offset: 0, column: 0, line: 0 }
};
// Represents function(sequence<type>, ...) => sequence<type> paxel functions
function makePaxelCollectionTypeFunction(name, arity) {
    return makePaxelFunction(name, arity, {
        kind: SchemaFieldKind.Collection,
        schema: {
            kind: 'type-name',
            name: '*',
            location: INTERNAL_PAXEL_LOCATION
        },
        location: INTERNAL_PAXEL_LOCATION
    });
}
// arity = -1 means varargs
function makePaxelFunction(name, arity, returnType) {
    return {
        name,
        arity,
        returnType
    };
}
const PAXEL_FUNCTIONS = [
    makePaxelNumericFunction(PaxelFunctionName.Now, 0, 'Number'),
    makePaxelNumericFunction(PaxelFunctionName.Min, 1, 'Number'),
    makePaxelNumericFunction(PaxelFunctionName.Max, 1, 'Number'),
    makePaxelNumericFunction(PaxelFunctionName.Average, 1, 'Number'),
    makePaxelNumericFunction(PaxelFunctionName.Count, 1, 'Number'),
    makePaxelNumericFunction(PaxelFunctionName.Sum, 1, 'Number'),
    makePaxelCollectionTypeFunction(PaxelFunctionName.Union, -1),
    makePaxelCollectionTypeFunction(PaxelFunctionName.First, 1)
];
function preSlandlesDirectionToDirection(direction, isOptional = false) {
    // TODO(jopra): Remove after syntax unification.
    // Use switch for totality checking.
    const opt = isOptional ? '?' : '';
    switch (direction) {
        case 'reads':
            return `reads${opt}`;
        case 'writes':
            return `writes${opt}`;
        case 'reads writes':
            return `reads${opt} writes${opt}`;
        case '`consumes':
            return `\`consumes${opt}`;
        case '`provides':
            return `\`provides${opt}`;
        case 'hosts':
            return `hosts${opt}`;
        case 'any':
            return `any${opt}`;
        default:
            // Catch nulls and unsafe values from javascript.
            throw new Error(`Bad pre slandles direction ${direction}`);
    }
}
function viewAst(ast, viewLocation = false) {
    // Helper function useful for viewing ast information while working on the parser and test code:
    // Optionally, strips location information.
    console.log(JSON.stringify(ast, (_key, value) => {
        if (!viewLocation && value != null && value['location']) {
            delete value['location'];
        }
        return typeof value === 'bigint'
            ? value.toString() // Workaround for JSON not supporting bigint.
            : value;
    }, // return everything else unchanged
    2));
}
function viewLoc(loc) {
    const filename = loc.filename ? ` in ${loc.filename}` : '';
    return `line ${loc.start.line}, col ${loc.start.column}${filename}`;
}
//# sourceMappingURL=manifest-ast-nodes.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/symbols.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// TypeScript seems to lose the necessary type info if this symbol is wrapped in an object and then
// used as an interface key (e.g. 'interface Foo { [Symbols.internals]: {...} }'), so we just have
// to export it as a standard variable. See the EntityInternals class for the usage of this symbol.
const SYMBOL_INTERNALS = Symbol('internals');
//# sourceMappingURL=symbols.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storable.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


class Storable {
    static creationTimestamp(entity) {
        return getStorableInternals(entity).hasCreationTimestamp()
            ? getStorableInternals(entity).getCreationTimestamp() : null;
    }
    static expirationTimestamp(entity) {
        return getStorableInternals(entity).hasExpirationTimestamp()
            ? getStorableInternals(entity).getExpirationTimestamp() : null;
    }
}
class StorableInternals {
}
function getStorableInternals(entity) {
    const internals = entity[SYMBOL_INTERNALS];
    external_assert_default()(internals !== undefined, 'SYMBOL_INTERNALS lookup on non-entity');
    return internals;
}
//# sourceMappingURL=storable.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/flags.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/* Arcs runtime flags.
 * These can be set via command line arguments and are generally for
 * incrementally introducing potentially breaking changes (e.g. adding/removing
 * features).
 *
 * Example:
 * To run all test, but use slandles, use the following command:
 * sigh test --useSlandles=true
 *
 * Note: This does not override flag values set explicitly for a test.
 */
class FlagDefaults {
}
FlagDefaults.enforceRefinements = false;
FlagDefaults.useSlandles = false;
FlagDefaults.defaultToSlandles = false;
FlagDefaults.fieldRefinementsAllowed = false;
// Enables support for recursive & co-recursive schemas. See b/156427820
FlagDefaults.recursiveSchemasAllowed = false;
// Silences unsafe refinement warnings. See b/160879434 for more info.
FlagDefaults.warnOnUnsafeRefinement = false;
// Enables support for nullable/optional types in JS and Kotlin code generation.
// See b/174115805 for more info.
FlagDefaults.supportNullables = false;
// Strict null checking in JS runtime.
FlagDefaults.enforceStrictNullCheckingInJS = false;
// TODO(#4843): temporary avoid using reference-mode-store in tests.
FlagDefaults.defaultReferenceMode = false;
class Flags extends FlagDefaults {
    /** Resets flags. To be called in test teardown methods. */
    static reset() {
        // Use the defaults
        Object.assign(Flags, FlagDefaults);
        // Overwrite the defaults with the testFlags.
        if (typeof global !== 'undefined') {
            Object.assign(Flags, global['testFlags']);
        }
    }
    // tslint:disable-next-line: no-any
    static whileEnforcingRefinements(f) {
        return Flags.withFlags({ enforceRefinements: true }, f);
    }
    // tslint:disable-next-line: no-any
    static withFieldRefinementsAllowed(f) {
        return Flags.withFlags({ fieldRefinementsAllowed: true }, f);
    }
    // tslint:disable-next-line: no-any
    static withDefaultReferenceMode(f) {
        return Flags.withFlags({ defaultReferenceMode: true }, f);
    }
    // For testing with a different set of flags to the default.
    // tslint:disable-next-line: no-any
    static withFlags(flagsSettings, f) {
        return async (...args) => {
            Object.assign(Flags, flagsSettings);
            let res;
            try {
                res = await f(...args);
            }
            finally {
                Flags.reset();
            }
            return res;
        };
    }
}
/** Initialize flags to their default value */
Flags.reset();
//# sourceMappingURL=flags.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/types/internal/refiner.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */



var AtLeastAsSpecific;
(function (AtLeastAsSpecific) {
    AtLeastAsSpecific["YES"] = "YES";
    AtLeastAsSpecific["NO"] = "NO";
    AtLeastAsSpecific["UNKNOWN"] = "UNKNOWN";
})(AtLeastAsSpecific || (AtLeastAsSpecific = {}));
// The variable name used for the query argument in generated Kotlin code.
const KOTLIN_QUERY_ARGUMENT_NAME = 'queryArgument';
class refiner_Refinement {
    constructor(expr) {
        this.kind = 'refinement';
        // TODO(ragdev): ensure that the refinement contains at least 1 fieldName
        this.expression = expr;
    }
    static fromAst(ref, typeData) {
        if (!ref) {
            return null;
        }
        return new refiner_Refinement(refiner_RefinementExpression.fromAst(ref.expression, typeData));
    }
    toLiteral() {
        return { kind: this.kind, expression: this.expression.toLiteral() };
    }
    static fromLiteral(ref) {
        return new refiner_Refinement(refiner_RefinementExpression.fromLiteral(ref.expression));
    }
    static unionOf(ref1, ref2) {
        const expr1 = ref1 && ref1.expression;
        const expr2 = ref2 && ref2.expression;
        let refinement = null;
        if (expr1 && expr2) {
            const bothExpr = new refiner_BinaryExpression(expr1, expr2, new refiner_RefinementOperator(Op.OR));
            refinement = new refiner_Refinement(bothExpr);
        }
        return refinement;
    }
    static intersectionOf(ref1, ref2) {
        const expr1 = ref1 && ref1.expression;
        const expr2 = ref2 && ref2.expression;
        let refinement = null;
        if (expr1 && expr2) {
            const bothExpr = new refiner_BinaryExpression(expr1, expr2, new refiner_RefinementOperator(Op.AND));
            refinement = new refiner_Refinement(bothExpr);
        }
        else if (expr1 || expr2) {
            refinement = new refiner_Refinement(expr1 || expr2);
        }
        return refinement;
    }
    containsField(fieldName) {
        return this.getFieldParams().has(fieldName);
    }
    getFieldParams() {
        return this.expression.getFieldParams();
    }
    getQueryParams() {
        return this.expression.getQueryParams();
    }
    getTextPrimitives() {
        return this.expression.getTextPrimitives();
    }
    // checks if a is at least as specific as b
    static isAtLeastAsSpecificAs(a, b) {
        // Ensure there is a refinement to check with.
        if (b === null || b === undefined) {
            // All refinements are more specific than this.
            return AtLeastAsSpecific.YES;
        }
        a = a || new refiner_Refinement(new BooleanPrimitive(true));
        try {
            a.normalize();
            b.normalize();
            if (a.toString() === b.toString()) { // Short cut until simple NumberMultinomial equality works.
                return AtLeastAsSpecific.YES;
            }
            const texts = new Set([...a.expression.getTextPrimitives(), ...b.expression.getTextPrimitives()]);
            const textToNum = {};
            let idx = 0;
            for (const text of texts) {
                textToNum[text] = idx;
                idx += 1;
            }
            // Find the range of values for the field name over which the refinement is valid.
            if (discreteTypes.includes(a.expression.evalType) || discreteTypes.includes(b.expression.evalType)) {
                // the 'as DiscreteType' here works around the definition of .includes's type being too narrow.
                const rangeA = refiner_BigIntRange.fromExpression(a.expression, {});
                const rangeB = refiner_BigIntRange.fromExpression(b.expression, {});
                return rangeA.isSubsetOf(rangeB) ? AtLeastAsSpecific.YES : AtLeastAsSpecific.NO;
            }
            const rangeA = refiner_NumberRange.fromExpression(a.expression, textToNum);
            const rangeB = refiner_NumberRange.fromExpression(b.expression, textToNum);
            return rangeA.isSubsetOf(rangeB) ? AtLeastAsSpecific.YES : AtLeastAsSpecific.NO;
        }
        catch (e) {
            if (Flags.warnOnUnsafeRefinement) {
                console.warn(`Unable to ascertain if ${a} is at least as specific as ${b}.`);
            }
            return AtLeastAsSpecific.UNKNOWN;
        }
    }
    // This function does the following:
    // ~ Simplifies mathematical and boolean expressions e.g. '(2*num + (1 + 3) < 4 + num) and True' => 'num < 0'
    // ~ Converts a binary node to {leftExpr: fieldName, rightExpr: val} (where applicable).
    // ~ Converts a unary node {op: '-', val: x} into a number node {val: -x}
    // ~ Removes redundant info like expression && false => false
    normalize() {
        this.expression = this.expression.normalizeOperators();
        try {
            // Rearrange doesn't handle multivariate case yet.
            // Therefore, we TRY to rearrange, if possible.
            this.expression = this.expression.rearrange();
        }
        catch (e) {
            // tslint:disable-next-line no-empty
            //TODO(cypher1): Report polynomial errors without using the console.
            console.log(`Normalisation failed for ${this}`);
        }
        this.expression = this.expression.normalize();
    }
    toString() {
        return '[' + this.expression.toString() + ']';
    }
    extractRefinementFromQuery() {
        const ref = this.expression.extractRefinementFromQuery();
        return ref ? new refiner_Refinement(ref) : null;
    }
    validateData(data) {
        const res = this.expression.evaluate(data);
        if (res === null && this.expression.getQueryParams().has('?')) {
            return true;
        }
        if (typeof res !== 'boolean') {
            throw new Error(`Refinement expression ${this.expression} evaluated to a non-boolean type: ${typeof res}. ${res}`);
        }
        return res;
    }
}
class refiner_RefinementExpression {
    constructor(kind, evalType) {
        this.kind = kind;
        this.evalType = evalType;
    }
    static fromAst(expr, typeData) {
        if (!expr) {
            return null;
        }
        switch (expr.kind) {
            case 'binary-expression-node': return refiner_BinaryExpression.fromAst(expr, typeData);
            case 'unary-expression-node': return refiner_UnaryExpression.fromAst(expr, typeData);
            case 'field-name-node': return FieldNamePrimitive.fromAst(expr, typeData);
            case 'built-in-node': return refiner_BuiltIn.fromAst(expr, typeData);
            case 'query-argument-node': return QueryArgumentPrimitive.fromAst(expr, typeData);
            case 'number-node': return NumberPrimitive.fromAst(expr);
            case 'discrete-node': return DiscretePrimitive.fromAst(expr);
            case 'boolean-node': return BooleanPrimitive.fromAst(expr);
            case 'text-node': return TextPrimitive.fromAst(expr);
            default:
                // Should never happen; all known kinds are handled above, but the linter wants a default.
                throw new Error(`RefinementExpression.fromAst: Unknown node type ${expr['kind']}`);
        }
    }
    isConstant() {
        return true;
    }
    static fromLiteral(expr) {
        switch (expr.kind) {
            case 'BinaryExpressionNode': return refiner_BinaryExpression.fromLiteral(expr);
            case 'UnaryExpressionNode': return refiner_UnaryExpression.fromLiteral(expr);
            case 'FieldNamePrimitiveNode': return FieldNamePrimitive.fromLiteral(expr);
            case 'BuiltInNode': return refiner_BuiltIn.fromLiteral(expr);
            case 'QueryArgumentPrimitiveNode': return QueryArgumentPrimitive.fromLiteral(expr);
            case 'NumberPrimitiveNode': return NumberPrimitive.fromLiteral(expr);
            case 'DiscretePrimitiveNode': return DiscretePrimitive.fromLiteral(expr);
            case 'BooleanPrimitiveNode': return BooleanPrimitive.fromLiteral(expr);
            case 'TextPrimitiveNode': return TextPrimitive.fromLiteral(expr);
            default:
                // Should never happen; all known kinds are handled above, but the linter wants a default.
                throw new Error(`RefinementExpression.fromLiteral: Unknown node type ${expr['kind']}`);
        }
    }
    normalize() {
        return this;
    }
    rearrange() {
        return this;
    }
    normalizeOperators() {
        return this;
    }
    extractRefinementFromQuery() {
        return this;
    }
    getValue() {
        const value = this.evaluate({});
        switch (this.evalType) {
            case 'Boolean': return new BooleanPrimitive(value);
            case 'Int':
            case 'Long':
            case 'BigInt':
            case 'Instant':
                return new DiscretePrimitive(value, [], this.evalType);
            case 'Duration':
                return new DiscretePrimitive(value, [], this.evalType);
            case 'Number':
                return new NumberPrimitive(value, []);
            default: throw new Error('Couldn\'t force evaluation of ${this.toString()}');
        }
    }
    getFieldParams() {
        return new Map();
    }
    getQueryParams() {
        return new Map();
    }
    getTextPrimitives() {
        return new Set();
    }
    static validateOperandCompatibility(op, operands) {
        const getWiderTypes = (type) => {
            switch (type) {
                case 'Long': return ['Instant', 'BigInt'];
                case 'Instant': return ['Long', 'BigInt'];
                case 'Int': return ['Long', 'Instant', 'BigInt'];
                case 'Float': return ['Double'];
                case '~query_arg_type': return primitiveTypes;
                default: return [];
            }
        };
        const operandTys = operands.map(op => op.evalType).join(' and ');
        const opInfo = operatorTable[op.op];
        const expected = () => {
            if (opInfo.argType === 'same') {
                return 'arguments to be of the same type';
            }
            else {
                const typeOptions = opInfo.argType.filter(x => x !== '~query_arg_type');
                if (typeOptions.length > 1) {
                    const front = typeOptions.slice(0, typeOptions.length - 1);
                    const last = typeOptions[typeOptions.length - 1];
                    return `${front.join(', ')} or ${last}`;
                }
            }
            return opInfo.argType[0];
        };
        // TODO(cypher1): Use the type checker here (with type variables) as this is not typesafe.
        // E.g. if both arguments are unknown, the types will be unknown but not enforced to be equal.
        if (operands.length !== opInfo.nArgs) {
            throw new Error(`Expected ${opInfo.nArgs} operands. Got ${operands.length}.`);
        }
        const unary = operands.length === 1;
        const pluralise = unary ? '' : 's';
        const repr = unary ? `${op.op} ${operands[0]}` : `(${operands[0]} ${op.op} ${operands[1]})`;
        const getArgType = () => {
            let argType = '~query_arg_type';
            // Discover the shared argument type.
            for (const operand of operands) {
                if (operand.evalType === argType) {
                    continue;
                }
                if (opInfo.argType === 'same' || opInfo.argType.includes(operand.evalType)) {
                    if (getWiderTypes(operand.evalType).includes(argType)) {
                        // The current argType already assumes that the operand can be safely up-cast.
                        continue;
                    }
                    if (getWiderTypes(argType).includes(operand.evalType)) {
                        // Can safely up-cast the left.
                        argType = operand.evalType;
                        continue;
                    }
                }
                // This type is not valid, no matter the other arguments.
                throw new Error(`Operands of refinement expression ${repr} have type${pluralise} ${operandTys}. Expected ${expected()}`);
            }
            return argType;
        };
        if (operands.length !== opInfo.nArgs) {
            throw new Error(`Expected ${opInfo.nArgs} operands. Got ${operands.length}.`);
        }
        const argType = getArgType();
        // Set the query argument type.
        for (const operand of operands) {
            if (operand instanceof QueryArgumentPrimitive && operand.evalType === '~query_arg_type') {
                operand.evalType = argType;
            }
        }
        // Passed type checking.
        return (opInfo.evalType === 'same') ? argType : opInfo.evalType;
    }
}
class refiner_BinaryExpression extends refiner_RefinementExpression {
    constructor(leftExpr, rightExpr, op) {
        super('BinaryExpressionNode', refiner_RefinementExpression.validateOperandCompatibility(op, [leftExpr, rightExpr]));
        this.leftExpr = leftExpr;
        this.rightExpr = rightExpr;
        this.operator = op;
    }
    static fromAst(expression, typeData) {
        if (operatorTable[expression.operator] === undefined) {
            const loc = expression.location;
            throw new Error(`Unknown operator '${expression.operator}' at ${viewLoc(loc)}`);
        }
        const left = refiner_RefinementExpression.fromAst(expression.leftExpr, typeData);
        const right = refiner_RefinementExpression.fromAst(expression.rightExpr, typeData);
        return new refiner_BinaryExpression(left, right, new refiner_RefinementOperator(expression.operator));
    }
    toLiteral() {
        return {
            kind: this.kind,
            leftExpr: this.leftExpr.toLiteral(),
            rightExpr: this.rightExpr.toLiteral(),
            evalType: this.evalType,
            operator: this.operator.toLiteral()
        };
    }
    static fromLiteral(expr) {
        return new refiner_BinaryExpression(refiner_RefinementExpression.fromLiteral(expr.leftExpr), refiner_RefinementExpression.fromLiteral(expr.rightExpr), refiner_RefinementOperator.fromLiteral(expr.operator));
    }
    update(expr) {
        this.leftExpr = expr.leftExpr;
        this.rightExpr = expr.rightExpr;
        this.operator = expr.operator;
        this.evalType = expr.evalType;
    }
    toString() {
        return `(${this.leftExpr.toString()} ${this.operator.op} ${this.rightExpr.toString()})`;
    }
    evaluate(data = null) {
        const left = this.leftExpr.evaluate(data);
        const right = this.rightExpr.evaluate(data);
        return this.operator.eval([left, right]);
    }
    extractRefinementFromQuery() {
        const left = this.leftExpr.extractRefinementFromQuery();
        const right = this.rightExpr.extractRefinementFromQuery();
        if (this.operator.op === Op.AND && left !== null && right === null) {
            return left;
        }
        if (this.operator.op === Op.AND && left === null && right !== null) {
            return right;
        }
        if (left === null) {
            return null;
        }
        if (right === null) {
            return null;
        }
        return new refiner_BinaryExpression(left, right, this.operator);
    }
    swapChildren() {
        const temp = this.rightExpr;
        this.rightExpr = this.leftExpr;
        this.leftExpr = temp;
        this.operator.flip();
    }
    simplifyPrimitive() {
        if (this.leftExpr instanceof BooleanPrimitive && this.rightExpr instanceof BooleanPrimitive) {
            return new BooleanPrimitive(this.evaluate());
        }
        else if (this.leftExpr instanceof NumberPrimitive && this.rightExpr instanceof NumberPrimitive) {
            if (this.evalType === 'Boolean') {
                return new BooleanPrimitive(this.evaluate());
            }
            return new NumberPrimitive(this.evaluate());
        }
        return null;
    }
    rearrange() {
        const leftNumeric = numericTypes.includes(this.leftExpr.evalType);
        const rightNumeric = numericTypes.includes(this.rightExpr.evalType);
        if (this.evalType === 'Boolean' && leftNumeric && rightNumeric) {
            try {
                refiner_Normalizer.rearrangeNumericalExpression(this);
            }
            catch (e) {
                // tslint:disable-next-line no-empty
                //TODO(cypher1): Report polynomial errors without using the console.
            }
        }
        else {
            this.leftExpr = this.leftExpr.rearrange();
            this.rightExpr = this.rightExpr.rearrange();
        }
        return this;
    }
    normalize() {
        if (this.isConstant()) {
            return this.getValue();
        }
        this.leftExpr = this.leftExpr.normalize();
        this.rightExpr = this.rightExpr.normalize();
        if (this.leftExpr.toString() < this.rightExpr.toString()) {
            this.swapChildren();
        }
        switch (this.operator.op) {
            case Op.AND: {
                if (this.leftExpr instanceof BooleanPrimitive) {
                    return this.leftExpr.value ? this.rightExpr : this.leftExpr;
                }
                else if (this.rightExpr instanceof BooleanPrimitive) {
                    return this.rightExpr.value ? this.leftExpr : this.rightExpr;
                }
                return this;
            }
            case Op.OR: {
                if (this.leftExpr instanceof BooleanPrimitive) {
                    return this.leftExpr.value ? this.leftExpr : this.rightExpr;
                }
                else if (this.rightExpr instanceof BooleanPrimitive) {
                    return this.rightExpr.value ? this.rightExpr : this.leftExpr;
                }
                return this;
            }
            case Op.EQ: {
                if (this.leftExpr instanceof BooleanPrimitive) {
                    return this.leftExpr.value ? this.rightExpr : new refiner_UnaryExpression(this.rightExpr, new refiner_RefinementOperator(Op.NOT));
                }
                else if (this.rightExpr instanceof BooleanPrimitive) {
                    return this.rightExpr.value ? this.leftExpr : new refiner_UnaryExpression(this.leftExpr, new refiner_RefinementOperator(Op.NOT));
                }
                return this;
            }
            case Op.NEQ: {
                if (this.leftExpr instanceof BooleanPrimitive) {
                    return this.leftExpr.value ? new refiner_UnaryExpression(this.rightExpr, new refiner_RefinementOperator(Op.NOT)) : this.rightExpr;
                }
                else if (this.rightExpr instanceof BooleanPrimitive) {
                    return this.rightExpr.value ? new refiner_UnaryExpression(this.leftExpr, new refiner_RefinementOperator(Op.NOT)) : this.leftExpr;
                }
                return this;
            }
            case Op.DIV: {
                if (this.rightExpr instanceof NumberPrimitive && this.rightExpr.value === 1) {
                    return this.leftExpr;
                }
                if (this.rightExpr instanceof DiscretePrimitive && this.rightExpr.value === BigInt(1)) {
                    return this.leftExpr;
                }
                return this;
            }
            case Op.MUL: {
                if (this.leftExpr instanceof NumberPrimitive && this.leftExpr.value === 1) {
                    return this.rightExpr;
                }
                if (this.leftExpr instanceof DiscretePrimitive && this.leftExpr.value === BigInt(1)) {
                    return this.rightExpr;
                }
                if (this.rightExpr instanceof NumberPrimitive && this.rightExpr.value === 1) {
                    return this.leftExpr;
                }
                if (this.rightExpr instanceof DiscretePrimitive && this.rightExpr.value === BigInt(1)) {
                    return this.leftExpr;
                }
                return this;
            }
            default: return this;
        }
    }
    normalizeOperators() {
        this.leftExpr = this.leftExpr.normalizeOperators();
        this.rightExpr = this.rightExpr.normalizeOperators();
        switch (this.operator.op) {
            case Op.GTE: return new refiner_BinaryExpression(new refiner_BinaryExpression(this.rightExpr, this.leftExpr, new refiner_RefinementOperator(Op.LT)), new refiner_BinaryExpression(this.rightExpr, this.leftExpr, new refiner_RefinementOperator(Op.EQ)), new refiner_RefinementOperator(Op.OR));
            case Op.LTE: return new refiner_BinaryExpression(new refiner_BinaryExpression(this.leftExpr, this.rightExpr, new refiner_RefinementOperator(Op.LT)), new refiner_BinaryExpression(this.leftExpr, this.rightExpr, new refiner_RefinementOperator(Op.EQ)), new refiner_RefinementOperator(Op.OR));
            case Op.NEQ: return new refiner_UnaryExpression(new refiner_BinaryExpression(this.leftExpr, this.rightExpr, new refiner_RefinementOperator(Op.EQ)), new refiner_RefinementOperator(Op.NOT));
            default: return this;
        }
    }
    getFieldParams() {
        const fn1 = this.leftExpr.getFieldParams();
        const fn2 = this.rightExpr.getFieldParams();
        return new Map([...fn1, ...fn2]);
    }
    getQueryParams() {
        const fn1 = this.leftExpr.getQueryParams();
        const fn2 = this.rightExpr.getQueryParams();
        return new Map([...fn1, ...fn2]);
    }
    getTextPrimitives() {
        const fn1 = this.leftExpr.getTextPrimitives();
        const fn2 = this.rightExpr.getTextPrimitives();
        return new Set([...fn1, ...fn2]);
    }
    isConstant() {
        return this.leftExpr.isConstant() && this.rightExpr.isConstant();
    }
}
class refiner_UnaryExpression extends refiner_RefinementExpression {
    constructor(expr, op) {
        super('UnaryExpressionNode', refiner_RefinementExpression.validateOperandCompatibility(op, [expr]));
        this.expr = expr;
        this.operator = op;
    }
    static fromAst(expression, typeData) {
        return new refiner_UnaryExpression(refiner_RefinementExpression.fromAst(expression.expr, typeData), new refiner_RefinementOperator((expression.operator === Op.SUB) ? Op.NEG : expression.operator));
    }
    toLiteral() {
        return {
            kind: this.kind,
            evalType: this.evalType,
            expr: this.expr.toLiteral(),
            operator: this.operator.toLiteral()
        };
    }
    static fromLiteral(expr) {
        return new refiner_UnaryExpression(refiner_RefinementExpression.fromLiteral(expr.expr), refiner_RefinementOperator.fromLiteral(expr.operator));
    }
    toString() {
        return `(${this.operator.op === Op.NEG ? '-' : this.operator.op} ${this.expr.toString()})`;
    }
    evaluate(data = null) {
        const expression = this.expr.evaluate(data);
        if (expression === null) {
            return null;
        }
        return this.operator.eval([expression]);
    }
    extractRefinementFromQuery() {
        const expr = this.expr.extractRefinementFromQuery() || this;
        if (expr === null) {
            return null;
        }
        return new refiner_UnaryExpression(expr, this.operator);
    }
    simplifyPrimitive() {
        if (this.expr instanceof BooleanPrimitive && this.operator.op === Op.NOT) {
            return new BooleanPrimitive(this.evaluate());
        }
        else if (this.expr instanceof NumberPrimitive && this.operator.op === Op.NEG) {
            return new NumberPrimitive(this.evaluate());
        }
        return null;
    }
    normalize() {
        if (this.isConstant()) {
            return this.getValue();
        }
        this.expr = this.expr.normalize();
        switch (this.operator.op) {
            case Op.NOT: {
                if (this.expr instanceof refiner_UnaryExpression && this.expr.operator.op === Op.NOT) {
                    return this.expr.expr;
                }
                if (this.expr instanceof refiner_BinaryExpression) {
                    if (this.expr.operator.op === Op.NEQ) {
                        return new refiner_BinaryExpression(this.expr.leftExpr, this.expr.rightExpr, new refiner_RefinementOperator(Op.EQ));
                    }
                    if (this.expr.operator.op === Op.EQ) {
                        return new refiner_BinaryExpression(this.expr.leftExpr, this.expr.rightExpr, new refiner_RefinementOperator(Op.NEQ));
                    }
                }
                return this;
            }
            default:
                return this;
        }
    }
    rearrange() {
        this.expr = this.expr.rearrange();
        return this;
    }
    getFieldParams() {
        return this.expr.getFieldParams();
    }
    getQueryParams() {
        return this.expr.getQueryParams();
    }
    getTextPrimitives() {
        return this.expr.getTextPrimitives();
    }
    isConstant() {
        return this.expr.isConstant();
    }
}
class FieldNamePrimitive extends refiner_RefinementExpression {
    constructor(value, evalType) {
        super('FieldNamePrimitiveNode', evalType);
        this.value = value;
    }
    static fromAst(expression, typeData) {
        if (typeData[expression.value] === undefined) {
            throw new Error(`Unresolved field name '${expression.value}' in the refinement expression.`);
        }
        return new FieldNamePrimitive(expression.value, typeData[expression.value]);
    }
    toLiteral() {
        return {
            kind: this.kind,
            evalType: this.evalType,
            value: this.value
        };
    }
    static fromLiteral(expr) {
        return new FieldNamePrimitive(expr.value, expr.evalType);
    }
    toString() {
        return this.value.toString();
    }
    evaluate(data = null) {
        if (data === null || data[this.value] === undefined) {
            throw new Error(`Unresolved field value '${this.value}' in the refinement expression.`);
        }
        return data[this.value];
    }
    getFieldParams() {
        return new Map([[this.value, this.evalType]]);
    }
    isConstant() {
        return false;
    }
}
class QueryArgumentPrimitive extends refiner_RefinementExpression {
    constructor(value, evalType) {
        super('QueryArgumentPrimitiveNode', evalType);
        this.value = value;
    }
    static fromAst(expression, typeData) {
        return new QueryArgumentPrimitive(expression.value, typeData[expression.value] || '~query_arg_type');
    }
    toLiteral() {
        return {
            kind: this.kind,
            evalType: this.evalType,
            value: this.value
        };
    }
    static fromLiteral(expr) {
        return new QueryArgumentPrimitive(expr.value, expr.evalType);
    }
    toString() {
        return this.value.toString();
    }
    evaluate(data = null) {
        if (data === null || data[this.value] === undefined) {
            throw new Error(`Unresolved query value '${this.value}' in the refinement expression.`);
        }
        return data[this.value];
    }
    extractRefinementFromQuery() {
        return null;
    }
    getQueryParams() {
        return new Map([[this.value, this.evalType]]);
    }
    isConstant() {
        return false;
    }
}
class refiner_BuiltIn extends refiner_RefinementExpression {
    constructor(value, evalType) {
        super('BuiltInNode', evalType);
        this.value = value;
    }
    static fromAst(expression, _typeData) {
        const type = () => {
            switch (expression.value) {
                case 'now':
                case 'creationTime':
                case 'expirationTime':
                    return 'Instant';
                default:
                    throw new Error(`Unresolved built in name '${expression.value}' in the refinement expression.`);
            }
        };
        return new refiner_BuiltIn(expression.value, type());
    }
    toLiteral() {
        return {
            kind: this.kind,
            evalType: this.evalType,
            value: this.value
        };
    }
    static fromLiteral(expr) {
        return new refiner_BuiltIn(expr.value, expr.evalType);
    }
    toString() {
        return `${this.value}()`;
    }
    evaluate(data = null) {
        switch (this.value) {
            case 'now': return new Date().getTime();
            case 'creationTime': return Storable.creationTimestamp(data).getTime();
            case 'expirationTime': return Storable.expirationTimestamp(data).getTime();
            default: throw new Error(`Unhandled BuiltInNode '${this.value}' in evaluate`);
        }
    }
    getFieldParams() {
        return new Map();
    }
    isConstant() {
        return false;
    }
}
class DiscretePrimitive extends refiner_RefinementExpression {
    constructor(value, units = [], evalType) {
        super('DiscretePrimitiveNode', evalType);
        this.value = value;
        // Convert to Si units.
        // For time units, the base unit is milliseconds.
        for (const unit of units) {
            switch (unit) {
                case 'milliseconds':
                    break;
                case 'seconds':
                    this.value *= BigInt(1000);
                    break;
                case 'minutes':
                    this.value *= BigInt(60 * 1000);
                    break;
                case 'hours':
                    this.value *= BigInt(60 * 60 * 1000);
                    break;
                case 'days':
                    this.value *= BigInt(24 * 60 * 60 * 1000);
                    break;
                default:
                    throw new Error(`Unsupported units ${unit}`);
            }
        }
    }
    static fromAst(expression) {
        return new DiscretePrimitive(expression.value, expression.units || [], expression.type);
    }
    toLiteral() {
        return {
            kind: this.kind,
            evalType: this.evalType,
            value: this.value
        };
    }
    static fromLiteral(expr) {
        return new DiscretePrimitive(expr['value'], expr['units'], expr['evalType']);
    }
    toString() {
        const typeIndicator = () => {
            const pluralize = (this.value === BigInt(1) || this.value === BigInt(-1)) ? '' : 's';
            switch (this.evalType) {
                case 'BigInt': return 'n';
                case 'Int': return 'i';
                case 'Long': return 'l';
                case 'Instant': return ` millisecond${pluralize}`;
                default: throw new Error(`unexpected type ${this.evalType}`);
            }
        };
        return `${this.value}${typeIndicator()}`;
    }
    evaluate() {
        return this.value;
    }
}
class NumberPrimitive extends refiner_RefinementExpression {
    constructor(value, units = []) {
        super('NumberPrimitiveNode', 'Number');
        // Convert to Si units.
        this.value = value;
        // For time units, the base unit is milliseconds.
        for (const unit of units) {
            switch (unit) {
                case 'milliseconds':
                    break;
                case 'seconds':
                    this.value *= 1000;
                    break;
                case 'minutes':
                    this.value *= 60 * 1000;
                    break;
                case 'hours':
                    this.value *= 60 * 60 * 1000;
                    break;
                case 'days':
                    this.value *= 24 * 60 * 60 * 1000;
                    break;
                default:
                    throw new Error(`Unsupported units ${unit}`);
            }
        }
    }
    static fromAst(expression) {
        const value = Number(expression.value);
        if (isNaN(value)) {
            // This mirrors the behavior of constructing BigInts, as Number and Number.parseFloat are
            // otherwise inconsistent in their handling of invalid values.
            throw new SyntaxError(`Cannot convert ${expression.value} to a Number`);
        }
        return new NumberPrimitive(value, expression.units || []);
    }
    toLiteral() {
        return {
            kind: this.kind,
            evalType: this.evalType,
            value: this.value
        };
    }
    static fromLiteral(expr) {
        return new NumberPrimitive(expr.value, expr.units);
    }
    toString() {
        return this.value.toString();
    }
    evaluate() {
        return this.value;
    }
}
class BooleanPrimitive extends refiner_RefinementExpression {
    constructor(value) {
        super('BooleanPrimitiveNode', 'Boolean');
        this.value = value;
    }
    static fromAst(expression) {
        return new BooleanPrimitive(expression.value);
    }
    toLiteral() {
        return {
            kind: this.kind,
            evalType: this.evalType,
            value: this.value
        };
    }
    static fromLiteral(expr) {
        return new BooleanPrimitive(expr.value);
    }
    toString() {
        return this.value.toString();
    }
    evaluate() {
        return this.value;
    }
}
class TextPrimitive extends refiner_RefinementExpression {
    constructor(value) {
        super('TextPrimitiveNode', 'Text');
        this.value = value;
    }
    static fromAst(expression) {
        return new TextPrimitive(expression.value);
    }
    toLiteral() {
        return {
            kind: this.kind,
            evalType: this.evalType,
            value: this.value
        };
    }
    static fromLiteral(expr) {
        return new TextPrimitive(expr.value);
    }
    toString() {
        return `'${this.value}'`;
    }
    evaluate() {
        return this.value;
    }
    getTextPrimitives() {
        return new Set([this.value]);
    }
}
class refiner_NumberRange {
    constructor(segs = [], type = 'Number') {
        this.type = type;
        this.segments = [];
        for (const seg of segs) {
            this.unionWithSeg(seg);
        }
    }
    static universal(type) {
        if (type === 'Boolean') {
            return new refiner_NumberRange([NumberSegment.closedClosed(0, 0), NumberSegment.closedClosed(1, 1)], type);
        }
        return new refiner_NumberRange([NumberSegment.closedClosed(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY)], type);
    }
    static unit(val, ty) {
        return new refiner_NumberRange([NumberSegment.closedClosed(val, val)], ty);
    }
    static copyOf(range) {
        return new refiner_NumberRange(range.segments, range.type);
    }
    static unionOf(range1, range2) {
        const newRange = refiner_NumberRange.copyOf(range1);
        newRange.union(range2);
        return newRange;
    }
    complement() {
        return refiner_NumberRange.difference(refiner_NumberRange.universal(this.type), this);
    }
    // difference(A,B) = A\B = A - B
    static difference(range1, range2) {
        const newRange = new refiner_NumberRange([], range1.type);
        for (const seg of range1.segments) {
            const ntrsct = range2.intersectWithSeg(seg);
            let from = { ...seg.from };
            for (const iseg of ntrsct.segments) {
                const to = { ...iseg.from };
                to.isOpen = !to.isOpen;
                if (NumberSegment.isValid(from, to)) {
                    newRange.segments.push(new NumberSegment(from, to));
                }
                from = iseg.to;
                from.isOpen = !from.isOpen;
            }
            const to = { ...seg.to };
            if (NumberSegment.isValid(from, to)) {
                newRange.segments.push(new NumberSegment(from, to));
            }
        }
        return newRange;
    }
    equals(range) {
        if (this.segments.length !== range.segments.length) {
            return false;
        }
        for (let i = 0; i < this.segments.length; i++) {
            if (!this.segments[i].equals(range.segments[i])) {
                return false;
            }
        }
        return true;
    }
    isSubsetOf(range) {
        return this.equals(this.intersect(range));
    }
    union(range) {
        for (const seg of range.segments) {
            this.unionWithSeg(seg);
        }
    }
    intersect(range) {
        const newRange = new refiner_NumberRange();
        for (const seg of range.segments) {
            const dup = this.intersectWithSeg(seg);
            newRange.union(dup);
        }
        return newRange;
    }
    unionWithSeg(seg) {
        let i = 0;
        for (const subRange of this.segments) {
            if (seg.isGreaterThan(subRange, false)) {
                i += 1;
            }
            else if (seg.mergeableWith(subRange)) {
                seg.from = NumberSegment.min(subRange.from, seg.from, false);
            }
            else {
                break;
            }
        }
        let j = this.segments.length;
        for (const subRange of this.segments.slice().reverse()) {
            if (seg.isLessThan(subRange, false)) {
                j -= 1;
            }
            else if (seg.mergeableWith(subRange)) {
                seg.to = NumberSegment.max(subRange.to, seg.to, false);
            }
            else {
                break;
            }
        }
        this.segments.splice(i, j - i, seg);
    }
    intersectWithSeg(seg) {
        const newRange = new refiner_NumberRange();
        for (const subRange of this.segments) {
            if (subRange.overlapsWith(seg)) {
                newRange.segments.push(NumberSegment.overlap(seg, subRange));
            }
        }
        return newRange;
    }
    // This function assumes that the expression is univariate
    // and has been normalized (see Refinement.normalize for definition).
    // TODO(ragdev): Currently only Number and Boolean types are supported. Add String support.
    static fromExpression(expr, textToNum = {}) {
        if (expr instanceof refiner_BinaryExpression) {
            if (expr.leftExpr instanceof FieldNamePrimitive && expr.rightExpr instanceof NumberPrimitive) {
                return refiner_NumberRange.makeInitialGivenOp(expr.rightExpr.evalType, expr.operator.op, expr.rightExpr.value);
            }
            if (expr.leftExpr instanceof FieldNamePrimitive && expr.rightExpr instanceof TextPrimitive) {
                return refiner_NumberRange.makeInitialGivenOp(expr.rightExpr.evalType, expr.operator.op, textToNum[expr.rightExpr.value]);
            }
            const left = refiner_NumberRange.fromExpression(expr.leftExpr, textToNum);
            const right = refiner_NumberRange.fromExpression(expr.rightExpr, textToNum);
            return refiner_NumberRange.updateGivenOp(expr.operator.op, [left, right]);
        }
        if (expr instanceof refiner_UnaryExpression) {
            const rg = refiner_NumberRange.fromExpression(expr.expr, textToNum);
            return refiner_NumberRange.updateGivenOp(expr.operator.op, [rg]);
        }
        if (expr instanceof FieldNamePrimitive && expr.evalType === 'Boolean') {
            return refiner_NumberRange.unit(1, 'Boolean');
        }
        if (expr instanceof BooleanPrimitive && expr.evalType === 'Boolean') {
            return refiner_NumberRange.universal('~query_arg_type');
        }
        // This represents cases that the refinement system cannot solve statically.
        return null;
    }
    static makeInitialGivenOp(type, op, val) {
        switch (op) {
            case Op.LT: return new refiner_NumberRange([NumberSegment.closedOpen(Number.NEGATIVE_INFINITY, val)], type);
            case Op.LTE: return new refiner_NumberRange([NumberSegment.closedClosed(Number.NEGATIVE_INFINITY, val)], type);
            case Op.GT: return new refiner_NumberRange([NumberSegment.openClosed(val, Number.POSITIVE_INFINITY)], type);
            case Op.GTE: return new refiner_NumberRange([NumberSegment.closedClosed(val, Number.POSITIVE_INFINITY)], type);
            case Op.EQ: return new refiner_NumberRange([NumberSegment.closedClosed(val, val)], type);
            case Op.NEQ: return new refiner_NumberRange([NumberSegment.closedClosed(val, val)], type).complement();
            default: throw new Error(`Unsupported operator: field ${op} number`);
        }
    }
    static updateGivenOp(op, ranges) {
        switch (op) {
            case Op.AND: {
                return ranges[0].intersect(ranges[1]);
            }
            case Op.OR: {
                return refiner_NumberRange.unionOf(ranges[0], ranges[1]);
            }
            case Op.EQ: {
                const lc = ranges[0].complement();
                const rc = ranges[1].complement();
                const lnr = ranges[0].intersect(ranges[1]);
                const lcnrc = lc.intersect(rc);
                return refiner_NumberRange.unionOf(lnr, lcnrc);
            }
            case Op.NEQ: {
                const lc = ranges[0].complement();
                const rc = ranges[1].complement();
                const lnrc = ranges[0].intersect(rc);
                const lcnr = lc.intersect(ranges[1]);
                return refiner_NumberRange.unionOf(lnrc, lcnr);
            }
            case Op.NOT: {
                return ranges[0].complement();
            }
            default: {
                throw new Error(`Unsupported operator '${op}': cannot update range`);
            }
        }
    }
}
class NumberSegment {
    constructor(from, to) {
        if (!NumberSegment.isValid(from, to)) {
            throw new Error(`Invalid range from: ${from.val}, open:${from.isOpen}, to: ${to.val}, open:${to.isOpen}`);
        }
        this.from = { ...from };
        this.to = { ...to };
    }
    static isValid(from, to) {
        if (to.val === undefined || from.val === undefined) {
            return false;
        }
        if ((to.val === Infinity || to.val === -Infinity) && to.isOpen) {
            return false;
        }
        if ((from.val === Infinity || from.val === -Infinity) && from.isOpen) {
            return false;
        }
        if (to.val < from.val) {
            return false;
        }
        else if (from.val === to.val && (from.isOpen || to.isOpen)) {
            return false;
        }
        return true;
    }
    static closedClosed(from, to) {
        return new NumberSegment({ val: from, isOpen: false }, { val: to, isOpen: false });
    }
    static openOpen(from, to) {
        return new NumberSegment({ val: from, isOpen: true }, { val: to, isOpen: true });
    }
    static closedOpen(from, to) {
        return new NumberSegment({ val: from, isOpen: false }, { val: to, isOpen: true });
    }
    static openClosed(from, to) {
        return new NumberSegment({ val: from, isOpen: true }, { val: to, isOpen: false });
    }
    equals(seg) {
        return this.from.isOpen === seg.from.isOpen &&
            this.from.val === seg.from.val &&
            this.to.isOpen === seg.to.isOpen &&
            this.to.val === seg.to.val;
    }
    // If strict is false, (a,x) is NOT less than [x,b)
    // even though mathematically it is.
    isLessThan(seg, strict) {
        if (this.to.val === seg.from.val) {
            if (strict) {
                return this.to.isOpen || seg.from.isOpen;
            }
            return this.to.isOpen && seg.from.isOpen;
        }
        return this.to.val < seg.from.val;
    }
    // If strict is false, (x,a) is NOT greater than (b,x]
    // even though mathematically it is.
    isGreaterThan(seg, strict) {
        if (this.from.val === seg.to.val) {
            if (strict) {
                return this.from.isOpen || seg.to.isOpen;
            }
            return this.from.isOpen && seg.to.isOpen;
        }
        return this.from.val > seg.to.val;
    }
    mergeableWith(seg) {
        return !this.isLessThan(seg, false) && !this.isGreaterThan(seg, false);
    }
    overlapsWith(seg) {
        return !this.isLessThan(seg, true) && !this.isGreaterThan(seg, true);
    }
    static min(a, b, inclusive) {
        if (a.val !== b.val) {
            return (a.val < b.val) ? { ...a } : { ...b };
        }
        return { ...a, isOpen: inclusive ? a.isOpen && b.isOpen : a.isOpen || b.isOpen };
    }
    static max(a, b, inclusive) {
        if (a.val !== b.val) {
            return (a.val < b.val) ? { ...b } : { ...a };
        }
        return { ...a, isOpen: inclusive ? a.isOpen && b.isOpen : a.isOpen || b.isOpen };
    }
    static merge(a, b) {
        if (!a.mergeableWith(b)) {
            throw new Error('Cannot merge non-overlapping segments');
        }
        return new NumberSegment(NumberSegment.min(a.from, b.from, true), NumberSegment.max(a.to, b.to, true));
    }
    static overlap(a, b) {
        if (!a.overlapsWith(b)) {
            throw new Error('Cannot find intersection of non-overlapping segments');
        }
        return new NumberSegment(NumberSegment.max(a.from, b.from, false), NumberSegment.min(a.to, b.to, false));
    }
}
class refiner_BigIntRange {
    constructor(segs = [], type = 'BigInt') {
        this.type = type;
        this.segments = [];
        for (const seg of segs) {
            this.unionWithSeg(seg);
        }
    }
    segmentsForTesting() {
        return this.segments;
    }
    static universal(type) {
        const b0 = BigInt(0);
        const b1 = BigInt(1);
        switch (type) {
            case 'Boolean':
                return new refiner_BigIntRange([BigIntSegment.closedClosed(b0, b0), BigIntSegment.closedClosed(b1, b1)], type);
            case 'Int':
                return new refiner_BigIntRange([BigIntSegment.closedClosed(INT_MIN, INT_MAX)], type);
            case 'Long':
                return new refiner_BigIntRange([BigIntSegment.closedClosed(LONG_MIN, LONG_MAX)], type);
            default:
                // These are used to represent 'infinity'.
                return new refiner_BigIntRange([BigIntSegment.closedClosed('NEGATIVE_INFINITY', 'POSITIVE_INFINITY')], type);
        }
    }
    static unit(val, ty) {
        return new refiner_BigIntRange([BigIntSegment.closedClosed(val, val)], ty);
    }
    static copyOf(range) {
        return new refiner_BigIntRange(range.segments, range.type);
    }
    static unionOf(range1, range2) {
        const newRange = refiner_BigIntRange.copyOf(range1);
        newRange.union(range2);
        return newRange;
    }
    complement() {
        return refiner_BigIntRange.difference(refiner_BigIntRange.universal(this.type), this);
    }
    // difference(A,B) = A\B = A - B
    static difference(range1, range2) {
        const newRange = new refiner_BigIntRange([], range1.type);
        for (const seg of range1.segments) {
            const ntrsct = range2.intersectWithSeg(seg);
            let from = { ...seg.from };
            for (const iseg of ntrsct.segments) {
                const to = { ...iseg.from };
                to.isOpen = !to.isOpen;
                if (BigIntSegment.isValid(from, to)) {
                    newRange.segments.push(new BigIntSegment(from, to));
                }
                from = iseg.to;
                from.isOpen = !from.isOpen;
            }
            const to = { ...seg.to };
            if (BigIntSegment.isValid(from, to)) {
                newRange.segments.push(new BigIntSegment(from, to));
            }
        }
        return newRange;
    }
    equals(range) {
        if (this.segments.length !== range.segments.length) {
            return false;
        }
        for (let i = 0; i < this.segments.length; i++) {
            if (!this.segments[i].equals(range.segments[i])) {
                return false;
            }
        }
        return true;
    }
    isSubsetOf(range) {
        return this.equals(this.intersect(range));
    }
    union(range) {
        for (const seg of range.segments) {
            this.unionWithSeg(seg);
        }
    }
    intersect(range) {
        const newRange = new refiner_BigIntRange([], this.type);
        for (const seg of range.segments) {
            const dup = this.intersectWithSeg(seg);
            newRange.union(dup);
        }
        return newRange;
    }
    unionWithSeg(seg) {
        let i = 0;
        for (const subRange of this.segments) {
            if (seg.isGreaterThan(subRange, false)) {
                i += 1;
            }
            else if (seg.mergeableWith(subRange)) {
                seg.from = BigIntSegment.min(subRange.from, seg.from, false);
            }
            else {
                break;
            }
        }
        let j = this.segments.length;
        for (const subRange of this.segments.slice().reverse()) {
            if (seg.isLessThan(subRange, false)) {
                j -= 1;
            }
            else if (seg.mergeableWith(subRange)) {
                seg.to = BigIntSegment.max(subRange.to, seg.to, false);
            }
            else {
                break;
            }
        }
        this.segments.splice(i, j - i, seg);
    }
    intersectWithSeg(seg) {
        const newRange = new refiner_BigIntRange([], this.type);
        for (const subRange of this.segments) {
            if (subRange.overlapsWith(seg)) {
                newRange.segments.push(BigIntSegment.overlap(seg, subRange));
            }
        }
        return newRange;
    }
    // This function assumes that the expression is univariate
    // and has been normalized (see Refinement.normalize for definition).
    // TODO(ragdev): Currently only BigInt and Boolean types are supported. Add String support.
    static fromExpression(expr, textToNum = {}) {
        if (expr instanceof refiner_BinaryExpression) {
            if (expr.leftExpr instanceof FieldNamePrimitive) {
                if (expr.rightExpr instanceof DiscretePrimitive) {
                    return refiner_BigIntRange.makeInitialGivenOp(expr.leftExpr.evalType, expr.operator.op, expr.rightExpr.value);
                }
                if (expr.rightExpr instanceof TextPrimitive) {
                    return refiner_BigIntRange.makeInitialGivenOp(expr.leftExpr.evalType, expr.operator.op, textToNum[expr.rightExpr.value]);
                }
            }
            const left = refiner_BigIntRange.fromExpression(expr.leftExpr, textToNum);
            const right = refiner_BigIntRange.fromExpression(expr.rightExpr, textToNum);
            return refiner_BigIntRange.updateGivenOp(expr.operator.op, [left, right]);
        }
        if (expr instanceof refiner_UnaryExpression) {
            const rg = refiner_BigIntRange.fromExpression(expr.expr, textToNum);
            return refiner_BigIntRange.updateGivenOp(expr.operator.op, [rg]);
        }
        if (expr instanceof FieldNamePrimitive && expr.evalType === 'Boolean') {
            return refiner_BigIntRange.unit(BigInt(1), 'Boolean');
        }
        if (expr instanceof BooleanPrimitive && expr.evalType === 'Boolean') {
            return refiner_BigIntRange.universal('~query_arg_type');
        }
        // This represents cases that the refinement system cannot solve statically.
        return null;
    }
    static makeInitialGivenOp(type, op, val) {
        const getRange = () => {
            switch (op) {
                case Op.LT: return new refiner_BigIntRange([BigIntSegment.closedOpen('NEGATIVE_INFINITY', val)], type);
                case Op.LTE: return new refiner_BigIntRange([BigIntSegment.closedClosed('NEGATIVE_INFINITY', val)], type);
                case Op.GT: return new refiner_BigIntRange([BigIntSegment.openClosed(val, 'POSITIVE_INFINITY')], type);
                case Op.GTE: return new refiner_BigIntRange([BigIntSegment.closedClosed(val, 'POSITIVE_INFINITY')], type);
                case Op.EQ: return new refiner_BigIntRange([BigIntSegment.closedClosed(val, val)], type);
                case Op.NEQ: return new refiner_BigIntRange([
                    BigIntSegment.closedOpen('NEGATIVE_INFINITY', val),
                    BigIntSegment.openClosed(val, 'POSITIVE_INFINITY')
                ], type);
                default: throw new Error(`Unsupported operator: field ${op} bigint`);
            }
        };
        return refiner_BigIntRange.universal(type).intersect(getRange());
    }
    static updateGivenOp(op, ranges) {
        switch (op) {
            case Op.AND: {
                return ranges[0].intersect(ranges[1]);
            }
            case Op.OR: {
                return refiner_BigIntRange.unionOf(ranges[0], ranges[1]);
            }
            case Op.EQ: {
                const lc = ranges[0].complement();
                const rc = ranges[1].complement();
                const lnr = ranges[0].intersect(ranges[1]);
                const lcnrc = lc.intersect(rc);
                return refiner_BigIntRange.unionOf(lnr, lcnrc);
            }
            case Op.NEQ: {
                const lc = ranges[0].complement();
                const rc = ranges[1].complement();
                const lnrc = ranges[0].intersect(rc);
                const lcnr = lc.intersect(ranges[1]);
                return refiner_BigIntRange.unionOf(lnrc, lcnr);
            }
            case Op.NOT: {
                return ranges[0].complement();
            }
            default: {
                throw new Error(`Unsupported operator '${op}': cannot update range`);
            }
        }
    }
}
class BigIntSegment {
    constructor(from, to) {
        // BigInt's have a special property, that x < y -> x <= y-1.
        // and x > z -> x >= z+1.
        // Therefore
        if (from.isOpen && typeof from.val === 'bigint') {
            from.isOpen = false;
            from.val += BigInt(1);
        }
        if (to.isOpen && typeof to.val === 'bigint') {
            to.isOpen = false;
            to.val -= BigInt(1);
        }
        if (!BigIntSegment.isValid(from, to)) {
            throw new Error(`Invalid range from: ${from.val}, open:${from.isOpen}, to: ${to.val}, open:${to.isOpen}`);
        }
        this.from = { ...from };
        this.to = { ...to };
    }
    toString() {
        const fromVal = this.from.val === 'NEGATIVE_INFINITY' ? '-∞' : this.from.val;
        const toVal = this.to.val === 'POSITIVE_INFINITY' ? '∞' : this.to.val;
        const fromBound = this.from.isOpen ? '(' : '[';
        const toBound = this.to.isOpen ? ')' : ']';
        return `${fromBound}${fromVal}, ${toVal}${toBound}`;
    }
    static isValid(from, to) {
        if (to.val === undefined || from.val === undefined) {
            return false;
        }
        if (from.val === 'NEGATIVE_INFINITY') {
            return to.val !== 'NEGATIVE_INFINITY' && !from.isOpen;
        }
        if (to.val === 'POSITIVE_INFINITY') {
            return from.val !== 'POSITIVE_INFINITY' && !to.isOpen;
        }
        if (to.val < from.val) {
            return false;
        }
        else if (from.val === to.val && (from.isOpen || to.isOpen)) {
            return false;
        }
        return true;
    }
    static closedClosed(from, to) {
        return new BigIntSegment({ val: from, isOpen: false }, { val: to, isOpen: false });
    }
    static openOpen(from, to) {
        return new BigIntSegment({ val: from, isOpen: true }, { val: to, isOpen: true });
    }
    static closedOpen(from, to) {
        return new BigIntSegment({ val: from, isOpen: false }, { val: to, isOpen: true });
    }
    static openClosed(from, to) {
        return new BigIntSegment({ val: from, isOpen: true }, { val: to, isOpen: false });
    }
    equals(seg) {
        return this.from.isOpen === seg.from.isOpen &&
            this.from.val === seg.from.val &&
            this.to.isOpen === seg.to.isOpen &&
            this.to.val === seg.to.val;
    }
    // If strict is false, (a,x) is NOT less than [x,b)
    // even though mathematically it is.
    isLessThan(seg, strict) {
        if (this.to.val === seg.from.val) {
            if (strict) {
                return this.to.isOpen || seg.from.isOpen;
            }
            return this.to.isOpen && seg.from.isOpen;
        }
        return BigIntSegment.gt(seg.from, this.to);
    }
    // If strict is false, (x,a) is NOT greater than (b,x]
    // even though mathematically it is.
    isGreaterThan(seg, strict) {
        if (this.from.val === seg.to.val) {
            if (strict) {
                return this.from.isOpen || seg.to.isOpen;
            }
            return this.from.isOpen && seg.to.isOpen;
        }
        return BigIntSegment.gt(this.from, seg.to);
    }
    mergeableWith(seg) {
        return !this.isLessThan(seg, false) && !this.isGreaterThan(seg, false);
    }
    overlapsWith(seg) {
        return !this.isLessThan(seg, true) && !this.isGreaterThan(seg, true);
    }
    static gt(a, b) {
        return (a.val === 'POSITIVE_INFINITY' || b.val === 'NEGATIVE_INFINITY' || (typeof a.val === 'bigint' && typeof b.val === 'bigint' && a.val > b.val));
    }
    static min(a, b, inclusive) {
        if (a.val !== b.val) {
            return BigIntSegment.gt(a, b) ? { ...b } : { ...a };
        }
        return { ...a, isOpen: inclusive ? a.isOpen && b.isOpen : a.isOpen || b.isOpen };
    }
    static max(a, b, inclusive) {
        if (a.val !== b.val) {
            return BigIntSegment.gt(a, b) ? { ...a } : { ...b };
        }
        return { ...a, isOpen: inclusive ? a.isOpen && b.isOpen : a.isOpen || b.isOpen };
    }
    static merge(a, b) {
        if (!a.mergeableWith(b)) {
            throw new Error('Cannot merge non-overlapping segments');
        }
        return new BigIntSegment(BigIntSegment.min(a.from, b.from, true), BigIntSegment.max(a.to, b.to, true));
    }
    static overlap(a, b) {
        if (!a.overlapsWith(b)) {
            throw new Error('Cannot find intersection of non-overlapping segments');
        }
        return new BigIntSegment(BigIntSegment.max(a.from, b.from, false), BigIntSegment.min(a.to, b.to, false));
    }
}
const numericTypes = ['~query_arg_type', 'Number', ...discreteTypes];
// From https://kotlinlang.org/docs/reference/basic-types.html
const INT_MIN = BigInt('-2147483648'); // -2**31
const INT_MAX = BigInt('2147483647'); // 2**31 - 1
const LONG_MIN = BigInt('-9223372036854775808'); // -2**63
const LONG_MAX = BigInt('9223372036854775807'); // 2**63 - 1
const operatorTable = {
    // Booleans
    [Op.NOT]: { nArgs: 1, argType: ['Boolean'], evalType: 'Boolean' },
    [Op.AND]: { nArgs: 2, argType: ['Boolean'], evalType: 'Boolean' },
    [Op.OR]: { nArgs: 2, argType: ['Boolean'], evalType: 'Boolean' },
    // Numerics
    [Op.ADD]: { nArgs: 2, argType: numericTypes, evalType: 'same' },
    [Op.SUB]: { nArgs: 2, argType: numericTypes, evalType: 'same' },
    [Op.MUL]: { nArgs: 2, argType: numericTypes, evalType: 'same' },
    [Op.DIV]: { nArgs: 2, argType: numericTypes, evalType: 'same' },
    [Op.NEG]: { nArgs: 1, argType: numericTypes, evalType: 'same' },
    // Numeric Comparisons
    [Op.LT]: { nArgs: 2, argType: numericTypes, evalType: 'Boolean' },
    [Op.GT]: { nArgs: 2, argType: numericTypes, evalType: 'Boolean' },
    [Op.LTE]: { nArgs: 2, argType: numericTypes, evalType: 'Boolean' },
    [Op.GTE]: { nArgs: 2, argType: numericTypes, evalType: 'Boolean' },
    // Comparisons
    [Op.EQ]: { nArgs: 2, argType: 'same', evalType: 'Boolean' },
    [Op.NEQ]: { nArgs: 2, argType: 'same', evalType: 'Boolean' },
};
const evalTable = {
    // Booleans
    [Op.NOT]: e => !e[0],
    [Op.AND]: e => e[0] && e[1],
    [Op.OR]: e => e[0] || e[1],
    // Numerics
    [Op.ADD]: (e) => {
        // Note: These operators support automatic casting of bigint types to number.
        // The type system enforces that these are not used in `validateOperandCompatibility`.
        if (typeof e[0] === 'number' || typeof e[1] === 'number') {
            return Number(e[0]) + Number(e[1]);
        }
        return e[0] + e[1];
    },
    [Op.SUB]: (e) => {
        if (typeof e[0] === 'number' || typeof e[1] === 'number') {
            return Number(e[0]) - Number(e[1]);
        }
        return e[0] - e[1];
    },
    [Op.MUL]: (e) => {
        if (typeof e[0] === 'number' || typeof e[1] === 'number') {
            return Number(e[0]) * Number(e[1]);
        }
        return e[0] * e[1];
    },
    [Op.DIV]: (e) => {
        if (typeof e[0] === 'number' || typeof e[1] === 'number') {
            return Number(e[0]) / Number(e[1]);
        }
        return e[0] / e[1];
    },
    [Op.NEG]: e => -e[0],
    // Numeric Comparisons (javascript already supports number and bigint comparisons here)
    [Op.LT]: e => e[0] < e[1],
    [Op.GT]: e => e[0] > e[1],
    [Op.LTE]: e => e[0] <= e[1],
    [Op.GTE]: e => e[0] >= e[1],
    // Comparisons
    [Op.EQ]: (e) => {
        if (typeof e[0] === 'number' || typeof e[1] === 'number') {
            return Number(e[0]) === Number(e[1]);
        }
        return e[0] === e[1];
    },
    [Op.NEQ]: (e) => {
        if (typeof e[0] === 'number' || typeof e[1] === 'number') {
            return Number(e[0]) !== Number(e[1]);
        }
        return e[0] !== e[1];
    },
};
class refiner_RefinementOperator {
    constructor(operator) {
        this.updateOp(operator);
    }
    toLiteral() {
        return this.op;
    }
    static fromLiteral(refOpr) {
        return new refiner_RefinementOperator(refOpr);
    }
    flip() {
        switch (this.op) {
            case Op.LT:
                this.updateOp(Op.GT);
                break;
            case Op.GT:
                this.updateOp(Op.LT);
                break;
            case Op.LTE:
                this.updateOp(Op.GTE);
                break;
            case Op.GTE:
                this.updateOp(Op.LTE);
                break;
            default: break;
        }
    }
    updateOp(operator) {
        this.op = operator;
        if (!operatorTable[this.op]) {
            throw new Error(`Invalid refinement operator ${operator}`);
        }
    }
    eval(exprs) {
        return evalTable[this.op](exprs);
    }
}
// A constant is represented by an empty Term object, where there is no indeterminate.
const CONSTANT = '{}';
class refiner_NumberFraction {
    constructor(n, d) {
        this.type = 'Number';
        this.num = n ? refiner_NumberMultinomial.copyOf(n) : new refiner_NumberMultinomial();
        this.den = d ? refiner_NumberMultinomial.copyOf(d) : new refiner_NumberMultinomial({ [CONSTANT]: 1 });
        if (this.den.isZero()) {
            throw new Error('Division by zero.');
        }
        this.reduce();
    }
    static add(a, b) {
        const den = refiner_NumberMultinomial.multiply(a.den, b.den);
        const num = refiner_NumberMultinomial.add(refiner_NumberMultinomial.multiply(a.num, b.den), refiner_NumberMultinomial.multiply(b.num, a.den));
        return new refiner_NumberFraction(num, den);
    }
    static negate(a) {
        return new refiner_NumberFraction(refiner_NumberMultinomial.negate(a.num), a.den);
    }
    static subtract(a, b) {
        const negB = refiner_NumberFraction.negate(b);
        return refiner_NumberFraction.add(a, negB);
    }
    static multiply(a, b) {
        return new refiner_NumberFraction(refiner_NumberMultinomial.multiply(a.num, b.num), refiner_NumberMultinomial.multiply(a.den, b.den));
    }
    static divide(a, b) {
        const invB = new refiner_NumberFraction(b.den, b.num);
        return refiner_NumberFraction.multiply(a, invB);
    }
    fracLessThanZero() {
        const ngt0 = this.num.toExpression(Op.GT);
        const nlt0 = this.num.toExpression(Op.LT);
        const dgt0 = this.den.toExpression(Op.GT);
        const dlt0 = this.den.toExpression(Op.LT);
        const left = new refiner_BinaryExpression(ngt0, dlt0, new refiner_RefinementOperator(Op.AND));
        const right = new refiner_BinaryExpression(nlt0, dgt0, new refiner_RefinementOperator(Op.AND));
        return new refiner_BinaryExpression(left, right, new refiner_RefinementOperator(Op.OR));
    }
    fracGreaterThanZero() {
        const ngt0 = this.num.toExpression(Op.GT);
        const nlt0 = this.num.toExpression(Op.LT);
        const dgt0 = this.den.toExpression(Op.GT);
        const dlt0 = this.den.toExpression(Op.LT);
        return new refiner_BinaryExpression(new refiner_BinaryExpression(ngt0, dgt0, new refiner_RefinementOperator(Op.AND)), new refiner_BinaryExpression(nlt0, dlt0, new refiner_RefinementOperator(Op.AND)), new refiner_RefinementOperator(Op.OR));
    }
    fracEqualsToZero() {
        const neq0 = this.num.toExpression(Op.EQ);
        if (this.den.isConstant() && !this.den.isZero()) {
            return neq0; // TODO(cypher1): This normalizer should be doing this for us.
        }
        const dneq0 = this.den.toExpression(Op.NEQ);
        return new refiner_BinaryExpression(neq0, dneq0, new refiner_RefinementOperator(Op.AND));
    }
    reduce() {
        if (this.num.isZero()) {
            this.den = new refiner_NumberMultinomial({ [CONSTANT]: 1 });
            return;
        }
        if (this.num.isConstant() &&
            this.den.isConstant() &&
            Number.isInteger(this.num.terms[CONSTANT]) &&
            Number.isInteger(this.den.terms[CONSTANT])) {
            const gcd = (a, b) => {
                a = Math.abs(a);
                b = Math.abs(b);
                return b === 0 ? a : gcd(b, a % b);
            };
            const g = gcd(this.num.terms[CONSTANT], this.den.terms[CONSTANT]);
            this.num = new refiner_NumberMultinomial({ [CONSTANT]: this.num.terms[CONSTANT] / g });
            this.den = new refiner_NumberMultinomial({ [CONSTANT]: this.den.terms[CONSTANT] / g });
            return;
        }
        // TODO(ragdev): NumberFractions can be reduced further by factoring out the gcd of
        // the coeffs in num and den, and then dividing the two. However, since the numbers are floating
        // points, the precision and computation cost of gcd function will be a trade-off to consider.
    }
    // assumes the expression received has an evalType of 'Number'
    static fromExpression(expr) {
        if (expr instanceof refiner_BinaryExpression) {
            const left = refiner_NumberFraction.fromExpression(expr.leftExpr);
            const right = refiner_NumberFraction.fromExpression(expr.rightExpr);
            return refiner_NumberFraction.updateGivenOp(expr.operator.op, [left, right]);
        }
        else if (expr instanceof refiner_UnaryExpression) {
            const fn = refiner_NumberFraction.fromExpression(expr.expr);
            return refiner_NumberFraction.updateGivenOp(expr.operator.op, [fn]);
        }
        else if (expr instanceof FieldNamePrimitive) {
            if (expr.evalType === 'Number') {
                const term = new refiner_NumberTerm({ [expr.value]: 1 });
                return new refiner_NumberFraction(new refiner_NumberMultinomial({ [term.toKey()]: 1 }));
            }
            else {
                throw new Error(`Cannot model expression as NumberFraction: ${expr.toString()}, wrong type: ${expr.evalType}`);
            }
        }
        else if (expr instanceof NumberPrimitive) {
            return new refiner_NumberFraction(new refiner_NumberMultinomial({ [CONSTANT]: expr.value }));
        }
        throw new Error(`Cannot model expression as NumberFraction: ${expr.toString()}`);
    }
    static updateGivenOp(op, fractions) {
        switch (op) {
            case Op.ADD: return refiner_NumberFraction.add(fractions[0], fractions[1]);
            case Op.MUL: return refiner_NumberFraction.multiply(fractions[0], fractions[1]);
            case Op.SUB: return refiner_NumberFraction.subtract(fractions[0], fractions[1]);
            case Op.DIV: return refiner_NumberFraction.divide(fractions[0], fractions[1]);
            case Op.NEG: return refiner_NumberFraction.negate(fractions[0]);
            default:
                throw new Error(`Unsupported operator: '${op}'. Cannot update NumberFraction`);
        }
    }
}
class refiner_BigIntFraction {
    constructor(n, d, type) {
        this.type = type;
        this.num = refiner_BigIntMultinomial.copyOf(n);
        this.den = refiner_BigIntMultinomial.copyOf(d);
        if (this.den.isZero()) {
            throw new Error('Division by zero.');
        }
        this.reduce();
    }
    static onOne(n, type) {
        return new refiner_BigIntFraction(n, refiner_BigIntMultinomial.one(), type);
    }
    static one(type) {
        return refiner_BigIntFraction.onOne(refiner_BigIntMultinomial.one(), type);
    }
    static add(a, b) {
        if (a.type !== b.type) {
            throw new Error(`cannot combine ${a.toString()} and ${b.toString()}, types do not match.`);
        }
        const den = refiner_BigIntMultinomial.multiply(a.den, b.den);
        const num = refiner_BigIntMultinomial.add(refiner_BigIntMultinomial.multiply(a.num, b.den), refiner_BigIntMultinomial.multiply(b.num, a.den));
        return new refiner_BigIntFraction(num, den, a.type);
    }
    static negate(a) {
        return new refiner_BigIntFraction(refiner_BigIntMultinomial.negate(a.num), a.den, a.type);
    }
    static subtract(a, b) {
        if (a.type !== b.type) {
            throw new Error(`cannot combine ${a.toString()} and ${b.toString()}, types do not match.`);
        }
        const negB = refiner_BigIntFraction.negate(b);
        return refiner_BigIntFraction.add(a, negB);
    }
    static multiply(a, b) {
        if (a.type !== b.type) {
            throw new Error(`cannot combine ${a.toString()} and ${b.toString()}, types do not match.`);
        }
        return new refiner_BigIntFraction(refiner_BigIntMultinomial.multiply(a.num, b.num), refiner_BigIntMultinomial.multiply(a.den, b.den), a.type);
    }
    static divide(a, b) {
        if (a.type !== b.type) {
            throw new Error(`cannot combine ${a.toString()} and ${b.toString()}, types do not match.`);
        }
        const invB = new refiner_BigIntFraction(b.den, b.num, a.type);
        return refiner_BigIntFraction.multiply(a, invB);
    }
    fracLessThanZero() {
        const ngt0 = this.num.toExpression(Op.GT, this.type);
        const nlt0 = this.num.toExpression(Op.LT, this.type);
        const dgt0 = this.den.toExpression(Op.GT, this.type);
        const dlt0 = this.den.toExpression(Op.LT, this.type);
        const left = new refiner_BinaryExpression(ngt0, dlt0, new refiner_RefinementOperator(Op.AND));
        const right = new refiner_BinaryExpression(nlt0, dgt0, new refiner_RefinementOperator(Op.AND));
        return new refiner_BinaryExpression(left, right, new refiner_RefinementOperator(Op.OR));
    }
    fracGreaterThanZero() {
        const ngt0 = this.num.toExpression(Op.GT, this.type);
        const nlt0 = this.num.toExpression(Op.LT, this.type);
        const dgt0 = this.den.toExpression(Op.GT, this.type);
        const dlt0 = this.den.toExpression(Op.LT, this.type);
        return new refiner_BinaryExpression(new refiner_BinaryExpression(ngt0, dgt0, new refiner_RefinementOperator(Op.AND)), new refiner_BinaryExpression(nlt0, dlt0, new refiner_RefinementOperator(Op.AND)), new refiner_RefinementOperator(Op.OR));
    }
    fracEqualsToZero() {
        const neq0 = this.num.toExpression(Op.EQ, this.type);
        if (this.den.isConstant() && !this.den.isZero()) {
            return neq0; // TODO(cypher1): This normalizer should be doing this for us.
        }
        const dneq0 = this.den.toExpression(Op.NEQ, this.type);
        return new refiner_BinaryExpression(neq0, dneq0, new refiner_RefinementOperator(Op.AND));
    }
    reduce() {
        if (this.num.isZero()) {
            this.den = refiner_BigIntMultinomial.one();
            return;
        }
        if (this.num.isConstant() &&
            this.den.isConstant()) {
            const gcd = (a, b) => {
                a = a > 0 ? a : -a;
                b = b > 0 ? b : -b; // Because Math.abs doesn't support bigint.
                return b === BigInt(0) ? a : gcd(b, a % b);
            };
            const g = gcd(this.num.terms[CONSTANT], this.den.terms[CONSTANT]);
            this.num = new refiner_BigIntMultinomial({ [CONSTANT]: this.num.terms[CONSTANT] / g });
            this.den = new refiner_BigIntMultinomial({ [CONSTANT]: this.den.terms[CONSTANT] / g });
            return;
        }
        // TODO(ragdev): BigIntFractions can be reduced further by factoring out the gcd of
        // the coeffs in num and den, and then dividing the two. However, since the numbers are floating
        // points, the precision and computation cost of gcd function will be a trade-off to consider.
    }
    // assumes the expression received has an evalType of 'Number'
    static fromExpression(expr) {
        if (expr instanceof refiner_BinaryExpression) {
            const left = refiner_BigIntFraction.fromExpression(expr.leftExpr);
            const right = refiner_BigIntFraction.fromExpression(expr.rightExpr);
            return refiner_BigIntFraction.updateGivenOp(expr.operator.op, [left, right]);
        }
        else if (expr instanceof refiner_UnaryExpression) {
            const fn = refiner_BigIntFraction.fromExpression(expr.expr);
            return refiner_BigIntFraction.updateGivenOp(expr.operator.op, [fn]);
        }
        else if (expr instanceof FieldNamePrimitive) {
            if (discreteTypes.includes(expr.evalType)) {
                const term = new refiner_BigIntTerm({ [expr.value]: BigInt(1) });
                return refiner_BigIntFraction.onOne(new refiner_BigIntMultinomial({ [term.toKey()]: BigInt(1) }), expr.evalType // Safe due to manual check of bigIntTypes list.
                );
            }
            else {
                throw new Error(`Cannot model expression as BigIntFraction: ${expr.toString()}, wrong type: ${expr.evalType}`);
            }
        }
        else if (expr instanceof DiscretePrimitive) {
            return refiner_BigIntFraction.onOne(new refiner_BigIntMultinomial({ [CONSTANT]: expr.value }), expr.evalType);
        }
        throw new Error(`Cannot model expression as BigIntFraction: ${expr.toString()}`);
    }
    static updateGivenOp(op, fractions) {
        switch (op) {
            case Op.ADD: return refiner_BigIntFraction.add(fractions[0], fractions[1]);
            case Op.MUL: return refiner_BigIntFraction.multiply(fractions[0], fractions[1]);
            case Op.SUB: return refiner_BigIntFraction.subtract(fractions[0], fractions[1]);
            case Op.DIV: return refiner_BigIntFraction.divide(fractions[0], fractions[1]);
            case Op.NEG: return refiner_BigIntFraction.negate(fractions[0]);
            default:
                throw new Error(`Unsupported operator: '${op}'. Cannot update BigIntFraction`);
        }
    }
}
class refiner_NumberTerm {
    constructor(indeterminates = {}) {
        this.indeterminates = indeterminates;
    }
    static copyOf(tm) {
        return new refiner_NumberTerm(tm.indeterminates);
    }
    get indeterminates() {
        for (const [indeterminate, power] of Object.entries(this._indeterminates)) {
            if (power === 0) {
                delete this._indeterminates[indeterminate];
            }
        }
        return this._indeterminates;
    }
    set indeterminates(indtrms) {
        this._indeterminates = { ...indtrms };
    }
    toKey() {
        // sort the indeterminates
        const ordered = {};
        const unordered = this.indeterminates;
        Object.keys(unordered).sort().forEach((key) => {
            ordered[key] = unordered[key];
        });
        return JSON.stringify(ordered);
    }
    static fromKey(key) {
        const data = JSON.parse(key);
        for (const [indeterminate, power] of Object.entries(data)) {
            data[indeterminate] = Number(power);
        }
        return new refiner_NumberTerm(data);
    }
    static indeterminateToExpression(fn, pow) {
        if (pow <= 0) {
            throw new Error('Pow should be >= 0');
        }
        if (pow === 1) {
            return new FieldNamePrimitive(fn, 'Number');
        }
        const n = Math.floor(pow / 2);
        return new refiner_BinaryExpression(refiner_NumberTerm.indeterminateToExpression(fn, n), refiner_NumberTerm.indeterminateToExpression(fn, pow - n), new refiner_RefinementOperator(Op.MUL));
    }
    // assumes that term is not a constant i.e. not {}
    toExpression() {
        if (Object.keys(this.indeterminates).length === 0) {
            throw new Error('Cannot convert an empty term to expression');
        }
        let expr = null;
        for (const [indeterminate, power] of Object.entries(this.indeterminates)) {
            const indtrExpr = refiner_NumberTerm.indeterminateToExpression(indeterminate, power);
            expr = expr ? new refiner_BinaryExpression(expr, indtrExpr, new refiner_RefinementOperator(Op.MUL)) : indtrExpr;
        }
        return expr;
    }
}
class refiner_NumberMultinomial {
    constructor(terms = {}) {
        this._terms = terms;
    }
    static copyOf(mn) {
        return new refiner_NumberMultinomial(mn.terms);
    }
    get terms() {
        for (const [term, coeff] of Object.entries(this._terms)) {
            if (coeff === 0) {
                delete this._terms[term];
            }
        }
        const ordered = {};
        const unordered = this._terms;
        Object.keys(unordered).sort().forEach((key) => {
            ordered[key] = unordered[key];
        });
        this._terms = ordered;
        return this._terms;
    }
    static add(a, b) {
        const sum = refiner_NumberMultinomial.copyOf(a);
        for (const [term, coeff] of Object.entries(b.terms)) {
            const val = (sum.terms[term] || 0) + coeff;
            sum.terms[term] = val;
        }
        return sum;
    }
    static subtract(a, b) {
        return refiner_NumberMultinomial.add(a, refiner_NumberMultinomial.negate(b));
    }
    static negate(a) {
        const neg = refiner_NumberMultinomial.copyOf(a);
        for (const [term, coeff] of Object.entries(neg.terms)) {
            neg.terms[term] = -coeff;
        }
        return neg;
    }
    static multiply(a, b) {
        const prod = new refiner_NumberMultinomial();
        for (const [aTerm, acoeff] of Object.entries(a.terms)) {
            for (const [bTerm, bcoeff] of Object.entries(b.terms)) {
                const tprod = refiner_NumberTerm.fromKey(aTerm);
                const bterm = refiner_NumberTerm.fromKey(bTerm);
                for (const [indeterminate, power] of Object.entries(bterm.indeterminates)) {
                    const val = power + (tprod.indeterminates[indeterminate] || 0);
                    tprod.indeterminates[indeterminate] = val;
                }
                const val = acoeff * bcoeff + (prod.terms[tprod.toKey()] || 0);
                prod.terms[tprod.toKey()] = val;
            }
        }
        return prod;
    }
    isZero() {
        return Object.keys(this.terms).length === 0;
    }
    isConstant() {
        return this.isZero() || (Object.keys(this.terms).length === 1 && this.terms.hasOwnProperty(CONSTANT));
    }
    getIndeterminates() {
        const indeterminates = new Set();
        for (const tKey of Object.keys(this.terms)) {
            const term = refiner_NumberTerm.fromKey(tKey);
            for (const indeterminate of Object.keys(term.indeterminates)) {
                indeterminates.add(indeterminate);
            }
        }
        return indeterminates;
    }
    isUnivariate() {
        return this.getIndeterminates().size === 1;
    }
    degree() {
        let degree = 0;
        for (const tKey of Object.keys(this.terms)) {
            const term = refiner_NumberTerm.fromKey(tKey);
            let sum = 0;
            for (const power of Object.values(term.indeterminates)) {
                sum += power;
            }
            degree = sum > degree ? sum : degree;
        }
        return degree;
    }
    // returns <multinomial> <op> CONSTANT
    toExpression(op) {
        const operator = new refiner_RefinementOperator(op);
        if (this.isConstant()) {
            return new refiner_BinaryExpression(new NumberPrimitive(this.isZero() ? 0 : this.terms[CONSTANT]), new NumberPrimitive(0), operator);
        }
        if (this.isUnivariate() && this.degree() === 1) {
            const indeterminate = this.getIndeterminates().values().next().value;
            // TODO(ragdev): Implement a neater way to get the leading coefficient
            const leadingCoeff = this.terms[`{"${indeterminate}":1}`];
            const cnst = this.terms[CONSTANT] || 0;
            if (leadingCoeff < 0) {
                operator.flip();
            }
            const scaledCnst = cnst / leadingCoeff;
            return new refiner_BinaryExpression(new FieldNamePrimitive(indeterminate, 'Number'), new NumberPrimitive(-scaledCnst), operator);
        }
        const termToExpression = (tKey, tCoeff) => {
            const termExpr = refiner_NumberTerm.fromKey(tKey).toExpression();
            if (tCoeff === 1) {
                return termExpr;
            }
            return new refiner_BinaryExpression(new NumberPrimitive(tCoeff), termExpr, new refiner_RefinementOperator(Op.MUL));
        };
        let expr = null;
        let cnst = 0;
        for (const [tKey, tCoeff] of Object.entries(this.terms)) {
            if (tKey === CONSTANT) {
                cnst = tCoeff;
            }
            else {
                const termExpr = termToExpression(tKey, tCoeff);
                expr = expr ? new refiner_BinaryExpression(expr, termExpr, new refiner_RefinementOperator(Op.ADD)) : termExpr;
            }
        }
        return new refiner_BinaryExpression(expr, new NumberPrimitive(-cnst), operator);
    }
}
class refiner_BigIntTerm {
    constructor(indeterminates = {}) {
        this.indeterminates = indeterminates;
    }
    static copyOf(tm) {
        return new refiner_BigIntTerm(tm.indeterminates);
    }
    get indeterminates() {
        for (const [indeterminate, power] of Object.entries(this._indeterminates)) {
            if (power === BigInt(0)) {
                delete this._indeterminates[indeterminate];
            }
        }
        return this._indeterminates;
    }
    set indeterminates(indtrms) {
        this._indeterminates = { ...indtrms };
    }
    toKey() {
        // sort the indeterminates
        const ordered = {};
        const unordered = this.indeterminates;
        Object.keys(unordered).sort().forEach((key) => {
            ordered[key] = unordered[key];
        });
        return JSON.stringify(ordered, (_key, value) => typeof value === 'bigint'
            ? value.toString() // Workaround for JSON not supporting bigint.
            : value // return everything else unchanged
        );
    }
    static fromKey(key) {
        const data = JSON.parse(key);
        for (const [indeterminate, power] of Object.entries(data)) {
            data[indeterminate] = BigInt(power);
        }
        return new refiner_BigIntTerm(data);
    }
    static indeterminateToExpression(fn, pow) {
        if (pow <= 0) {
            throw new Error('Pow should be >= 0');
        }
        if (pow === BigInt(1)) {
            return new FieldNamePrimitive(fn, 'BigInt');
        }
        const n = pow / BigInt(2);
        return new refiner_BinaryExpression(refiner_BigIntTerm.indeterminateToExpression(fn, n), refiner_BigIntTerm.indeterminateToExpression(fn, pow - n), new refiner_RefinementOperator(Op.MUL));
    }
    // assumes that term is not a constant i.e. not {}
    toExpression() {
        if (Object.keys(this.indeterminates).length === 0) {
            throw new Error('Cannot convert an empty term to expression');
        }
        let expr = null;
        for (const [indeterminate, power] of Object.entries(this.indeterminates)) {
            const indtrExpr = refiner_BigIntTerm.indeterminateToExpression(indeterminate, power);
            expr = expr ? new refiner_BinaryExpression(expr, indtrExpr, new refiner_RefinementOperator(Op.MUL)) : indtrExpr;
        }
        return expr;
    }
}
class refiner_BigIntMultinomial {
    constructor(terms = {}) {
        this._terms = terms;
    }
    static one() {
        return new refiner_BigIntMultinomial({ [CONSTANT]: BigInt(1) });
    }
    static copyOf(mn) {
        return new refiner_BigIntMultinomial(mn.terms);
    }
    get terms() {
        for (const [term, coeff] of Object.entries(this._terms)) {
            if (coeff === BigInt(0)) {
                delete this._terms[term];
            }
        }
        const ordered = {};
        const unordered = this._terms;
        Object.keys(unordered).sort().forEach((key) => {
            ordered[key] = unordered[key];
        });
        this._terms = ordered;
        return this._terms;
    }
    static add(a, b) {
        const sum = refiner_BigIntMultinomial.copyOf(a);
        for (const [term, coeff] of Object.entries(b.terms)) {
            const val = (sum.terms[term] || BigInt(0)) + coeff;
            sum.terms[term] = val;
        }
        return sum;
    }
    static subtract(a, b) {
        return refiner_BigIntMultinomial.add(a, refiner_BigIntMultinomial.negate(b));
    }
    static negate(a) {
        const neg = refiner_BigIntMultinomial.copyOf(a);
        for (const [term, coeff] of Object.entries(neg.terms)) {
            neg.terms[term] = -coeff;
        }
        return neg;
    }
    static multiply(a, b) {
        const prod = new refiner_BigIntMultinomial();
        for (const [aTerm, acoeff] of Object.entries(a.terms)) {
            for (const [bTerm, bcoeff] of Object.entries(b.terms)) {
                const tprod = refiner_BigIntTerm.fromKey(aTerm);
                const bterm = refiner_BigIntTerm.fromKey(bTerm);
                for (const [indeterminate, power] of Object.entries(bterm.indeterminates)) {
                    const newPow = tprod.indeterminates[indeterminate] || 0;
                    const val = BigInt(power) + BigInt(newPow);
                    tprod.indeterminates[indeterminate] = val;
                }
                const val = acoeff * bcoeff + (prod.terms[tprod.toKey()] || BigInt(0));
                prod.terms[tprod.toKey()] = val;
            }
        }
        return prod;
    }
    isZero() {
        return Object.keys(this.terms).length === 0;
    }
    isConstant() {
        return this.isZero() || (Object.keys(this.terms).length === 1 && this.terms.hasOwnProperty(CONSTANT));
    }
    getIndeterminates() {
        const indeterminates = new Set();
        for (const tKey of Object.keys(this.terms)) {
            const term = refiner_BigIntTerm.fromKey(tKey);
            for (const indeterminate of Object.keys(term.indeterminates)) {
                indeterminates.add(indeterminate);
            }
        }
        return indeterminates;
    }
    isUnivariate() {
        return this.getIndeterminates().size === 1;
    }
    degree() {
        let degree = BigInt(0);
        for (const tKey of Object.keys(this.terms)) {
            const term = refiner_BigIntTerm.fromKey(tKey);
            let sum = BigInt(0);
            for (const power of Object.values(term.indeterminates)) {
                sum += power;
            }
            degree = sum > degree ? sum : degree;
        }
        return degree;
    }
    // returns <multinomial> <op> CONSTANT
    toExpression(op, type) {
        if (this.isConstant()) {
            return new refiner_BinaryExpression(new DiscretePrimitive(this.isZero() ? BigInt(0) : this.terms[CONSTANT], [], type), new DiscretePrimitive(BigInt(0), [], type), new refiner_RefinementOperator(op));
        }
        if (this.isUnivariate() && this.degree() === BigInt(1)) {
            const operator = new refiner_RefinementOperator(op);
            const indeterminate = this.getIndeterminates().values().next().value;
            // TODO(ragdev): Implement a neater way to get the leading coefficient
            const leadingCoeff = this.terms[`{"${indeterminate}":"1"}`];
            const cnst = this.terms[CONSTANT] || BigInt(0);
            if (leadingCoeff < BigInt(0)) {
                operator.flip();
            }
            const scaledCnst = cnst / leadingCoeff;
            return new refiner_BinaryExpression(new FieldNamePrimitive(indeterminate, 'BigInt'), new DiscretePrimitive(-scaledCnst, [], type), operator);
        }
        const termToExpression = (tKey, tCoeff) => {
            const termExpr = refiner_BigIntTerm.fromKey(tKey).toExpression();
            if (tCoeff === BigInt(1)) {
                return termExpr;
            }
            return new refiner_BinaryExpression(new DiscretePrimitive(tCoeff, [], type), termExpr, new refiner_RefinementOperator(Op.MUL));
        };
        let expr = null;
        let cnst = BigInt(0);
        for (const [tKey, tCoeff] of Object.entries(this.terms)) {
            if (tKey === CONSTANT) {
                cnst = tCoeff;
            }
            else {
                const termExpr = termToExpression(tKey, tCoeff);
                expr = expr ? new refiner_BinaryExpression(expr, termExpr, new refiner_RefinementOperator(Op.ADD)) : termExpr;
            }
        }
        return new refiner_BinaryExpression(expr, new DiscretePrimitive(-cnst, [], type), new refiner_RefinementOperator(op));
    }
}
class refiner_Normalizer {
    // Updates 'expr' after rearrangement.
    static rearrangeNumericalExpression(expr) {
        // TODO(cypher1): Use Number or BigInt here
        try {
            const lF = refiner_NumberFraction.fromExpression(expr.leftExpr);
            const rF = refiner_NumberFraction.fromExpression(expr.rightExpr);
            const frac = refiner_NumberFraction.subtract(lF, rF);
            let rearranged = null;
            switch (expr.operator.op) {
                case Op.LT:
                    rearranged = frac.fracLessThanZero();
                    break;
                case Op.GT:
                    rearranged = frac.fracGreaterThanZero();
                    break;
                case Op.EQ:
                    rearranged = frac.fracEqualsToZero();
                    break;
                default:
                    throw new Error(`Unsupported operator ${expr.operator.op}: cannot rearrange numerical expression.`);
            }
            expr.update(rearranged);
        }
        catch {
            const lF = refiner_BigIntFraction.fromExpression(expr.leftExpr);
            const rF = refiner_BigIntFraction.fromExpression(expr.rightExpr);
            const frac = refiner_BigIntFraction.subtract(lF, rF);
            let rearranged = null;
            switch (expr.operator.op) {
                case Op.LT:
                    rearranged = frac.fracLessThanZero();
                    break;
                case Op.GT:
                    rearranged = frac.fracGreaterThanZero();
                    break;
                case Op.EQ:
                    rearranged = frac.fracEqualsToZero();
                    break;
                default:
                    throw new Error(`Unsupported operator ${expr.operator.op}: cannot rearrange numerical expression.`);
            }
            expr.update(rearranged);
        }
    }
}
/**
 * A visitor for the refinement expression to aid translation of refinement expressions
 * into expressions in another language, e.g. SQL or Kotlin.
 */
class RefinementExpressionVisitor {
    generate(refinement) {
        refinement.normalize();
        return this.visit(refinement.expression);
    }
    visit(expression) {
        switch (expression.kind) {
            case 'BinaryExpressionNode':
                return this.visitBinaryExpression(expression);
            case 'BuiltInNode':
                return this.visitBuiltIn(expression);
            case 'FieldNamePrimitiveNode':
                return this.visitFieldNamePrimitive(expression);
            case 'NumberPrimitiveNode':
                return this.visitNumberPrimitive(expression);
            case 'DiscretePrimitiveNode':
                return this.visitDiscretePrimitive(expression);
            case 'QueryArgumentPrimitiveNode':
                return this.visitQueryArgumentPrimitive(expression);
            case 'TextPrimitiveNode':
                return this.visitTextPrimitive(expression);
            case 'UnaryExpressionNode':
                return this.visitUnaryExpression(expression);
            default:
                throw new Error(`Unsupported refinement expression kind ${expression.kind}`);
        }
    }
}
//# sourceMappingURL=refiner.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/types/internal/schema-field.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */



class schema_field_FieldType {
    constructor(kind) {
        this.kind = kind;
        this.refinement = null;
        this.annotations = [];
    }
    get isPrimitive() { return this.kind === SchemaFieldKind.Primitive; }
    get isKotlinPrimitive() { return this.kind === SchemaFieldKind.KotlinPrimitive; }
    get isCollection() { return this.kind === SchemaFieldKind.Collection; }
    get isReference() { return this.kind === SchemaFieldKind.Reference; }
    get isOrderedList() { return this.kind === SchemaFieldKind.OrderedList; }
    get isUnion() { return this.kind === SchemaFieldKind.Union; }
    get isTuple() { return this.kind === SchemaFieldKind.Tuple; }
    get isNested() { return this.kind === SchemaFieldKind.Nested; }
    get isInline() { return this.kind === SchemaFieldKind.Inline || this.kind === SchemaFieldKind.TypeName; }
    getType() { return null; }
    getFieldTypes() { return null; }
    getFieldType() { return null; }
    getEntityType() { return null; }
    clone() {
        // tslint:disable-next-line: no-any
        const literal = this.toLiteral();
        if (literal.refinement) {
            literal.refinement = refiner_Refinement.fromLiteral(literal.refinement);
        }
        return schema_field_FieldType.fromLiteral(literal);
    }
    // tslint:disable-next-line: no-any
    toLiteral() {
        return {
            kind: this.kind,
            annotations: this.annotations,
            refinement: this.refinement ? this.refinement.toLiteral() : null
        };
    }
    equals(other) {
        // TODO(cypher1): structural check instead of stringification.
        return this.toString() === other.toString();
    }
    // TODO(shans): output AtLeastAsSpecific here. This is necessary to support
    // refinements on nested structures and references.
    isAtLeastAsSpecificAs(other) {
        external_assert_default()(this.kind === other.kind);
        return this.equals(other);
    }
    static create(theField) {
        let newField = null;
        // tslint:disable-next-line: no-any
        const field = theField;
        if (typeof (field) === 'string') {
            external_assert_default()(['Text', 'URL', 'Number', 'Boolean', 'Bytes'].includes(field), `non-primitive schema type ${field} need to be defined as a parser production`);
            newField = new schema_field_PrimitiveField(field);
        }
        else {
            switch (field.kind) {
                case SchemaFieldKind.Primitive:
                    newField = new schema_field_PrimitiveField(field.type);
                    break;
                case SchemaFieldKind.KotlinPrimitive:
                    newField = new schema_field_KotlinPrimitiveField(field.type);
                    break;
                case SchemaFieldKind.Collection:
                    newField = new schema_field_CollectionField(schema_field_FieldType.create(field.schema));
                    break;
                case SchemaFieldKind.Reference:
                    newField = new schema_field_ReferenceField(schema_field_FieldType.create(field.schema));
                    break;
                case SchemaFieldKind.OrderedList:
                    newField = new schema_field_OrderedListField(schema_field_FieldType.create(field.schema));
                    break;
                case SchemaFieldKind.Inline:
                case SchemaFieldKind.TypeName:
                    newField = new schema_field_InlineField(field.model);
                    break;
                case SchemaFieldKind.Union:
                    newField = new schema_field_UnionField(field.types.map(type => schema_field_FieldType.create(type)));
                    break;
                case SchemaFieldKind.Tuple:
                    newField = new schema_field_TupleField(field.types.map(type => schema_field_FieldType.create(type)));
                    break;
                case SchemaFieldKind.Nested:
                    newField = new schema_field_NestedField(schema_field_FieldType.create(field.schema));
                    break;
                default:
                    throw new Error(`Unsupported schema field ${field.kind}`);
            }
        }
        newField.refinement = field.refinement || null;
        newField.annotations = field.annotations || [];
        return newField;
    }
}
// The implementation of fromLiteral creates a cyclic dependency, so it is
// separated out. This variable serves the purpose of an abstract static.
schema_field_FieldType.fromLiteral = null;
class schema_field_PrimitiveField extends schema_field_FieldType {
    constructor(type) {
        super(SchemaFieldKind.Primitive);
        this.type = type;
        external_assert_default()(this.type);
    }
    getType() { return this.type; }
    toString() { return this.type; }
    normalizeForHash() { return `${this.type}|`; }
    // tslint:disable-next-line: no-any
    toLiteral() {
        return { ...super.toLiteral(), type: this.type };
    }
}
class schema_field_KotlinPrimitiveField extends schema_field_FieldType {
    constructor(type) {
        super(SchemaFieldKind.KotlinPrimitive);
        this.type = type;
    }
    getType() { return this.type; }
    toString() { return this.type; }
    normalizeForHash() { return `${this.type}|`; }
    // tslint:disable-next-line: no-any
    toLiteral() {
        return { ...super.toLiteral(), type: this.type };
    }
}
class schema_field_CollectionField extends schema_field_FieldType {
    constructor(schema) {
        super(SchemaFieldKind.Collection);
        this.schema = schema;
    }
    getFieldType() { return this.schema; }
    getEntityType() {
        return this.getFieldType().getFieldType() ? this.getFieldType().getFieldType().getEntityType() : null;
    }
    toString() { return `[${this.schema.toString()}]`; }
    normalizeForHash() {
        if (this.schema.isPrimitive || this.schema.isKotlinPrimitive) {
            return `[${this.schema.getType()}]`;
        }
        return `[${this.schema.normalizeForHash()}]`;
    }
    isAtLeastAsSpecificAs(other) {
        external_assert_default()(this.kind === other.kind);
        return this.getFieldType().isAtLeastAsSpecificAs(other.getFieldType());
    }
    // tslint:disable-next-line: no-any
    toLiteral() {
        return { ...super.toLiteral(), schema: this.schema.toLiteral() };
    }
}
class schema_field_ReferenceField extends schema_field_FieldType {
    constructor(schema) {
        super(SchemaFieldKind.Reference);
        this.schema = schema;
        external_assert_default()(this.schema);
    }
    getFieldType() { return this.schema; }
    getEntityType() { return this.getFieldType().getEntityType(); }
    toString() { return `&${this.schema.toString()}`; }
    normalizeForHash() { return `&(${this.schema.getEntityType().entitySchema.normalizeForHash()})`; }
    isAtLeastAsSpecificAs(other) {
        external_assert_default()(this.kind === other.kind);
        return this.getFieldType().getEntityType().isAtLeastAsSpecificAs(other.getFieldType().getEntityType());
    }
    // tslint:disable-next-line: no-any
    toLiteral() {
        return {
            ...super.toLiteral(),
            schema: { kind: this.schema.kind, model: this.schema.getEntityType().toLiteral() }
        };
    }
}
class schema_field_OrderedListField extends schema_field_FieldType {
    constructor(schema) {
        super(SchemaFieldKind.OrderedList);
        this.schema = schema;
    }
    getFieldType() { return this.schema; }
    getEntityType() {
        return this.getFieldType().getFieldType() ? this.getFieldType().getFieldType().getEntityType() : null;
    }
    toString() { return `List<${this.schema.toString()}>`; }
    normalizeForHash() {
        if (this.schema.isPrimitive || this.schema.isKotlinPrimitive) {
            return `List<${this.schema.getType()}>`;
        }
        return `List<${this.schema.normalizeForHash()}>`;
    }
    isAtLeastAsSpecificAs(other) {
        external_assert_default()(this.kind === other.kind);
        return this.getFieldType().isAtLeastAsSpecificAs(other.getFieldType());
    }
    // tslint:disable-next-line: no-any
    toLiteral() {
        return { ...super.toLiteral(), schema: this.schema.toLiteral() };
    }
}
class schema_field_UnionField extends schema_field_FieldType {
    constructor(types) {
        super(SchemaFieldKind.Union);
        this.types = types;
    }
    getFieldTypes() { return this.types; }
    toString() { return `(${this.types.map(type => type.toString()).join(' or ')})`; }
    normalizeForHash() { return `(${this.types.map(t => t.getType()).join('|')})`; }
    // tslint:disable-next-line: no-any
    toLiteral() {
        return { ...super.toLiteral(), types: this.types.map(t => t.toLiteral()) };
    }
}
class schema_field_TupleField extends schema_field_FieldType {
    constructor(types) {
        super(SchemaFieldKind.Tuple);
        this.types = types;
    }
    getFieldTypes() { return this.types; }
    toString() { return `(${this.types.map(type => type.toString()).join(', ')})`; }
    normalizeForHash() { return `(${this.types.map(t => t.getType()).join('|')})`; }
    // tslint:disable-next-line: no-any
    toLiteral() {
        return { ...super.toLiteral(), types: this.types.map(t => t.toLiteral()) };
    }
}
class schema_field_NestedField extends schema_field_FieldType {
    constructor(schema) {
        super(SchemaFieldKind.Nested);
        this.schema = schema;
        external_assert_default()(this.schema.isInline);
    }
    getFieldType() { return this.schema; }
    getEntityType() { return this.getFieldType().getEntityType(); }
    toString() { return `inline ${this.schema.toString()}`; }
    normalizeForHash() { return `inline ${this.getEntityType().entitySchema.normalizeForHash()}`; }
    isAtLeastAsSpecificAs(other) {
        external_assert_default()(this.kind === other.kind);
        return this.getEntityType().isAtLeastAsSpecificAs(other.getEntityType());
    }
    // tslint:disable-next-line: no-any
    toLiteral() {
        return { ...super.toLiteral(), schema: this.schema.toLiteral() };
    }
}
class schema_field_InlineField extends schema_field_FieldType {
    constructor(model) {
        super(SchemaFieldKind.Inline);
        this.model = model;
    }
    getEntityType() { return this.model; }
    toString() { return this.getEntityType().getEntitySchema().toInlineSchemaString(); }
    normalizeForHash() { return this.getEntityType().getEntitySchema().normalizeForHash(); }
    // tslint:disable-next-line: no-any
    toLiteral() {
        return { ...super.toLiteral(), model: this.getEntityType() };
    }
}
//# sourceMappingURL=schema-field.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/utils/internal/comparable.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

function compareNulls(o1, o2) {
    if (o1 === o2)
        return 0;
    if (o1 === null)
        return -1;
    return 1;
}
function compareStrings(s1, s2) {
    if (s1 == null || s2 == null)
        return compareNulls(s1, s2);
    return s1.localeCompare(s2);
}
function compareNumbers(n1, n2) {
    if (n1 == null || n2 == null)
        return compareNulls(n1, n2);
    return n1 - n2;
}
function compareBools(b1, b2) {
    if (b1 == null || b2 == null)
        return compareNulls(b1, b2);
    return Number(b1) - Number(b2);
}
function compareArrays(a1, a2, compare) {
    external_assert_default()(a1 != null && a2 != null);
    if (a1.length !== a2.length)
        return compareNumbers(a1.length, a2.length);
    for (let i = 0; i < a1.length; i++) {
        let result;
        if ((result = compare(a1[i], a2[i])) !== 0)
            return result;
    }
    return 0;
}
function compareObjects(o1, o2, compare) {
    external_assert_default()(o1 != null && o2 != null);
    const keys = Object.keys(o1);
    let result;
    if ((result = compareNumbers(keys.length, Object.keys(o2).length)) !== 0)
        return result;
    for (const key of keys) {
        if ((result = compare(o1[key], o2[key])) !== 0)
            return result;
    }
    return 0;
}
function compareComparables(o1, o2) {
    if (o1 == null || o2 == null)
        return compareNulls(o1, o2);
    return o1._compareTo(o2);
}
//# sourceMappingURL=comparable.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/utils/internal/hot.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Predicates {
}
/** A Predicate that always succeeds */
Predicates.alwaysTrue = () => true;
/** A Predicate that always fails */
Predicates.alwaysFalse = () => false;
/**
 * Combines boolean expressions into a single value for use in switch cases.
 *
 * For example:
 *   switch(when(condition1, condition2)) {
 *     case when(true, true): break;
 *     case when(true, false): break;
 *     case when(false, true): break;
 *     case when(false, false): break;
 *   }
 *
 */
function when(...conditions) {
    return conditions.reduce((acc, x) => acc + (x ? '1' : '0'), '');
}
/** Merge two maps (updating values in the first with values from the second) */
function mergeMapInto(destination, source) {
    [...source].forEach(([k, v]) => destination.set(k, v));
}
/**
 * Used to explicitly ignore an 'unused' expression.
 * This is typically useful when an expression is self registering or has other side effects
 * e.g. rather than
 *    new entityClass();
 * use
 *    drop(new entityClass());
 */
function drop(_value) { }
//# sourceMappingURL=hot.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/utils/internal/indenting-string-builder.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const spacesPerIndent = 2;
class IndentingStringBuilder {
    constructor(parentBuilder) {
        if (parentBuilder) {
            this.lines = parentBuilder.lines;
            this.indent = parentBuilder.indent + 1;
            this.startIndex = this.lines.length;
        }
        else {
            this.lines = [];
            this.indent = 0;
            this.startIndex = 0;
        }
    }
    /** Add the given line(s) with the correct indent level. */
    push(...lines) {
        this.lines.push(...lines.map(line => ' '.repeat(this.indent * spacesPerIndent) + line));
    }
    /**
     * Allow indenting a block at a time. Can be used either via a lambda argument
     * or via the return value.
     *
     * Example 1:
     *
     * ```
     * const indented = builder.withIndent();
     * indented.push('a');
     * indented.push('a');
     * ```
     *
     * Example 2:
     *
     * ```
     * builder.withIndent(indented => {
     *   indented.push('a');
     *   indented.push('a');
     * });
     * ```
     */
    withIndent(fn) {
        const indentedBuilder = new IndentingStringBuilder(this);
        if (fn) {
            fn(indentedBuilder);
        }
        return indentedBuilder;
    }
    toString() {
        return this.lines.slice(this.startIndex).join('\n');
    }
}
//# sourceMappingURL=indenting-string-builder.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/utils/internal/walker.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * Walkers traverse an object, calling methods based on the
 * features encountered on that object. For example, a RecipeWalker
 * takes a list of recipes and calls methods when:
 *  - a new recipe is encountered
 *  - a handle is found inside a recipe
 *  - a particle is found inside a recipe
 *  - etc..
 *
 * Each of these methods can return a list of updates:
 *   [(recipe, encountered_thing) => new_recipe]
 *
 * The walker then does something with the updates depending on the
 * tactic selected.
 *
 * If the tactic is "Permuted", then an output will be generated
 * for every combination of 1 element drawn from each update list.
 * For example, if 3 methods return [a,b], [c,d,e], and [f] respectively
 * then "Permuted" will cause 6 outputs to be generated: [acf, adf, aef, bcf, bdf, bef]
 *
 * If the tactic is "Independent", an output will be generated for each
 * update, regardless of the list the update is in. For example,
 * if 3 methods return [a,b], [c,d,e], and [f] respectively,
 * then "Independent" will cause 6 outputs to be generated: [a,b,c,d,e,f]
 */
var WalkerTactic;
(function (WalkerTactic) {
    WalkerTactic["Permuted"] = "permuted";
    WalkerTactic["Independent"] = "independent";
})(WalkerTactic || (WalkerTactic = {}));
/**
 * An Action generates the list of Descendants by walking the object with a
 * Walker.
 */
class Action {
    constructor(args) {
        this._args = args;
    }
    getResults({ generated }) {
        return generated;
    }
    async generateFrom(generated) {
        return this.generate({
            generated,
            population: [],
            terminal: [],
            generation: 0,
        });
    }
}
class walker_Walker {
    constructor(tactic) {
        this.descendants = [];
        external_assert_default()(tactic);
        this.tactic = tactic;
    }
    onAction(action) {
        this.currentAction = action;
    }
    onResult(result) {
        this.currentResult = result;
        this.updateList = [];
    }
    onResultDone() {
        this.runUpdateList(this.currentResult.result, this.updateList);
        this.currentResult = undefined;
        this.updateList = undefined;
    }
    onActionDone() {
        this.currentAction = undefined;
    }
    static walk(results, walker, action) {
        walker.onAction(action);
        results.forEach(result => {
            walker.onResult(result);
            walker.onResultDone();
        });
        walker.onActionDone();
        return walker.descendants;
    }
    visit(visitor, ...context) {
        const continuation = visitor(this.currentResult.result, ...context);
        if (!this.isEmptyResult(continuation)) {
            this.updateList.push({
                continuation: continuation,
                context
            });
        }
    }
    runUpdateList(start, updateList) {
        const updated = [];
        if (updateList.length) {
            switch (this.tactic) {
                case WalkerTactic.Permuted: {
                    let permutations = [[]];
                    updateList.forEach(({ continuation, context }) => {
                        const newResults = [];
                        if (typeof continuation === 'function') {
                            continuation = [continuation];
                        }
                        continuation.forEach(f => {
                            permutations.forEach(p => {
                                const newP = p.slice();
                                newP.push({ continuation: f, context });
                                newResults.push(newP);
                            });
                        });
                        permutations = newResults;
                    });
                    for (const permutation of permutations) {
                        const cloneMap = new Map();
                        const newResult = start.clone(cloneMap);
                        let score = 0;
                        const newPermutation = permutation.filter(p => p.continuation !== null);
                        if (newPermutation.length === 0) {
                            continue;
                        }
                        newPermutation.forEach(({ continuation, context }) => {
                            // TODO: Should this only take the last?
                            score = continuation(newResult, ...context.map(c => cloneMap.get(c) || c));
                        });
                        updated.push({ result: newResult, score });
                    }
                    break;
                }
                case WalkerTactic.Independent:
                    updateList.forEach(({ continuation, context }) => {
                        if (typeof continuation === 'function') {
                            continuation = [continuation];
                        }
                        continuation.forEach(continuation => {
                            const cloneMap = new Map();
                            const newResult = start.clone(cloneMap);
                            let score = 0;
                            if (continuation == null) {
                                score = 0;
                            }
                            else {
                                score = continuation(newResult, ...context.map(c => cloneMap.get(c) || c));
                            }
                            updated.push({ result: newResult, score });
                        });
                    });
                    break;
                default:
                    throw new Error(`${this.tactic} not supported`);
            }
        }
        // commit phase - output results.
        for (const newResult of updated) {
            this.createDescendant(newResult.result, newResult.score);
        }
    }
    createWalkerDescendant(item, score, hash, valid) {
        external_assert_default()(this.currentResult, 'no current result');
        external_assert_default()(this.currentAction, 'no current action');
        if (this.currentResult.score) {
            score += this.currentResult.score;
        }
        this.descendants.push({
            result: item,
            score,
            derivation: [{ parent: this.currentResult, strategy: this.currentAction }],
            hash,
            valid,
        });
    }
    isEmptyResult(result) {
        if (!result) {
            return true;
        }
        if (result.constructor === Array && result.length <= 0) {
            return true;
        }
        external_assert_default()(typeof result === 'function' || result.length);
        return false;
    }
}
// tslint:disable-next-line: variable-name
walker_Walker.Permuted = WalkerTactic.Permuted;
// tslint:disable-next-line: variable-name
walker_Walker.Independent = WalkerTactic.Independent;
//# sourceMappingURL=walker.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/utils/internal/bimap.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class BiMap {
    constructor(iterable) {
        this.left2right = new Map();
        this.right2left = new Map();
        if (iterable) {
            for (const [left, right] of iterable) {
                this.set(left, right);
            }
        }
    }
    get size() { return this.left2right.size; }
    set(left, right) {
        if (this.hasL(left)) {
            this.right2left.delete(this.getL(left));
        }
        if (this.hasR(right)) {
            this.left2right.delete(this.getR(right));
        }
        this.left2right.set(left, right);
        this.right2left.set(right, left);
        return this;
    }
    hasL(left) {
        return this.left2right.has(left);
    }
    hasR(right) {
        return this.right2left.has(right);
    }
    getL(left) {
        return this.left2right.get(left);
    }
    getR(right) {
        return this.right2left.get(right);
    }
    deleteL(left) {
        this.right2left.delete(this.getL(left));
        return this.left2right.delete(left);
    }
    deleteR(right) {
        this.left2right.delete(this.getR(right));
        return this.right2left.delete(right);
    }
    clear() {
        this.left2right.clear();
        this.right2left.clear();
    }
    entries() {
        return this.left2right.entries();
    }
    lefts() {
        return this.left2right.keys();
    }
    rights() {
        return this.right2left.keys();
    }
    forEach(callback) {
        this.left2right.forEach((value, key) => callback(key, value, this));
    }
}
//# sourceMappingURL=bimap.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/utils/internal/mutex.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * A simmple Mutex to gate access to critical async code
 * sections that should not execute concurrently.
 *
 * Sample usage:
 *
 * ```
 *   class SampleClass {
 *     private readonly mutex = new Mutex();
 *
 *     async instantiate() {
 *       const release = await mutex.acquire();
 *       try {
 *         // Protected section with async execution.
 *       } finally {
 *         release();
 *       }
 *     }
 *   }
 */
class Mutex {
    constructor() {
        this.next = Promise.resolve();
        this.depth = 0; // tracks the number of blocked executions on this lock.
    }
    /**
     * @return true if the mutex is already acquired.
     */
    get locked() {
        return this.depth !== 0;
    }
    /**
     * Call acquire and await it to lock the critical section for the Mutex.
     *
     * @return A Releaser which resolves to a function which releases the Mutex.
     */
    async acquire() {
        let release;
        const current = this.next.then(() => {
            // external code is awaiting the result of acquire
            this.depth++;
            return () => {
                // external code is calling the releaser
                release();
                this.depth--;
            };
        });
        this.next = new Promise(resolve => {
            release = resolve;
        });
        return current;
    }
}
//# sourceMappingURL=mutex.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/utils/internal/misc.js
/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * Returns the set delta between two lists based on direct object comparison.
 */
function setDiff(from, to) {
    const result = { add: [], remove: [] };
    const items = new Set([...from, ...to]);
    const fromSet = new Set(from);
    const toSet = new Set(to);
    for (const item of items) {
        if (fromSet.has(item)) {
            if (toSet.has(item)) {
                continue;
            }
            result.remove.push(item);
            continue;
        }
        external_assert_default()(toSet.has(item));
        result.add.push(item);
    }
    return result;
}
/**
 * Returns the set delta between two lists based on custom object comparison.
 * `keyFn` takes type T and returns the value by which items should be compared.
 */
function setDiffCustom(from, to, keyFn) {
    const result = { add: [], remove: [] };
    const items = new Map();
    const fromSet = new Map();
    const toSet = new Map();
    for (const item of from) {
        const key = keyFn(item);
        items.set(key, item);
        fromSet.set(key, item);
    }
    for (const item of to) {
        const key = keyFn(item);
        items.set(key, item);
        toSet.set(key, item);
    }
    for (const [key, item] of items) {
        if (fromSet.has(key)) {
            if (toSet.has(key)) {
                continue;
            }
            result.remove.push(item);
            continue;
        }
        external_assert_default()(toSet.has(key));
        result.add.push(item);
    }
    return result;
}
/**
 * A hack to ignore a floating promise and bypass the linter. Promises should very rarely be left floating, and when such behaviour is intended,
 * it should be clearly marked as such. See https://tsetse.info/must-use-promises.html for details.
 *
 * TODO: Remove all usages of this function and then delete it.
 */
function floatingPromiseToAudit(promise) { }
/**
 * Noop function that can be used to supress the tsetse must-use-promises rule.
 *
 * Example Usage:
 *   async function x() {
 *     await doA();
 *     noAwait(doB());
 *   }
 */
function noAwait(result) { }
/**
 * Flat map. Maps every element of the given array using the mapping function
 * provided, then joins all elements together into a single list.
 *
 * Polyfill, replace with native Array.flatMap() once we upgrade to a sufficient
 * version of Nodejs.
 */
function flatMap(array, mapper) {
    return [].concat(...array.map(mapper));
}
/** Converts a Map to a Dictionary. */
function mapToDictionary(map) {
    const dict = {};
    for (const [k, v] of map) {
        dict[k] = v;
    }
    return dict;
}
/** Recursively delete all fields with the given name. */
// tslint:disable-next-line: no-any
function deleteFieldRecursively(node, field, options) {
    options = options || {};
    if (node == null || typeof node !== 'object') {
        return;
    }
    if (field in node) {
        if (options.replaceWithNulls) {
            node[field] = null;
        }
        else {
            delete node[field];
        }
    }
    for (const value of Object.values(node)) {
        deleteFieldRecursively(value, field, options);
    }
}
//# sourceMappingURL=misc.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/utils/lib-utils.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */







//# sourceMappingURL=lib-utils.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/crdt/internal/crdt.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class CRDTError extends Error {
}
// A CRDT Change represents a delta between model states. Where possible,
// this delta should be expressed as a sequence of operations; in which case
// changeType will be ChangeType.Operations.
// Sometimes it isn't possible to express a delta as operations. In this case,
// changeType will be ChangeType.Model, and a full post-merge model will be supplied.
// A CRDT Change is parameterized by the operations that can be represented, and the data representation
// of the model.
var ChangeType;
(function (ChangeType) {
    ChangeType[ChangeType["Operations"] = 0] = "Operations";
    ChangeType[ChangeType["Model"] = 1] = "Model";
})(ChangeType || (ChangeType = {}));
function isEmptyChange(change) {
    return change.changeType === ChangeType.Operations && change.operations.length === 0;
}
function createEmptyChange() {
    return { changeType: ChangeType.Operations, operations: [] };
}
//# sourceMappingURL=crdt.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/crdt/internal/crdt-collection.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


var CollectionOpTypes;
(function (CollectionOpTypes) {
    CollectionOpTypes[CollectionOpTypes["Add"] = 0] = "Add";
    CollectionOpTypes[CollectionOpTypes["Remove"] = 1] = "Remove";
    CollectionOpTypes[CollectionOpTypes["FastForward"] = 2] = "FastForward";
})(CollectionOpTypes || (CollectionOpTypes = {}));
class crdt_collection_CRDTCollection {
    constructor() {
        this.model = { values: {}, version: {} };
    }
    merge(other) {
        // Ensure we never send an update if the two versions are already the same.
        // TODO(shans): Remove this once fast-forwarding is two-sided, and replace with
        // a check for an effect-free fast-forward op in each direction instead.
        if (sameVersions(this.model.version, other.version)) {
            let entriesMatch = true;
            const theseKeys = Object.keys(this.model.values);
            const otherKeys = Object.keys(other.values);
            if (theseKeys.length === otherKeys.length) {
                for (const key of Object.keys(this.model.values)) {
                    if (!other.values[key]) {
                        entriesMatch = false;
                        break;
                    }
                }
                if (entriesMatch) {
                    return { modelChange: createEmptyChange(), otherChange: createEmptyChange() };
                }
            }
        }
        const newVersionMap = mergeVersions(this.model.version, other.version);
        const merged = {};
        // Fast-forward op to send to other model. Elements added and removed will
        // be filled in below.
        const fastForwardOp = {
            type: CollectionOpTypes.FastForward,
            added: [],
            removed: [],
            oldVersionMap: other.version,
            newVersionMap,
        };
        for (const otherEntry of Object.values(other.values)) {
            const value = otherEntry.value;
            const id = value.id;
            const thisEntry = this.model.values[id];
            if (thisEntry) {
                if (sameVersions(thisEntry.version, otherEntry.version)) {
                    // Both models have the same value at the same version. Add it to the
                    // merge.
                    merged[id] = thisEntry;
                }
                else {
                    // Models have different versions for the same value. Merge the
                    // versions, and update other.
                    const mergedVersion = mergeVersions(thisEntry.version, otherEntry.version);
                    merged[id] = { value, version: mergedVersion };
                    fastForwardOp.added.push([value, mergedVersion]);
                }
            }
            else if (dominates(this.model.version, otherEntry.version)) {
                // Value was deleted by this model.
                fastForwardOp.removed.push(value);
            }
            else {
                // Value was added by other model.
                merged[id] = otherEntry;
            }
        }
        for (const [id, thisEntry] of Object.entries(this.model.values)) {
            if (!other.values[id] && !dominates(other.version, thisEntry.version)) {
                // Value was added by this model.
                merged[id] = thisEntry;
                fastForwardOp.added.push([thisEntry.value, thisEntry.version]);
            }
        }
        const operations = simplifyFastForwardOp(fastForwardOp) || [fastForwardOp];
        this.model.values = merged;
        this.model.version = newVersionMap;
        const modelChange = {
            changeType: ChangeType.Model,
            modelPostChange: this.model
        };
        const otherChange = {
            changeType: ChangeType.Operations,
            operations,
        };
        return { modelChange, otherChange };
    }
    applyOperation(op) {
        switch (op.type) {
            case CollectionOpTypes.Add:
                return this.add(op.added, op.actor, op.versionMap);
            case CollectionOpTypes.Remove:
                return this.remove(op.removed, op.actor, op.versionMap);
            case CollectionOpTypes.FastForward:
                return this.fastForward(op);
            default:
                throw new CRDTError(`Op ${op} not supported`);
        }
    }
    getData() {
        return this.model;
    }
    getParticleView() {
        return new Set(Object.values(this.model.values).map(entry => entry.value));
    }
    add(value, key, version) {
        this.checkValue(value);
        // Only accept an add if it is immediately consecutive to the versionMap for that actor.
        const expectedVersionMapValue = (this.model.version[key] || 0) + 1;
        if (!(expectedVersionMapValue === version[key] || 0)) {
            return false;
        }
        this.model.version[key] = version[key];
        const previousVersion = this.model.values[value.id] ? this.model.values[value.id].version : {};
        const newValue = this.model.values[value.id] ? this.model.values[value.id].value : value;
        this.model.values[value.id] = { value: newValue, version: mergeVersions(version, previousVersion) };
        return true;
    }
    remove(value, key, version) {
        this.checkValue(value);
        if (!this.model.values[value.id]) {
            return false;
        }
        const versionMapValue = (version[key] || 0);
        // Removes do not increment the VersionMap.
        const expectedVersionMapValue = (this.model.version[key] || 0);
        if (!(expectedVersionMapValue === versionMapValue)) {
            return false;
        }
        // Cannot remove an element unless version is higher for all other actors as
        // well.
        if (!dominates(version, this.model.values[value.id].version)) {
            return false;
        }
        this.model.version[key] = versionMapValue;
        delete this.model.values[value.id];
        return true;
    }
    fastForward(op) {
        const currentVersionMap = this.model.version;
        if (!dominates(currentVersionMap, op.oldVersionMap)) {
            // Can't apply fast-forward op. Current model's VersionMap is behind oldVersionMap.
            return false;
        }
        if (dominates(currentVersionMap, op.newVersionMap)) {
            // Current model already knows about everything in this fast-forward op.
            // Nothing to do, but not an error.
            return true;
        }
        for (const [value, version] of op.added) {
            this.checkValue(value);
            const existingValue = this.model.values[value.id];
            if (existingValue) {
                existingValue.version = mergeVersions(existingValue.version, version);
            }
            else if (!dominates(currentVersionMap, version)) {
                this.model.values[value.id] = { value, version };
            }
        }
        for (const value of op.removed) {
            this.checkValue(value);
            const existingValue = this.model.values[value.id];
            if (existingValue && dominates(op.newVersionMap, existingValue.version)) {
                delete this.model.values[value.id];
            }
        }
        this.model.version = mergeVersions(currentVersionMap, op.newVersionMap);
        return true;
    }
    checkValue(value) {
        external_assert_default()(value.id && value.id.length, `CRDT value must have an ID.`);
    }
}
function mergeVersions(version1, version2) {
    const merged = {};
    for (const [k, v] of Object.entries(version1)) {
        merged[k] = v;
    }
    for (const [k, v] of Object.entries(version2)) {
        merged[k] = Math.max(v, version1[k] || 0);
    }
    return merged;
}
function sameVersions(version1, version2) {
    if (Object.keys(version1).length !== Object.keys(version2).length) {
        return false;
    }
    for (const [k, v] of Object.entries(version1)) {
        if (v !== version2[k]) {
            return false;
        }
    }
    return true;
}
/** Returns true if map1 dominates map2. */
function dominates(map1, map2) {
    for (const [k, v] of Object.entries(map2)) {
        if ((map1[k] || 0) < v) {
            return false;
        }
    }
    return true;
}
/**
 * Converts a simple fast-forward operation into a sequence of regular ops.
 * Currently only supports converting add ops made by a single actor. Returns
 * null if it could not simplify the fast-forward operation.
 */
function simplifyFastForwardOp(fastForwardOp) {
    if (fastForwardOp.removed.length > 0) {
        // Remove ops can't be replayed in order.
        return null;
    }
    if (fastForwardOp.added.length === 0) {
        if (sameVersions(fastForwardOp.oldVersionMap, fastForwardOp.newVersionMap)) {
            // No added, no removed, and no versionMap changes: op should be empty.
            return [];
        }
        // Just a version bump, no add ops to replay.
        return null;
    }
    const actor = getSingleActorIncrement(fastForwardOp.oldVersionMap, fastForwardOp.newVersionMap);
    if (actor === null) {
        return null;
    }
    // Sort the add ops in increasing order by the actor's version.
    const addOps = [...fastForwardOp.added].sort(([elem1, v1], [elem2, v2]) => (v1[actor] || 0) - (v2[actor] || 0));
    let expectedVersion = fastForwardOp.oldVersionMap[actor] || 0;
    for (const [elem, version] of addOps) {
        if (++expectedVersion !== version[actor]) {
            // The add op didn't match the expected increment-by-one pattern. Can't
            // replay it properly.
            return null;
        }
    }
    // If we reach here then all added versions are incremented by one.
    // Check the final versionMap.
    const expectedVersionMap = { ...fastForwardOp.oldVersionMap };
    expectedVersionMap[actor] = expectedVersion;
    if (!sameVersions(expectedVersionMap, fastForwardOp.newVersionMap)) {
        return null;
    }
    return addOps.map(([elem, version]) => ({
        type: CollectionOpTypes.Add,
        added: elem,
        actor,
        versionMap: version,
    }));
}
/**
 * Given two version maps, returns the actor who incremented their version. If
 * there's more than one such actor, returns null.
 */
function getSingleActorIncrement(oldVersion, newVersion) {
    const incrementedActors = Object.entries(newVersion).filter(([k, v]) => v > (oldVersion[k] || 0));
    return incrementedActors.length === 1 ? incrementedActors[0][0] : null;
}
//# sourceMappingURL=crdt-collection.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/crdt/internal/crdt-singleton.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


var SingletonOpTypes;
(function (SingletonOpTypes) {
    SingletonOpTypes[SingletonOpTypes["Set"] = 0] = "Set";
    SingletonOpTypes[SingletonOpTypes["Clear"] = 1] = "Clear";
    SingletonOpTypes[SingletonOpTypes["FastForward"] = 2] = "FastForward";
})(SingletonOpTypes || (SingletonOpTypes = {}));
class crdt_singleton_CRDTSingleton {
    constructor() {
        this.collection = new crdt_collection_CRDTCollection();
    }
    merge(other) {
        const { modelChange, otherChange } = this.collection.merge(other);
        // We cannot pass through the collection ops, so always return the updated model.
        let newModelChange = {
            changeType: ChangeType.Model,
            modelPostChange: this.collection.getData()
        };
        let newOtherChange = newModelChange;
        if (isEmptyChange(modelChange)) {
            newModelChange = createEmptyChange();
        }
        if (isEmptyChange(otherChange)) {
            newOtherChange = createEmptyChange();
        }
        return { modelChange: newModelChange, otherChange: newOtherChange };
    }
    applyOperation(op) {
        switch (op.type) {
            case SingletonOpTypes.Set:
                return this.set(op.value, op.actor, op.versionMap);
            case SingletonOpTypes.Clear:
                return this.clear(op.actor, op.versionMap);
            case SingletonOpTypes.FastForward:
                return this.fastForward(op.oldVersionMap, op.newVersionMap);
            default:
                throw new CRDTError(`Op ${op} not supported`);
        }
    }
    getData() {
        return this.collection.getData();
    }
    getParticleView() {
        // Return any value.
        return [...this.collection.getParticleView()].sort()[0] || null;
    }
    set(value, actor, versionMap) {
        // Remove does not require an increment, but the caller of this method will have incremented
        // its version, so we hack a version with t-1 for this actor.
        const removeVersionMap = {};
        for (const [k, v] of Object.entries(versionMap)) {
            removeVersionMap[k] = v;
        }
        removeVersionMap[actor] = versionMap[actor] - 1;
        if (!this.clear(actor, removeVersionMap)) {
            return false;
        }
        const addOp = {
            type: CollectionOpTypes.Add,
            added: value,
            actor,
            versionMap,
        };
        return this.collection.applyOperation(addOp);
    }
    clear(actor, versionMap) {
        // Clear all existing values if our versionMap allows it.
        for (const value of Object.values(this.collection.getData().values)) {
            const removeOp = {
                type: CollectionOpTypes.Remove,
                removed: value.value,
                actor,
                versionMap,
            };
            // If any value fails to remove, we haven't cleared the value and we fail the whole op.
            //if (!this.collection.applyOperation(removeOp)) {
            //   return false;
            // }
            this.collection.applyOperation(removeOp);
        }
        return true;
    }
    fastForward(oldVersionMap, newVersionMap) {
        // Updates the singleton's versionMap
        return this.collection.applyOperation({
            type: CollectionOpTypes.FastForward,
            added: [],
            removed: [],
            oldVersionMap,
            newVersionMap
        });
    }
}
//# sourceMappingURL=crdt-singleton.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/crdt/internal/crdt-entity.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */



var EntityOpTypes;
(function (EntityOpTypes) {
    EntityOpTypes[EntityOpTypes["Set"] = 0] = "Set";
    EntityOpTypes[EntityOpTypes["Clear"] = 1] = "Clear";
    EntityOpTypes[EntityOpTypes["Add"] = 2] = "Add";
    EntityOpTypes[EntityOpTypes["Remove"] = 3] = "Remove";
    EntityOpTypes[EntityOpTypes["ClearAll"] = 4] = "ClearAll";
})(EntityOpTypes || (EntityOpTypes = {}));
class crdt_entity_CRDTEntity {
    constructor(singletons, collections) {
        this.model = { singletons, collections, version: {} };
    }
    merge(other) {
        const singletonChanges = {};
        const collectionChanges = {};
        let allOps = true;
        for (const singleton of Object.keys(this.model.singletons)) {
            singletonChanges[singleton] = this.model.singletons[singleton].merge(other.singletons[singleton]);
            if (singletonChanges[singleton].modelChange.changeType === ChangeType.Model ||
                singletonChanges[singleton].otherChange.changeType === ChangeType.Model) {
                allOps = false;
            }
        }
        for (const collection of Object.keys(this.model.collections)) {
            collectionChanges[collection] = this.model.collections[collection].merge(other.collections[collection]);
            if (collectionChanges[collection].modelChange.changeType === ChangeType.Model ||
                collectionChanges[collection].otherChange.changeType === ChangeType.Model) {
                allOps = false;
            }
        }
        for (const versionKey of Object.keys(other.version)) {
            this.model.version[versionKey] = Math.max(this.model.version[versionKey] || 0, other.version[versionKey]);
        }
        if (allOps) {
            const modelOps = [];
            const otherOps = [];
            for (const singleton of Object.keys(singletonChanges)) {
                for (const operation of singletonChanges[singleton].modelChange.operations) {
                    let op;
                    if (operation.type === SingletonOpTypes.Set) {
                        op = { ...operation, type: EntityOpTypes.Set, field: singleton };
                    }
                    else {
                        op = { ...operation, type: EntityOpTypes.Clear, field: singleton };
                    }
                    modelOps.push(op);
                }
                for (const operation of singletonChanges[singleton].otherChange.operations) {
                    let op;
                    if (operation.type === SingletonOpTypes.Set) {
                        op = { ...operation, type: EntityOpTypes.Set, field: singleton };
                    }
                    else {
                        op = { ...operation, type: EntityOpTypes.Clear, field: singleton };
                    }
                    otherOps.push(op);
                }
            }
            for (const collection of Object.keys(collectionChanges)) {
                for (const operation of collectionChanges[collection].modelChange.operations) {
                    let op;
                    if (operation.type === CollectionOpTypes.Add) {
                        op = { ...operation, type: EntityOpTypes.Add, field: collection };
                    }
                    else {
                        op = { ...operation, type: EntityOpTypes.Remove, field: collection };
                    }
                    modelOps.push(op);
                }
                for (const operation of collectionChanges[collection].otherChange.operations) {
                    let op;
                    if (operation.type === CollectionOpTypes.Add) {
                        op = { ...operation, type: EntityOpTypes.Add, field: collection };
                    }
                    else {
                        op = { ...operation, type: EntityOpTypes.Remove, field: collection };
                    }
                    otherOps.push(op);
                }
            }
            return { modelChange: { changeType: ChangeType.Operations, operations: modelOps },
                otherChange: { changeType: ChangeType.Operations, operations: otherOps } };
        }
        else {
            // need to map this.model to get the data out.
            const change = { changeType: ChangeType.Model, modelPostChange: this.getData() };
            return { modelChange: change, otherChange: change };
        }
    }
    applyOperation(op) {
        if (op.type === EntityOpTypes.Set || op.type === EntityOpTypes.Clear) {
            if (!this.model.singletons[op.field]) {
                if (this.model.collections[op.field]) {
                    throw new Error(`Can't apply ${op.type === EntityOpTypes.Set ? 'Set' : 'Clear'} operation to collection field ${op.field}`);
                }
                throw new Error(`Invalid field: ${op.field} does not exist`);
            }
        }
        else if (op.type === EntityOpTypes.Add || op.type === EntityOpTypes.Remove) {
            if (!this.model.collections[op.field]) {
                if (this.model.singletons[op.field]) {
                    throw new Error(`Can't apply ${op.type === EntityOpTypes.Add ? 'Add' : 'Remove'} operation to singleton field ${op.field}`);
                }
                throw new Error(`Invalid field: ${op.field} does not exist`);
            }
        }
        const apply = () => {
            switch (op.type) {
                case EntityOpTypes.Set:
                    return this.model.singletons[op.field].applyOperation({ ...op, type: SingletonOpTypes.Set });
                case EntityOpTypes.Clear:
                    return this.model.singletons[op.field].applyOperation({ ...op, type: SingletonOpTypes.Clear });
                case EntityOpTypes.Add:
                    return this.model.collections[op.field].applyOperation({ ...op, type: CollectionOpTypes.Add });
                case EntityOpTypes.Remove:
                    return this.model.collections[op.field].applyOperation({ ...op, type: CollectionOpTypes.Remove });
                case EntityOpTypes.ClearAll:
                    return this.clear(op.actor);
                default:
                    throw new Error(`Unexpected op ${op} for Entity CRDT`);
            }
        };
        if (apply()) {
            for (const versionKey of Object.keys(op.versionMap)) {
                this.model.version[versionKey] = Math.max(this.model.version[versionKey] || 0, op.versionMap[versionKey]);
            }
            // fast forward version number for all remaining fields
            if (op.type === EntityOpTypes.Add) {
                this.fastForwardAllCollectionsExcept(op.field);
                this.fastForwardAllSingletons();
            }
            else if (op.type === EntityOpTypes.Set) {
                this.fastForwardAllSingletonsExcept(op.field);
                this.fastForwardAllCollections();
            }
            return true;
        }
        return false;
    }
    fastForwardAllSingletons() {
        for (const field of Object.keys(this.model.singletons)) {
            const oldVersionMap = this.model.singletons[field].getData().version;
            this.model.singletons[field].applyOperation({
                type: SingletonOpTypes.FastForward,
                oldVersionMap,
                newVersionMap: this.model.version
            });
        }
    }
    fastForwardAllSingletonsExcept(exceptField) {
        for (const field of Object.keys(this.model.singletons)) {
            if (field !== exceptField) {
                const oldVersionMap = this.model.singletons[field].getData().version;
                this.model.singletons[field].applyOperation({
                    type: SingletonOpTypes.FastForward,
                    oldVersionMap,
                    newVersionMap: this.model.version
                });
            }
        }
    }
    fastForwardAllCollections() {
        for (const field of Object.keys(this.model.collections)) {
            const oldVersionMap = this.model.collections[field].getData().version;
            this.model.collections[field].applyOperation({
                type: CollectionOpTypes.FastForward,
                added: [],
                removed: [],
                oldVersionMap,
                newVersionMap: this.model.version
            });
        }
    }
    fastForwardAllCollectionsExcept(exceptField) {
        for (const field of Object.keys(this.model.collections)) {
            if (field !== exceptField) {
                const oldVersionMap = this.model.collections[field].getData().version;
                this.model.collections[field].applyOperation({
                    type: CollectionOpTypes.FastForward,
                    added: [],
                    removed: [],
                    oldVersionMap,
                    newVersionMap: this.model.version
                });
            }
        }
    }
    // Clear all fields.
    clear(actor) {
        Object.values(this.model.singletons).forEach(field => field.applyOperation({
            type: SingletonOpTypes.Clear,
            actor,
            versionMap: this.model.version,
        }));
        Object.values(this.model.collections).forEach(field => field.getParticleView().forEach(value => field.applyOperation({
            type: CollectionOpTypes.Remove,
            removed: value,
            actor,
            versionMap: this.model.version,
        })));
        return true;
    }
    getData() {
        const singletons = {};
        const collections = {};
        Object.keys(this.model.singletons).forEach(singleton => {
            singletons[singleton] = this.model.singletons[singleton].getData();
        });
        Object.keys(this.model.collections).forEach(collection => {
            collections[collection] = this.model.collections[collection].getData();
        });
        return { singletons, collections, version: this.model.version };
    }
    getParticleView() {
        const result = { singletons: {}, collections: {} };
        for (const key of Object.keys(this.model.singletons)) {
            result.singletons[key] = this.model.singletons[key].getParticleView();
        }
        for (const key of Object.keys(this.model.collections)) {
            result.collections[key] = this.model.collections[key].getParticleView();
        }
        return result;
    }
}
//# sourceMappingURL=crdt-entity.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/crdt/internal/crdt-count.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

var CountOpTypes;
(function (CountOpTypes) {
    CountOpTypes[CountOpTypes["Increment"] = 0] = "Increment";
    CountOpTypes[CountOpTypes["MultiIncrement"] = 1] = "MultiIncrement";
})(CountOpTypes || (CountOpTypes = {}));
class crdt_count_CRDTCount {
    constructor() {
        this.model = { values: {}, version: {} };
    }
    merge(other) {
        const otherChanges = [];
        const thisChanges = [];
        for (const key of Object.keys(other.values)) {
            const thisValue = this.model.values[key] || 0;
            const otherValue = other.values[key] || 0;
            const thisVersion = this.model.version[key] || 0;
            const otherVersion = other.version[key] || 0;
            if (thisValue > otherValue) {
                if (otherVersion >= thisVersion) {
                    throw new CRDTError('Divergent versions encountered when merging CRDTCount models');
                }
                otherChanges.push({ type: CountOpTypes.MultiIncrement, value: thisValue - otherValue, actor: key,
                    version: { from: otherVersion, to: thisVersion } });
            }
            else if (otherValue > thisValue) {
                if (thisVersion >= otherVersion) {
                    throw new CRDTError('Divergent versions encountered when merging CRDTCount models');
                }
                thisChanges.push({ type: CountOpTypes.MultiIncrement, value: otherValue - thisValue, actor: key,
                    version: { from: thisVersion, to: otherVersion } });
                this.model.values[key] = otherValue;
                this.model.version[key] = otherVersion;
            }
        }
        for (const key of Object.keys(this.model.values)) {
            if (other.values[key]) {
                continue;
            }
            if (other.version[key]) {
                throw new CRDTError(`CRDTCount model has version but no value for key ${key}`);
            }
            otherChanges.push({ type: CountOpTypes.MultiIncrement, value: this.model.values[key], actor: key,
                version: { from: 0, to: this.model.version[key] } });
        }
        return { modelChange: { changeType: ChangeType.Operations, operations: thisChanges }, otherChange: { changeType: ChangeType.Operations, operations: otherChanges } };
    }
    applyOperation(op) {
        let value;
        if (op.version.from !== (this.model.version[op.actor] || 0)) {
            return false;
        }
        if (op.version.to <= op.version.from) {
            return false;
        }
        if (op.type === CountOpTypes.MultiIncrement) {
            if (op.value < 0) {
                return false;
            }
            value = (this.model.values[op.actor] || 0) + op.value;
        }
        else {
            value = (this.model.values[op.actor] || 0) + 1;
        }
        this.model.values[op.actor] = value;
        this.model.version[op.actor] = op.version.to;
        return true;
    }
    cloneMap(map) {
        const result = {};
        Object.keys(map).forEach(key => result[key] = map[key]);
        return result;
    }
    getData() {
        return { values: this.cloneMap(this.model.values), version: this.cloneMap(this.model.version) };
    }
    getParticleView() {
        return Object.values(this.model.values).reduce((prev, current) => prev + current, 0);
    }
}
//# sourceMappingURL=crdt-count.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/crdt/lib-crdt.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */





//# sourceMappingURL=lib-crdt.js.map
// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(36);
var external_crypto_default = /*#__PURE__*/__webpack_require__.n(external_crypto_);

// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/digest-node.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

async function digest(str) {
    const sha = external_crypto_default.a.createHash('sha1');
    sha.update(str);
    return Promise.resolve().then(() => sha.digest('hex'));
}
//# sourceMappingURL=digest-node.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/types/internal/schema.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */








class schema_Schema {
    // For convenience, primitive field types can be specified as {name: 'Type'}
    // in `fields`; the constructor will convert these to the correct schema form.
    // tslint:disable-next-line: no-any
    constructor(names, fields, options = {}) {
        this.description = {};
        this.hashStr = null;
        this.location = null;
        this.names = names;
        this.fields = {};
        this.refinement = options.refinement || null;
        const fNs = this.refinement && this.refinement.getFieldParams();
        // if the schema level refinement is univariate, propogate it to the appropriate field
        if (fNs && fNs.size === 1 && Flags.fieldRefinementsAllowed) {
            const fN = fNs.keys().next().value;
            fields[fN].refinement = refiner_Refinement.intersectionOf(fields[fN].refinement, this.refinement);
            this.refinement = null;
        }
        for (const [name, field] of Object.entries(fields)) {
            this.fields[name] = field instanceof schema_field_FieldType ? field : schema_field_FieldType.create(field);
        }
        if (options.description && options.description.description) {
            // The descriptions should be passed ready for assignment into this.description.
            // TODO(cypher1): Refactor the schema construction code to do this rearrangement at the call site.
            options.description.description.forEach(desc => this.description[desc.name] = desc.pattern || desc.patterns[0]);
        }
        this.annotations = options.annotations || [];
    }
    forEachRefinement(func) {
        const types = [this, ...Object.values(this.fields)];
        types.forEach(type => type.refinement && func(type.refinement));
    }
    getFieldParams() {
        const params = new Map();
        this.forEachRefinement((ref) => mergeMapInto(params, ref.getFieldParams()));
        return params;
    }
    getQueryParams() {
        const params = new Map();
        this.forEachRefinement((ref) => mergeMapInto(params, ref.getQueryParams()));
        return params;
    }
    getQueryType() {
        return this.getQueryParams().get('?');
    }
    extractRefinementFromQuery() {
        const fields = [];
        for (const [name, fieldType] of Object.entries(this.fields)) {
            const field = { ...fieldType };
            field.refinement = field.refinement && field.refinement.extractRefinementFromQuery();
            fields[name] = field;
        }
        const options = {
            refinement: this.refinement && this.refinement.extractRefinementFromQuery()
        };
        const schema = new schema_Schema(this.names, fields, options);
        if (this.description) {
            schema.description = this.description;
        }
        return schema;
    }
    toLiteral() {
        const fields = {};
        for (const key of Object.keys(this.fields)) {
            fields[key] = this.fields[key].toLiteral();
        }
        const lit = {
            names: this.names,
            fields,
            description: this.description,
            refinement: this.refinement && this.refinement.toLiteral(),
            annotations: this.annotations
        };
        if (this.location !== null) {
            lit['location'] = this.location;
        }
        return lit;
    }
    // TODO(cypher1): This should only be an ident used in manifest parsing.
    get name() {
        return this.names[0];
    }
    get annotations() { return this._annotations; }
    set annotations(annotations) {
        annotations.every(a => external_assert_default()(a.isValidForTarget('Schema'), `Annotation '${a.name}' is invalid for Schema`));
        this._annotations = annotations;
    }
    getAnnotation(name) {
        const annotations = this.findAnnotations(name);
        external_assert_default()(annotations.length <= 1, `Multiple annotations found for '${name}'. Use findAnnotations instead.`);
        return annotations.length === 0 ? null : annotations[0];
    }
    findAnnotations(name) {
        return this.annotations.filter(a => a.name === name);
    }
    static typesEqual(fieldType1, fieldType2) {
        return fieldType1.equals(fieldType2);
    }
    static fieldTypeUnion(infield1, infield2) {
        // Ensure that changes to the field types are non-side-effecting
        const field1 = infield1 && infield1.clone();
        const field2 = infield2 && infield2.clone();
        if (field1.kind !== field2.kind)
            return null;
        switch (field1.kind) {
            case 'schema-collection': {
                const unionSchema = schema_Schema.fieldTypeUnion(field1.getFieldType(), field2.getFieldType());
                if (!unionSchema) {
                    return null;
                }
                return new schema_field_CollectionField(unionSchema);
            }
            case 'schema-reference': {
                const unionSchema = schema_Schema.union(field1.getEntityType().entitySchema, field2.getEntityType().entitySchema);
                if (!unionSchema) {
                    return null;
                }
                // Note: this is done because new EntityType(unionSchema) causes circular dependency.
                // tslint:disable-next-line: no-any
                const inlineUnionLiteral = field1.getFieldType().toLiteral();
                inlineUnionLiteral.model.entitySchema = unionSchema;
                return new schema_field_ReferenceField(schema_field_FieldType.create(inlineUnionLiteral));
            }
            case 'schema-nested': {
                const unionSchema = schema_Schema.union(field1.getEntityType().entitySchema, field2.getEntityType().entitySchema);
                if (!unionSchema) {
                    return null;
                }
                // Note: this is done because new EntityType(unionSchema) causes circular dependency.
                // tslint:disable-next-line: no-any
                const inlineUnionLiteral = field1.getFieldType().toLiteral();
                inlineUnionLiteral.model.entitySchema = unionSchema;
                return new schema_field_NestedField(schema_field_FieldType.create(inlineUnionLiteral));
            }
            case 'schema-ordered-list': {
                const unionSchema = schema_Schema.fieldTypeUnion(field1.getFieldType(), field2.getFieldType());
                if (!unionSchema) {
                    return null;
                }
                return new schema_field_OrderedListField(unionSchema);
            }
            default:
                return schema_Schema.typesEqual(field1, field2) ? field1 : null;
        }
    }
    static union(schema1, schema2) {
        const names = [...new Set([...schema1.names, ...schema2.names])];
        const fields = {};
        for (const [field, type] of [...Object.entries(schema1.fields), ...Object.entries(schema2.fields)]) {
            if (fields[field]) {
                const fieldUnionSchema = schema_Schema.fieldTypeUnion(fields[field], type);
                if (!fieldUnionSchema) {
                    return null;
                }
                if (!schema_Schema.typesEqual(fields[field], fieldUnionSchema)) {
                    fields[field] = { ...fields[field], ...fieldUnionSchema };
                }
                fields[field].refinement = refiner_Refinement.intersectionOf(fields[field].refinement, type.refinement);
                fields[field].annotations = [...(fields[field].annotations || []), ...(type.annotations || [])];
            }
            else {
                fields[field] = type.clone();
            }
        }
        return new schema_Schema(names, fields, { refinement: refiner_Refinement.intersectionOf(schema1.refinement, schema2.refinement) });
    }
    static fieldTypeIntersection(infield1, infield2) {
        // Ensure that changes to the field types are non-side-effecting
        const field1 = infield1 && infield1.clone();
        const field2 = infield2 && infield2.clone();
        const missingField1 = (field1 === null || field1 === undefined);
        const missingField2 = (field2 === null || field2 === undefined);
        if (missingField1 || missingField2) {
            // TODO(b/174115805, b/144507619, b/144507352): Handle nullables
            // (with make it possible to store 'true' unions)
            return null;
        }
        // TODO: non-eq Kinds?
        if (field1.kind !== field2.kind)
            return null;
        switch (field1.kind) {
            case 'schema-collection': {
                const intersectSchema = schema_Schema.fieldTypeIntersection(field1.getFieldType(), field2.getFieldType());
                if (!intersectSchema) {
                    return null;
                }
                return new schema_field_CollectionField(intersectSchema);
            }
            case 'schema-reference': {
                const intersectSchema = schema_Schema.intersect(field1.getEntityType().entitySchema, field2.getEntityType().entitySchema);
                if (!intersectSchema) {
                    return null;
                }
                // Note: this is done because new EntityType(intersectSchema) causes circular dependency.
                // tslint:disable-next-line: no-any
                const inlineIntersectionLiteral = field1.getFieldType().toLiteral();
                inlineIntersectionLiteral.model.entitySchema = intersectSchema;
                return new schema_field_ReferenceField(schema_field_FieldType.create(inlineIntersectionLiteral));
            }
            case 'schema-nested': {
                const intersectSchema = schema_Schema.intersect(field1.getEntityType().entitySchema, field2.getEntityType().entitySchema);
                if (!intersectSchema) {
                    return null;
                }
                // Note: this is done because new EntityType(intersectSchema) causes circular dependency.
                // tslint:disable-next-line: no-any
                const inlineIntersectionLiteral = field1.getFieldType().toLiteral();
                inlineIntersectionLiteral.model.entitySchema = intersectSchema;
                return new schema_field_NestedField(schema_field_FieldType.create(inlineIntersectionLiteral));
            }
            case 'schema-ordered-list': {
                const intersectSchema = schema_Schema.fieldTypeIntersection(field1.getFieldType(), field2.getFieldType());
                if (!intersectSchema) {
                    return null;
                }
                return new schema_field_OrderedListField(intersectSchema);
            }
            default:
                return schema_Schema.typesEqual(field1, field2) ? field1 : null;
        }
    }
    static intersect(schema1, schema2) {
        const names = [...schema1.names].filter(name => schema2.names.includes(name));
        const fields = {};
        const fieldNames = new Set([...Object.keys(schema1.fields), ...Object.keys(schema2.fields)]);
        for (const field of fieldNames) {
            const type = schema1.fields[field];
            const otherType = schema2.fields[field];
            const intersectionType = schema_Schema.fieldTypeIntersection(type, otherType);
            if (intersectionType) {
                fields[field] = intersectionType;
                fields[field].refinement = refiner_Refinement.unionOf(type && type.refinement, otherType && otherType.refinement);
                fields[field].annotations = (type.annotations || []).filter(a => (otherType.annotations || []).includes(a));
            }
        }
        // if schema level refinement contains fields not present in the intersection, discard it
        const ref1 = !schema1.refinementHasFieldsNotIn(fields) ? schema1.refinement : null;
        const ref2 = !schema2.refinementHasFieldsNotIn(fields) ? schema2.refinement : null;
        return new schema_Schema(names, fields, { refinement: refiner_Refinement.unionOf(ref1, ref2) });
    }
    equals(otherSchema) {
        if (this === otherSchema) {
            return true;
        }
        return (this.isEquivalentOrMoreSpecific(otherSchema) === AtLeastAsSpecific.YES)
            && (otherSchema.isEquivalentOrMoreSpecific(this) === AtLeastAsSpecific.YES);
    }
    isEquivalentOrMoreSpecific(otherSchema) {
        const names = new Set(this.names);
        for (const name of otherSchema.names) {
            if (!names.has(name)) {
                return AtLeastAsSpecific.NO;
            }
        }
        // tslint:disable-next-line: no-any
        const fields = {};
        for (const [name, type] of Object.entries(this.fields)) {
            fields[name] = type;
        }
        let best = AtLeastAsSpecific.YES;
        for (const [name, type] of Object.entries(otherSchema.fields)) {
            if (fields[name] == undefined) {
                return AtLeastAsSpecific.NO;
            }
            if (!fields[name].isAtLeastAsSpecificAs(type)) {
                return AtLeastAsSpecific.NO;
            }
            const fieldRes = refiner_Refinement.isAtLeastAsSpecificAs(fields[name].refinement, type.refinement);
            if (fieldRes === AtLeastAsSpecific.NO) {
                return AtLeastAsSpecific.NO;
            }
            else if (fieldRes === AtLeastAsSpecific.UNKNOWN) {
                best = AtLeastAsSpecific.UNKNOWN;
            }
        }
        const res = refiner_Refinement.isAtLeastAsSpecificAs(this.refinement, otherSchema.refinement);
        if (res === AtLeastAsSpecific.NO) {
            return AtLeastAsSpecific.NO;
        }
        else if (res === AtLeastAsSpecific.UNKNOWN) {
            best = AtLeastAsSpecific.UNKNOWN;
        }
        return best;
    }
    isAtLeastAsSpecificAs(otherSchema) {
        // Implementation moved to isEquivalentOrMoreSpecific to allow handling 'unknowns' in code gen.
        return this.isEquivalentOrMoreSpecific(otherSchema) !== AtLeastAsSpecific.NO;
    }
    // Returns true if there are fields in this.refinement, that are not in fields
    refinementHasFieldsNotIn(fields) {
        const amb = Object.keys(this.fields).filter(k => !(k in fields));
        for (const field of amb) {
            if (this.refinement && this.refinement.containsField(field)) {
                return true;
            }
        }
        return false;
    }
    hasQuery() {
        if (!this.refinement) {
            return false;
        }
        const qParams = this.refinement.getQueryParams();
        return qParams.size > 0;
    }
    crdtConstructor() {
        const singletons = {};
        const collections = {};
        // This implementation only supports:
        //   - singleton of a primitive,
        //   - singleton of a reference,
        //   - collection of primitives,
        //   - collection of references
        for (const [fieldName, field] of Object.entries(this.fields)) {
            const type = field.getType();
            const schema = field.getFieldType();
            switch (field.kind) {
                case 'schema-primitive': {
                    if (['Text', 'URL', 'Boolean', 'Number'].includes(type)) {
                        singletons[fieldName] = new crdt_singleton_CRDTSingleton();
                    }
                    else {
                        throw new Error(`Big Scary Exception: entity field ${fieldName} of type ${type} doesn't yet have a CRDT mapping implemented`);
                    }
                    break;
                }
                case 'schema-collection': {
                    if (schema == undefined) {
                        throw new Error(`there is no schema for the entity field ${fieldName}`);
                    }
                    if (['Text', 'URL', 'Boolean', 'Number'].includes(schema.getType())) {
                        collections[fieldName] = new crdt_collection_CRDTCollection();
                    }
                    else if (schema.kind === 'schema-reference') {
                        collections[fieldName] = new crdt_collection_CRDTCollection();
                    }
                    else {
                        throw new Error(`Big Scary Exception: entity field ${fieldName} of type ${schema.getType()} doesn't yet have a CRDT mapping implemented`);
                    }
                    break;
                }
                case 'schema-reference': {
                    singletons[fieldName] = new crdt_singleton_CRDTSingleton();
                    break;
                }
                case 'schema-ordered-list': {
                    singletons[fieldName] = new crdt_singleton_CRDTSingleton();
                    break;
                }
                default: {
                    throw new Error(`Big Scary Exception: entity field ${fieldName} of type ${schema.getType()} doesn't yet have a CRDT mapping implemented`);
                }
            }
        }
        return class EntityCRDT extends crdt_entity_CRDTEntity {
            constructor() {
                super(singletons, collections);
            }
        };
    }
    // TODO(jopra): Enforce that 'type' of a field is a Type.
    fieldToString([name, type]) {
        const refExpr = type.refinement ? type.refinement.toString() : '';
        const annotationsStr = (type.annotations || []).map(ann => ` ${ann.toString()}`).join('');
        return `${name}: ${type.toString()}${refExpr}${annotationsStr}`;
    }
    toInlineSchemaString(options) {
        const names = this.names.join(' ') || '*';
        const fields = Object.entries(this.fields).map(this.fieldToString).join(', ');
        return `${names} {${fields.length > 0 && options && options.hideFields ? '...' : fields}}${this.refinement ? this.refinement.toString() : ''}`;
    }
    toManifestString(builder = new IndentingStringBuilder()) {
        builder.push(...this.annotations.map(a => a.toString()));
        builder.push(`schema ${this.names.join(' ')}`);
        builder.withIndent(builder => {
            builder.push(...Object.entries(this.fields).map(f => this.fieldToString(f)));
            if (this.refinement) {
                builder.push(this.refinement.toString());
            }
            if (Object.keys(this.description).length > 0) {
                builder.push(`description \`${this.description.pattern}\``);
                builder.withIndent(builder => {
                    for (const name of Object.keys(this.description)) {
                        if (name !== 'pattern') {
                            builder.push(`${name} \`${this.description[name]}\``);
                        }
                    }
                });
            }
        });
        return builder.toString();
    }
    async hash() {
        if (!this.hashStr) {
            this.hashStr = await digest(this.normalizeForHash());
        }
        return this.hashStr;
    }
    normalizeForHash() {
        return this.names.slice().sort().join(' ') + '/' +
            Object.keys(this.fields).sort().map(field => `${field}:${this.fields[field].normalizeForHash()}`).join('') + '/';
    }
}
// The implementation of fromLiteral creates a cyclic dependency, so it is
// separated out. This variable serves the purpose of an abstract static.
schema_Schema.fromLiteral = null;
schema_Schema.EMPTY = new schema_Schema([], {});
//# sourceMappingURL=schema.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/types/internal/slot-info.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class SlotInfo {
    constructor(formFactor, handle) {
        this.formFactor = formFactor;
        this.handle = handle;
    }
    toLiteral() {
        return this;
    }
    static fromLiteral({ formFactor, handle }) {
        return new SlotInfo(formFactor, handle);
    }
}
//# sourceMappingURL=slot-info.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/types/internal/type.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */




class type_Type {
    constructor(tag) {
        this.tag = tag;
    }
    static unwrapPair(type1, type2) {
        if (type1.tag === type2.tag) {
            const contained1 = type1.getContainedType();
            if (contained1 !== null) {
                return type_Type.unwrapPair(contained1, type2.getContainedType());
            }
        }
        return [type1, type2];
    }
    static tryUnwrapMulti(type1, type2) {
        [type1, type2] = this.unwrapPair(type1, type2);
        if (type1.tag === type2.tag) {
            const contained1 = type1.getContainedTypes();
            if (contained1 !== null) {
                return [contained1, type2.getContainedTypes()];
            }
        }
        return [null, null];
    }
    /** Tests whether two types' constraints are compatible with each other. */
    static canMergeConstraints(type1, type2) {
        return type_Type._canMergeCanReadSubset(type1, type2) && type_Type._canMergeCanWriteSuperset(type1, type2);
    }
    static _canMergeCanReadSubset(type1, type2) {
        if (type1.canReadSubset && type2.canReadSubset) {
            if (type1.canReadSubset.tag !== type2.canReadSubset.tag) {
                return false;
            }
            if (type1.canReadSubset instanceof type_EntityType && type2.canReadSubset instanceof type_EntityType) {
                return schema_Schema.intersect(type1.canReadSubset.entitySchema, type2.canReadSubset.entitySchema) !== null;
            }
            throw new Error(`_canMergeCanReadSubset not implemented for types tagged with ${type1.canReadSubset.tag}`);
        }
        return true;
    }
    static _canMergeCanWriteSuperset(type1, type2) {
        if (type1.canWriteSuperset && type2.canWriteSuperset) {
            if (type1.canWriteSuperset.tag !== type2.canWriteSuperset.tag) {
                return false;
            }
            if (type1.canWriteSuperset instanceof type_EntityType && type2.canWriteSuperset instanceof type_EntityType) {
                return schema_Schema.union(type1.canWriteSuperset.entitySchema, type2.canWriteSuperset.entitySchema) !== null;
            }
        }
        return true;
    }
    isSlot() {
        return this instanceof type_SlotType;
    }
    slandleType() {
        if (this.isSlot()) {
            return this;
        }
        if (this.isCollectionType() && this.collectionType.isSlot()) {
            return this.collectionType;
        }
        return undefined;
    }
    // If you want to type-check fully, this is an improvement over just using
    // this instanceof CollectionType,
    // because instanceof doesn't propagate generic restrictions.
    isCollectionType() {
        return this instanceof type_CollectionType;
    }
    // If you want to type-check fully, this is an improvement over just using
    // this instaneceof BigCollectionType,
    // because instanceof doesn't propagate generic restrictions.
    isBigCollectionType() {
        return this instanceof type_BigCollectionType;
    }
    isReferenceType() {
        return this instanceof type_ReferenceType;
    }
    isMuxType() {
        return this instanceof type_MuxType && this.innerType instanceof type_EntityType;
    }
    isTupleType() {
        return this instanceof type_TupleType;
    }
    isResolved() {
        // TODO: one of these should not exist.
        return !this.hasUnresolvedVariable;
    }
    mergeTypeVariablesByName(variableMap) {
        return this;
    }
    _applyExistenceTypeTest(test) {
        return test(this);
    }
    get hasVariable() {
        return this._applyExistenceTypeTest(type => type instanceof type_TypeVariable);
    }
    get hasUnresolvedVariable() {
        return this._applyExistenceTypeTest(type => type instanceof type_TypeVariable && !type.variable.isResolved());
    }
    getContainedType() {
        return null;
    }
    getContainedTypes() {
        return null;
    }
    isTypeContainer() {
        return false;
    }
    get isReference() {
        return false;
    }
    get isMux() {
        return false;
    }
    get isSingleton() {
        return false;
    }
    get isCollection() {
        return false;
    }
    get isEntity() {
        return false;
    }
    get isInterface() {
        return false;
    }
    get isTuple() {
        return false;
    }
    get isVariable() {
        return false;
    }
    collectionOf() {
        return new type_CollectionType(this);
    }
    singletonOf() {
        return new type_SingletonType(this);
    }
    bigCollectionOf() {
        return new type_BigCollectionType(this);
    }
    referenceTo() {
        return new type_ReferenceType(this);
    }
    muxTypeOf() {
        return new type_MuxType(this);
    }
    resolvedType() {
        return this;
    }
    canEnsureResolved() {
        return this.isResolved() || this._canEnsureResolved();
    }
    _canEnsureResolved() {
        return true;
    }
    maybeEnsureResolved(options = undefined) {
        return true;
    }
    get canWriteSuperset() {
        throw new Error(`canWriteSuperset not implemented for ${this}`);
    }
    get canReadSubset() {
        throw new Error(`canReadSubset not implemented for ${this}`);
    }
    isAtLeastAsSpecificAs(type) {
        return this.tag === type.tag && this._isAtLeastAsSpecificAs(type);
    }
    _isAtLeastAsSpecificAs(type) {
        throw new Error(`isAtLeastAsSpecificAs not implemented for ${this}`);
    }
    /**
     * Clone a type object.
     * When cloning multiple types, variables that were associated with the same name
     * before cloning should still be associated after cloning. To maintain this
     * property, create a Map() and pass it into all clone calls in the group.
     */
    clone(variableMap) {
        return this.resolvedType()._clone(variableMap);
    }
    _clone(variableMap) {
        return type_Type.fromLiteral(this.toLiteral());
    }
    /**
     * Clone a type object, maintaining resolution information.
     * This function SHOULD NOT BE USED at the type level. In order for type variable
     * information to be maintained correctly, an entire context root needs to be
     * cloned.
     */
    _cloneWithResolutions(variableMap) {
        return type_Type.fromLiteral(this.toLiteral());
    }
    // TODO: is this the same as _applyExistenceTypeTest
    hasProperty(property) {
        return property(this) || this._hasProperty(property);
    }
    _hasProperty(property) {
        return false;
    }
    toString(options = undefined) {
        return this.tag;
    }
    getEntitySchema() {
        return null;
    }
    toPrettyString() {
        return null;
    }
    crdtInstanceConstructor() {
        return null;
    }
    handleConstructor() {
        return null;
    }
}
type_Type.fromLiteral = null;
class type_CountType extends type_Type {
    constructor() {
        super('Count');
    }
    toLiteral() {
        return { tag: 'Count' };
    }
    restrictTypeRanges(type) {
        external_assert_default()(this.tag === type.tag);
        throw new Error(`'restrictTypeRanges' is not supported for ${this.tag}`);
    }
    crdtInstanceConstructor() {
        return crdt_count_CRDTCount;
    }
}
class type_SingletonType extends type_Type {
    constructor(type) {
        super('Singleton');
        this.innerType = type;
    }
    toLiteral() {
        return { tag: 'Singleton', data: this.innerType.toLiteral() };
    }
    getContainedType() {
        return this.innerType;
    }
    crdtInstanceConstructor() {
        return crdt_singleton_CRDTSingleton;
    }
    handleConstructor() {
        return type_SingletonType.handleClass;
    }
    get isSingleton() {
        return true;
    }
    getEntitySchema() {
        return this.innerType.getEntitySchema();
    }
    toString(options = undefined) {
        return `![${this.innerType.toString(options)}]`;
    }
    get canWriteSuperset() {
        return this.innerType.canWriteSuperset;
    }
    get canReadSubset() {
        return this.innerType.canReadSubset;
    }
    restrictTypeRanges(type) {
        external_assert_default()(this.tag === type.tag);
        return new type_SingletonType(this.innerType.restrictTypeRanges(type));
    }
    mergeTypeVariablesByName(variableMap) {
        const innerType = this.innerType;
        const result = innerType.mergeTypeVariablesByName(variableMap);
        return (result === innerType) ? this : result.singletonOf();
    }
}
type_SingletonType.handleClass = null;
class type_EntityType extends type_Type {
    constructor(schema) {
        super('Entity');
        this.entitySchema = schema;
    }
    static make(names, fields, options = {}) {
        return new type_EntityType(new schema_Schema(names, fields, options));
    }
    // These type identifier methods are being left in place for non-runtime code.
    get isEntity() {
        return true;
    }
    get canWriteSuperset() {
        return this;
    }
    get canReadSubset() {
        return this;
    }
    _isAtLeastAsSpecificAs(type) {
        return this.entitySchema.isAtLeastAsSpecificAs(type.entitySchema);
    }
    toLiteral() {
        return { tag: this.tag, data: this.entitySchema.toLiteral() };
    }
    toString(options = undefined) {
        return this.entitySchema.toInlineSchemaString(options);
    }
    getEntitySchema() {
        return this.entitySchema;
    }
    _cloneWithResolutions(variableMap) {
        if (variableMap.has(this.entitySchema)) {
            return variableMap.get(this.entitySchema);
        }
        const clonedEntityType = new type_EntityType(this.entitySchema);
        variableMap.set(this.entitySchema, clonedEntityType);
        return clonedEntityType;
    }
    toPrettyString() {
        if (this.entitySchema.description.pattern) {
            return this.entitySchema.description.pattern;
        }
        // Spit MyTypeFOO to My Type FOO
        if (this.entitySchema.name) {
            return this.entitySchema.name.replace(/([^A-Z])([A-Z])/g, '$1 $2')
                .replace(/([A-Z][^A-Z])/g, ' $1')
                .replace(/[\s]+/g, ' ')
                .trim();
        }
        return JSON.stringify(this.entitySchema.toLiteral());
    }
    crdtInstanceConstructor() {
        return this.entitySchema.crdtConstructor();
    }
    handleConstructor() {
        // Currently using SingletonHandle as the implementation for Entity handles.
        // TODO: Make an EntityHandle class that uses the proper Entity CRDT.
        throw new Error(`Entity handle not yet implemented - you probably want to use a SingletonType`);
    }
    restrictTypeRanges(type) {
        external_assert_default()(this.tag === type.tag);
        external_assert_default()(this.getEntitySchema().name === type.getEntitySchema().name);
        return new type_EntityType(schema_Schema.intersect(this.getEntitySchema(), type.getEntitySchema()));
    }
}
class type_TypeVariable extends type_Type {
    constructor(variable) {
        super('TypeVariable');
        this.variable = variable;
    }
    static make(name, canWriteSuperset = null, canReadSubset = null, resolvesToMaxType = false) {
        return new type_TypeVariable(new type_TypeVariableInfo(name, canWriteSuperset, canReadSubset, resolvesToMaxType));
    }
    get isVariable() {
        return true;
    }
    mergeTypeVariablesByName(variableMap) {
        const name = this.variable.name;
        let variable = variableMap.get(name);
        if (!variable) {
            variable = this;
            variableMap.set(name, this);
        }
        else if (variable instanceof type_TypeVariable) {
            if (variable.variable.hasConstraint || this.variable.hasConstraint) {
                const mergedConstraint = variable.variable.maybeMergeConstraints(this.variable);
                if (!mergedConstraint) {
                    throw new Error('could not merge type variables');
                }
            }
        }
        return variable;
    }
    resolvedType() {
        return this.variable.resolution || this;
    }
    _canEnsureResolved() {
        return this.variable.canEnsureResolved();
    }
    maybeEnsureResolved(options = undefined) {
        return this.variable.maybeEnsureResolved(options);
    }
    get canWriteSuperset() {
        return this.variable.canWriteSuperset;
    }
    get canReadSubset() {
        return this.variable.canReadSubset;
    }
    _clone(variableMap) {
        const name = this.variable.name;
        if (variableMap.has(name)) {
            return new type_TypeVariable(variableMap.get(name));
        }
        else {
            const newTypeVariable = type_TypeVariableInfo.fromLiteral(this.variable.toLiteral());
            variableMap.set(name, newTypeVariable);
            return new type_TypeVariable(newTypeVariable);
        }
    }
    _cloneWithResolutions(variableMap) {
        if (variableMap.has(this.variable)) {
            return new type_TypeVariable(variableMap.get(this.variable));
        }
        else {
            const newTypeVariable = type_TypeVariableInfo.fromLiteral(this.variable.toLiteralIgnoringResolutions());
            if (this.variable.resolution) {
                newTypeVariable._resolution = this.variable._resolution._cloneWithResolutions(variableMap);
            }
            if (this.variable._canReadSubset) {
                newTypeVariable.canReadSubset = this.variable.canReadSubset._cloneWithResolutions(variableMap);
            }
            if (this.variable._canWriteSuperset) {
                newTypeVariable.canWriteSuperset = this.variable.canWriteSuperset._cloneWithResolutions(variableMap);
            }
            if (this.variable._originalCanReadSubset) {
                newTypeVariable._originalCanReadSubset = this.variable._originalCanReadSubset._cloneWithResolutions(variableMap);
            }
            if (this.variable._originalCanWriteSuperset) {
                newTypeVariable._originalCanWriteSuperset = this.variable._originalCanWriteSuperset._cloneWithResolutions(variableMap);
            }
            variableMap.set(this.variable, newTypeVariable);
            return new type_TypeVariable(newTypeVariable);
        }
    }
    toLiteral() {
        return this.variable.resolution ? this.variable.resolution.toLiteral()
            : { tag: this.tag, data: this.variable.toLiteral() };
    }
    toString(options = undefined) {
        return `~${this.variable.name}`;
    }
    getEntitySchema() {
        return this.variable.isResolved() ? this.resolvedType().getEntitySchema() : null;
    }
    toPrettyString() {
        return this.variable.isResolved() ? this.resolvedType().toPrettyString() : `[~${this.variable.name}]`;
    }
    restrictTypeRanges(type) {
        external_assert_default()(this.tag === type.tag);
        const typeVar = type;
        const restrictedTypeVar = this.variable.restrictTypeRanges(typeVar.variable);
        if (!restrictedTypeVar) {
            throw new Error(`Cannot restrict type ranges of ${this.variable.toPrettyString()}`
                + ` and ${typeVar.variable.toPrettyString()}`);
        }
        return new type_TypeVariable(restrictedTypeVar);
    }
}
class type_CollectionType extends type_Type {
    constructor(collectionType) {
        super('Collection');
        this.collectionType = collectionType;
    }
    get isCollection() {
        return true;
    }
    _isAtLeastAsSpecificAs(type) {
        return this.getContainedType().isAtLeastAsSpecificAs(type.getContainedType());
    }
    mergeTypeVariablesByName(variableMap) {
        const collectionType = this.collectionType;
        const result = collectionType.mergeTypeVariablesByName(variableMap);
        return (result === collectionType) ? this : result.collectionOf();
    }
    _applyExistenceTypeTest(test) {
        return this.collectionType._applyExistenceTypeTest(test);
    }
    getContainedType() {
        return this.collectionType;
    }
    isTypeContainer() {
        return true;
    }
    resolvedType() {
        const collectionType = this.collectionType;
        const resolvedCollectionType = collectionType.resolvedType();
        return (collectionType !== resolvedCollectionType) ? resolvedCollectionType.collectionOf() : this;
    }
    _canEnsureResolved() {
        return this.collectionType.canEnsureResolved();
    }
    maybeEnsureResolved(options = undefined) {
        return this.collectionType.maybeEnsureResolved(options);
    }
    get canWriteSuperset() {
        return type_InterfaceType.make(this.tag, [], []);
    }
    get canReadSubset() {
        return type_InterfaceType.make(this.tag, [], []);
    }
    _clone(variableMap) {
        const data = this.collectionType.clone(variableMap).toLiteral();
        return type_Type.fromLiteral({ tag: this.tag, data });
    }
    _cloneWithResolutions(variableMap) {
        return new type_CollectionType(this.collectionType._cloneWithResolutions(variableMap));
    }
    toLiteral() {
        return { tag: this.tag, data: this.collectionType.toLiteral() };
    }
    _hasProperty(property) {
        return this.collectionType.hasProperty(property);
    }
    toString(options = undefined) {
        return `[${this.collectionType.toString(options)}]`;
    }
    getEntitySchema() {
        return this.collectionType.getEntitySchema();
    }
    toPrettyString() {
        const entitySchema = this.getEntitySchema();
        if (entitySchema && entitySchema.description.plural) {
            return entitySchema.description.plural;
        }
        return `${this.collectionType.toPrettyString()} List`;
    }
    crdtInstanceConstructor() {
        return crdt_collection_CRDTCollection;
    }
    handleConstructor() {
        return type_CollectionType.handleClass;
    }
    restrictTypeRanges(type) {
        external_assert_default()(this.tag === type.tag);
        return new type_CollectionType(this.getContainedType().restrictTypeRanges(type.getContainedType()));
    }
}
type_CollectionType.handleClass = null;
class type_BigCollectionType extends type_Type {
    constructor(bigCollectionType) {
        super('BigCollection');
        this.bigCollectionType = bigCollectionType;
    }
    get isBigCollection() {
        return true;
    }
    mergeTypeVariablesByName(variableMap) {
        const collectionType = this.bigCollectionType;
        const result = collectionType.mergeTypeVariablesByName(variableMap);
        return (result === collectionType) ? this : result.bigCollectionOf();
    }
    _applyExistenceTypeTest(test) {
        return this.bigCollectionType._applyExistenceTypeTest(test);
    }
    getContainedType() {
        return this.bigCollectionType;
    }
    isTypeContainer() {
        return true;
    }
    resolvedType() {
        const collectionType = this.bigCollectionType;
        const resolvedCollectionType = collectionType.resolvedType();
        return (collectionType !== resolvedCollectionType) ? resolvedCollectionType.bigCollectionOf() : this;
    }
    _canEnsureResolved() {
        return this.bigCollectionType.canEnsureResolved();
    }
    maybeEnsureResolved(options = undefined) {
        return this.bigCollectionType.maybeEnsureResolved(options);
    }
    get canWriteSuperset() {
        return type_InterfaceType.make(this.tag, [], []);
    }
    get canReadSubset() {
        return type_InterfaceType.make(this.tag, [], []);
    }
    _clone(variableMap) {
        const data = this.bigCollectionType.clone(variableMap).toLiteral();
        return type_Type.fromLiteral({ tag: this.tag, data });
    }
    _cloneWithResolutions(variableMap) {
        return new type_BigCollectionType(this.bigCollectionType._cloneWithResolutions(variableMap));
    }
    toLiteral() {
        return { tag: this.tag, data: this.bigCollectionType.toLiteral() };
    }
    _hasProperty(property) {
        return this.bigCollectionType.hasProperty(property);
    }
    toString(options = undefined) {
        return `BigCollection<${this.bigCollectionType.toString(options)}>`;
    }
    getEntitySchema() {
        return this.bigCollectionType.getEntitySchema();
    }
    toPrettyString() {
        const entitySchema = this.getEntitySchema();
        if (entitySchema && entitySchema.description.plural) {
            return entitySchema.description.plural;
        }
        return `Collection of ${this.bigCollectionType.toPrettyString()}`;
    }
    restrictTypeRanges(type) {
        external_assert_default()(this.tag === type.tag);
        throw new Error(`'restrictTypeRanges' is not supported for ${this.tag}`);
    }
}
class type_TupleType extends type_Type {
    constructor(innerTypes) {
        super('Tuple');
        this.innerTypes = innerTypes;
    }
    get isTuple() {
        return true;
    }
    isTypeContainer() {
        return true;
    }
    getContainedTypes() {
        return this.innerTypes;
    }
    get canWriteSuperset() {
        return new type_TupleType(this.innerTypes.map(t => t.canWriteSuperset));
    }
    get canReadSubset() {
        return new type_TupleType(this.innerTypes.map(t => t.canReadSubset));
    }
    resolvedType() {
        let returnSelf = true;
        const resolvedinnerTypes = [];
        for (const t of this.innerTypes) {
            const resolved = t.resolvedType();
            if (resolved !== t)
                returnSelf = false;
            resolvedinnerTypes.push(resolved);
        }
        if (returnSelf)
            return this;
        return new type_TupleType(resolvedinnerTypes);
    }
    _canEnsureResolved() {
        return this.innerTypesSatisfy((type) => type.canEnsureResolved());
    }
    maybeEnsureResolved(options = undefined) {
        return this.innerTypesSatisfy((type) => type.maybeEnsureResolved(options));
    }
    _isAtLeastAsSpecificAs(other) {
        if (this.innerTypes.length !== other.innerTypes.length)
            return false;
        return this.innerTypesSatisfy((type, idx) => type.isAtLeastAsSpecificAs(other.innerTypes[idx]));
    }
    innerTypesSatisfy(predicate) {
        return this.innerTypes.reduce((result, type, idx) => result && predicate(type, idx), true);
    }
    _applyExistenceTypeTest(test) {
        return this.innerTypes.reduce((result, type) => result || type._applyExistenceTypeTest(test), false);
    }
    toLiteral() {
        return { tag: this.tag, data: this.innerTypes.map(t => t.toLiteral()) };
    }
    toString(options = undefined) {
        return `(${this.innerTypes.map(t => t.toString(options)).join(', ')})`;
    }
    toPrettyString() {
        return 'Tuple of ' + this.innerTypes.map(t => t.toPrettyString()).join(', ');
    }
    restrictTypeRanges(type) {
        external_assert_default()(this.tag === type.tag);
        return new type_TupleType(this.getContainedTypes().map((innerType, idx) => innerType.restrictTypeRanges(type.getContainedTypes()[idx])));
    }
    _clone(variableMap) {
        return new type_TupleType(this.innerTypes.map(t => t.clone(variableMap)));
    }
    _cloneWithResolutions(variableMap) {
        return new type_TupleType(this.innerTypes.map(t => t._cloneWithResolutions(variableMap)));
    }
    mergeTypeVariablesByName(variableMap) {
        let mergeSuccess = false;
        const results = [];
        for (const type of this.innerTypes) {
            const result = type.mergeTypeVariablesByName(variableMap);
            if (result !== type) {
                mergeSuccess = true;
            }
            results.push(result);
        }
        return mergeSuccess ? new type_TupleType(results) : this;
    }
}
class type_InterfaceType extends type_Type {
    constructor(iface) {
        super('Interface');
        this.interfaceInfo = iface;
    }
    static make(name, handleConnections, slots) {
        return new type_InterfaceType(type_InterfaceInfo.make(name, handleConnections, slots));
    }
    get isInterface() {
        return true;
    }
    mergeTypeVariablesByName(variableMap) {
        const interfaceInfo = this.interfaceInfo.clone(new Map());
        interfaceInfo.mergeTypeVariablesByName(variableMap);
        // TODO: only build a new type when a variable is modified
        return new type_InterfaceType(interfaceInfo);
    }
    _applyExistenceTypeTest(test) {
        return this.interfaceInfo._applyExistenceTypeTest(test);
    }
    resolvedType() {
        return new type_InterfaceType(this.interfaceInfo.resolvedType());
    }
    _canEnsureResolved() {
        return this.interfaceInfo.canEnsureResolved();
    }
    maybeEnsureResolved(options = undefined) {
        return this.interfaceInfo.maybeEnsureResolved();
    }
    get canWriteSuperset() {
        return new type_InterfaceType(this.interfaceInfo.canWriteSuperset);
    }
    get canReadSubset() {
        return new type_InterfaceType(this.interfaceInfo.canReadSubset);
    }
    _isAtLeastAsSpecificAs(type) {
        return this.interfaceInfo.isAtLeastAsSpecificAs(type.interfaceInfo);
    }
    _clone(variableMap) {
        const data = this.interfaceInfo.clone(variableMap).toLiteral();
        return type_Type.fromLiteral({ tag: this.tag, data });
    }
    _cloneWithResolutions(variableMap) {
        return new type_InterfaceType(this.interfaceInfo.cloneWithResolutions(variableMap));
    }
    toLiteral() {
        return { tag: this.tag, data: this.interfaceInfo.toLiteral() };
    }
    toString(options = undefined) {
        return this.interfaceInfo.name;
    }
    toPrettyString() {
        return this.interfaceInfo.toPrettyString();
    }
    restrictTypeRanges(type) {
        external_assert_default()(this.tag === type.tag);
        throw new Error(`'restrictTypeRanges' is not supported for ${this.tag}`);
    }
}
class type_SlotType extends type_Type {
    constructor(slot) {
        super('Slot');
        this.slot = slot;
    }
    static make(formFactor, handle) {
        return new type_SlotType(new SlotInfo(formFactor, handle));
    }
    getSlot() {
        return this.slot;
    }
    get canWriteSuperset() {
        return this;
    }
    get canReadSubset() {
        return this;
    }
    _isAtLeastAsSpecificAs(type) {
        // TODO: formFactor checking, etc.
        return true;
    }
    toLiteral() {
        return { tag: this.tag, data: this.slot.toLiteral() };
    }
    toString(options = undefined) {
        const fields = [];
        for (const key of Object.keys(this.slot)) {
            if (this.slot[key] !== undefined) {
                fields.push(`${key}:${this.slot[key]}`);
            }
        }
        let fieldsString = '';
        if (fields.length !== 0) {
            fieldsString = ` {${fields.join(', ')}}`;
        }
        return `Slot${fieldsString}`;
    }
    toPrettyString() {
        const fields = [];
        for (const key of Object.keys(this.slot)) {
            if (this.slot[key] !== undefined) {
                fields.push(`${key}:${this.slot[key]}`);
            }
        }
        let fieldsString = '';
        if (fields.length !== 0) {
            fieldsString = ` {${fields.join(', ')}}`;
        }
        return `Slot${fieldsString}`;
    }
    restrictTypeRanges(type) {
        external_assert_default()(this.tag === type.tag);
        throw new Error(`'restrictTypeRanges' is not supported for ${this.tag}`);
    }
}
class type_ReferenceType extends type_Type {
    constructor(reference) {
        super('Reference');
        if (reference == null) {
            throw new Error('invalid type! Reference types must include a referenced type declaration');
        }
        this.referredType = reference;
    }
    get isReference() {
        return true;
    }
    getContainedType() {
        return this.referredType;
    }
    isTypeContainer() {
        return true;
    }
    resolvedType() {
        const referredType = this.referredType;
        const resolvedReferredType = referredType.resolvedType();
        return (referredType !== resolvedReferredType) ? new type_ReferenceType(resolvedReferredType) : this;
    }
    _isAtLeastAsSpecificAs(type) {
        return this.getContainedType().isAtLeastAsSpecificAs(type.getContainedType());
    }
    _canEnsureResolved() {
        return this.referredType.canEnsureResolved();
    }
    maybeEnsureResolved(options = undefined) {
        return this.referredType.maybeEnsureResolved(options);
    }
    get canWriteSuperset() {
        // TODO(cypher1): Possibly cannot write to references.
        return this.referredType.canWriteSuperset;
    }
    get canReadSubset() {
        return this.referredType.canReadSubset;
    }
    _clone(variableMap) {
        const data = this.referredType.clone(variableMap).toLiteral();
        return type_Type.fromLiteral({ tag: this.tag, data });
    }
    _cloneWithResolutions(variableMap) {
        return new type_ReferenceType(this.referredType._cloneWithResolutions(variableMap));
    }
    _applyExistenceTypeTest(test) {
        return this.referredType._applyExistenceTypeTest(test);
    }
    toLiteral() {
        return { tag: this.tag, data: this.referredType.toLiteral() };
    }
    toString(options = undefined) {
        return '&' + this.referredType.toString();
    }
    toPrettyString() {
        return 'Reference to ' + this.referredType.toPrettyString();
    }
    getEntitySchema() {
        return this.referredType.getEntitySchema();
    }
    crdtInstanceConstructor() {
        return this.referredType.crdtInstanceConstructor();
    }
    restrictTypeRanges(type) {
        external_assert_default()(this.tag === type.tag);
        return new type_ReferenceType(this.getContainedType().restrictTypeRanges(type.getContainedType()));
    }
    mergeTypeVariablesByName(variableMap) {
        const referredType = this.referredType;
        const result = referredType.mergeTypeVariablesByName(variableMap);
        return (result === referredType) ? this : result.referenceTo();
    }
}
class type_MuxType extends type_Type {
    constructor(type) {
        super('Mux');
        if (type == null) {
            throw new Error('invalid type! Mux types must include an inner type declaration');
        }
        this.innerType = type;
    }
    get isMux() {
        return true;
    }
    getContainedType() {
        return this.innerType;
    }
    isTypeContainer() {
        return true;
    }
    resolvedType() {
        const innerType = this.innerType;
        const resolvedInnerType = innerType.resolvedType();
        return (innerType !== resolvedInnerType) ? new type_MuxType(resolvedInnerType) : this;
    }
    _canEnsureResolved() {
        return this.innerType.canEnsureResolved();
    }
    maybeEnsureResolved(options = undefined) {
        return this.innerType.maybeEnsureResolved(options);
    }
    get canWriteSuperset() {
        return this.innerType.canWriteSuperset;
    }
    get canReadSubset() {
        return this.innerType.canReadSubset;
    }
    _clone(variableMap) {
        const data = this.innerType.clone(variableMap).toLiteral();
        return type_Type.fromLiteral({ tag: this.tag, data });
    }
    _cloneWithResolutions(variableMap) {
        return new type_MuxType(this.innerType._cloneWithResolutions(variableMap));
    }
    toLiteral() {
        return { tag: this.tag, data: this.innerType.toLiteral() };
    }
    toString(options = undefined) {
        return '#' + this.innerType.toString();
    }
    toPrettyString() {
        return 'Mux Type of ' + this.innerType.toPrettyString();
    }
    getEntitySchema() {
        return this.innerType.getEntitySchema();
    }
    crdtInstanceConstructor() {
        return this.innerType.crdtInstanceConstructor();
    }
    handleConstructor() {
        return type_MuxType.handleClass;
    }
    restrictTypeRanges(type) {
        external_assert_default()(this.tag === type.tag);
        throw new type_MuxType(this.getContainedType().restrictTypeRanges(type.getContainedType()));
    }
    mergeTypeVariablesByName(variableMap) {
        const innerType = this.innerType;
        const result = innerType.mergeTypeVariablesByName(variableMap);
        return (result === innerType) ? this : result.muxTypeOf();
    }
}
type_MuxType.handleClass = null;
class type_HandleType extends type_Type {
    constructor() {
        super('Handle');
    }
    get isHandle() {
        return true;
    }
    toLiteral() {
        return { tag: this.tag };
    }
    restrictTypeRanges(type) {
        external_assert_default()(this.tag === type.tag);
        throw new Error(`'restrictTypeRanges' is not supported for ${this.tag}`);
    }
}
class type_TypeVariableInfo {
    constructor(name, canWriteSuperset, canReadSubset, resolveToMaxType = false) {
        this.name = name;
        this._canWriteSuperset = canWriteSuperset;
        this._canReadSubset = canReadSubset;
        this._resolution = null;
        this.resolveToMaxType = resolveToMaxType;
    }
    /**
     * Merge both the read subset (upper bound) and write superset (lower bound) constraints
     * of two variables together. Use this when two separate type variables need to resolve
     * to the same value.
     */
    maybeMergeConstraints(variable) {
        if (!this.maybeMergeCanReadSubset(variable.canReadSubset)) {
            return false;
        }
        return this.maybeMergeCanWriteSuperset(variable.canWriteSuperset);
    }
    /**
     * Merge a type variable's read subset (upper bound) constraints into this variable.
     * This is used to accumulate read constraints when resolving a handle's type.
     */
    maybeMergeCanReadSubset(constraint) {
        const { result, success } = this._maybeMerge(this.canReadSubset, constraint, schema_Schema.intersect);
        this.canReadSubset = result;
        return success;
    }
    /**
     * merge a type variable's write superset (lower bound) constraints into this variable.
     * This is used to accumulate write constraints when resolving a handle's type.
     */
    maybeMergeCanWriteSuperset(constraint) {
        const { result, success } = this._maybeMerge(this.canWriteSuperset, constraint, schema_Schema.union);
        this.canWriteSuperset = result;
        return success;
    }
    // Helper to generalize canReadSubset and canWriteSuperset merging
    _maybeMerge(target, constraint, merger) {
        if (constraint == null) {
            return { success: true, result: target };
        }
        if (target == null) {
            return { success: true, result: constraint };
        }
        if (target instanceof type_SlotType && constraint instanceof type_SlotType) {
            // TODO: formFactor compatibility, etc.
            return { success: true, result: target };
        }
        if (target instanceof type_EntityType && constraint instanceof type_EntityType) {
            const mergedSchema = merger(target.entitySchema, constraint.entitySchema);
            if (!mergedSchema) {
                return { success: false, result: target };
            }
            return { success: true, result: new type_EntityType(mergedSchema) };
        }
        return { success: false, result: target };
    }
    isSatisfiedBy(type) {
        const constraint = this._canWriteSuperset;
        if (!constraint) {
            return true;
        }
        if (!(constraint instanceof type_EntityType) || !(type instanceof type_EntityType)) {
            throw new Error(`constraint checking not implemented for ${this} and ${type}`);
        }
        return type.getEntitySchema().isAtLeastAsSpecificAs(constraint.getEntitySchema());
    }
    get resolution() {
        if (this._resolution) {
            return this._resolution.resolvedType();
        }
        return null;
    }
    isValidResolutionCandidate(value) {
        const elementType = value.resolvedType().getContainedType();
        if (elementType instanceof type_TypeVariable && elementType.variable === this) {
            return { result: false, detail: 'variable cannot resolve to collection of itself' };
        }
        return { result: true };
    }
    set resolution(value) {
        external_assert_default()(!this._resolution);
        const isValid = this.isValidResolutionCandidate(value);
        external_assert_default()(isValid.result, isValid.detail);
        let probe = value;
        while (probe) {
            if (!(probe instanceof type_TypeVariable)) {
                break;
            }
            if (this.resolveToMaxType) {
                probe.variable.resolveToMaxType = true;
            }
            if (probe.variable === this) {
                return;
            }
            probe = probe.variable.resolution;
        }
        this._resolution = value;
        this._originalCanWriteSuperset = this._canWriteSuperset;
        this._canWriteSuperset = null;
        this._originalCanReadSubset = this._canReadSubset;
        this._canReadSubset = null;
    }
    get canWriteSuperset() {
        if (this._resolution) {
            external_assert_default()(!this._canWriteSuperset);
            if (this._resolution instanceof type_TypeVariable) {
                return this._resolution.variable.canWriteSuperset;
            }
            return null;
        }
        return this._canWriteSuperset;
    }
    set canWriteSuperset(value) {
        external_assert_default()(!this._resolution);
        this._canWriteSuperset = value;
    }
    get canReadSubset() {
        if (this._resolution) {
            external_assert_default()(!this._canReadSubset);
            if (this._resolution instanceof type_TypeVariable) {
                return this._resolution.variable.canReadSubset;
            }
            return null;
        }
        return this._canReadSubset;
    }
    set canReadSubset(value) {
        external_assert_default()(!this._resolution);
        this._canReadSubset = value;
    }
    get hasConstraint() {
        return this._canReadSubset !== null || this._canWriteSuperset !== null;
    }
    canEnsureResolved() {
        if (this._resolution) {
            return this._resolution.canEnsureResolved();
        }
        if (this._canWriteSuperset || this._canReadSubset) {
            return true;
        }
        return false;
    }
    maybeEnsureResolved(options = undefined) {
        if (this._resolution) {
            return this._resolution.maybeEnsureResolved(options);
        }
        if (this.resolveToMaxType && this._canReadSubset) {
            this.resolution = this._canReadSubset;
            return true;
        }
        if (this._canWriteSuperset) {
            this.resolution = this._canWriteSuperset;
            return true;
        }
        if (options && options.restrictToMinBound) {
            const entitySchema = this._canReadSubset
                ? this._canReadSubset.getEntitySchema() : null;
            this.resolution = new type_EntityType(new schema_Schema(entitySchema ? entitySchema.names : [], {}, entitySchema || {}));
            return true;
        }
        if (this._canReadSubset) {
            this.resolution = this._canReadSubset;
            return true;
        }
        return false;
    }
    toLiteral() {
        external_assert_default()(this.resolution == null);
        return this.toLiteralIgnoringResolutions();
    }
    toLiteralIgnoringResolutions() {
        return {
            name: this.name,
            canWriteSuperset: this._canWriteSuperset && this._canWriteSuperset.toLiteral(),
            canReadSubset: this._canReadSubset && this._canReadSubset.toLiteral(),
            resolveToMaxType: this.resolveToMaxType
        };
    }
    static fromLiteral(data) {
        return new type_TypeVariableInfo(data.name, data.canWriteSuperset ? type_Type.fromLiteral(data.canWriteSuperset) : null, data.canReadSubset ? type_Type.fromLiteral(data.canReadSubset) : null, data.resolveToMaxType);
    }
    isResolved() {
        return this._resolution && this._resolution.isResolved();
    }
    restrictTypeRanges(other) {
        const thisCanWriteSuperset = this.canWriteSuperset || this._originalCanWriteSuperset;
        const otherCanWriteSuperset = other.canWriteSuperset || other._originalCanWriteSuperset;
        let newCanWriteSuperset = thisCanWriteSuperset || otherCanWriteSuperset;
        if (thisCanWriteSuperset && otherCanWriteSuperset) {
            const unionSchema = schema_Schema.union(thisCanWriteSuperset.getEntitySchema(), otherCanWriteSuperset.getEntitySchema());
            if (!unionSchema) {
                throw new Error(`Cannot union schemas: ${thisCanWriteSuperset.toString()} and ${otherCanWriteSuperset.toString()}`);
            }
            newCanWriteSuperset = new type_EntityType(unionSchema);
        }
        const thisCanReadSubset = this.canReadSubset || this._originalCanReadSubset;
        const otherCanReadSubset = other.canReadSubset || other._originalCanReadSubset;
        let newCanReadSubset = thisCanReadSubset || otherCanReadSubset;
        if (thisCanReadSubset && otherCanReadSubset) {
            newCanReadSubset = new type_EntityType(schema_Schema.intersect(thisCanReadSubset.getEntitySchema(), otherCanReadSubset.getEntitySchema()));
        }
        if (newCanWriteSuperset && newCanReadSubset
            && !newCanReadSubset.isAtLeastAsSpecificAs(newCanWriteSuperset)) {
            // Max bound must be at least as specific as min bound.
            return null;
        }
        return new type_TypeVariableInfo(this.name, newCanWriteSuperset, newCanReadSubset, this.resolveToMaxType);
    }
    toPrettyString() {
        return `[${(this.canWriteSuperset || 'undefined').toString()} - ${(this.canReadSubset || 'undefined').toString()}]`;
    }
}
class type_InterfaceInfo {
    constructor(name, handleConnections, slots) {
        external_assert_default()(name);
        external_assert_default()(handleConnections !== undefined);
        external_assert_default()(slots !== undefined);
        this.name = name;
        this.handleConnections = handleConnections;
        this.slots = slots;
        this.typeVars = [];
    }
    toPrettyString() {
        return 'InterfaceInfo';
    }
    mergeTypeVariablesByName(variableMap) {
        this.typeVars.forEach(({ object, field }) => object[field] = object[field].mergeTypeVariablesByName(variableMap));
    }
    static _updateTypeVar(typeVar, update) {
        typeVar.object[typeVar.field] = update(typeVar.object[typeVar.field]);
    }
    static isTypeVar(reference) {
        return reference instanceof type_TypeVariable || reference instanceof type_Type && reference.hasVariable;
    }
    static mustMatch(reference) {
        return !(reference == undefined || type_InterfaceInfo.isTypeVar(reference));
    }
}
type_InterfaceInfo.make = null;
type_InterfaceInfo.fromLiteral = null;
type_InterfaceInfo.handleConnectionsMatch = null;
type_InterfaceInfo.slotsMatch = null;
//# sourceMappingURL=type.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/types/lib-types.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */




//# sourceMappingURL=lib-types.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/type-checker.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


class type_checker_TypeChecker {
    // NOTE: you almost definitely don't want to call this function, if you think
    // you do, talk to shans@.
    static getResolution(candidate, options) {
        if (candidate.isCollectionType()) {
            const resolution = type_checker_TypeChecker.getResolution(candidate.collectionType, options);
            return (resolution !== null) ? resolution.collectionOf() : null;
        }
        if (candidate.isBigCollectionType()) {
            const resolution = type_checker_TypeChecker.getResolution(candidate.bigCollectionType, options);
            return (resolution !== null) ? resolution.bigCollectionOf() : null;
        }
        if (candidate.isReferenceType()) {
            const resolution = type_checker_TypeChecker.getResolution(candidate.referredType, options);
            return (resolution !== null) ? resolution.referenceTo() : null;
        }
        if (candidate.isMuxType()) {
            const resolution = type_checker_TypeChecker.getResolution(candidate.innerType, options);
            return (resolution != null) ? resolution.muxTypeOf() : null;
        }
        if (candidate.isTupleType()) {
            const resolutions = candidate.innerTypes.map(t => type_checker_TypeChecker.getResolution(t, options));
            return resolutions.every(r => r !== null) ? new type_TupleType(resolutions) : null;
        }
        if (!(candidate instanceof type_TypeVariable)) {
            return candidate;
        }
        if (candidate.canReadSubset == null || candidate.canWriteSuperset == null) {
            // This variable cannot be concretized without losing information.
            return candidate;
        }
        if (candidate.canReadSubset.isAtLeastAsSpecificAs(candidate.canWriteSuperset)) {
            // The resolution is still possible, but we may not have more information than the current candidate.
            if (candidate.canWriteSuperset.isAtLeastAsSpecificAs(candidate.canReadSubset)) {
                // The type bounds have 'met', they are equivalent and are the resolution.
                candidate.variable.resolution = candidate.canReadSubset;
            }
            return candidate;
        }
        // The candidate's requirements are no longer valid, it is uninhabitable / unsatisfiable.
        if (options && options.typeErrors) {
            const msg = `could not guarantee variable ${candidate} meets read requirements ${candidate.canWriteSuperset} with write guarantees ${candidate.canReadSubset}`;
            options.typeErrors.push(msg);
        }
        return null;
    }
    // resolve a list of handleConnection types against a handle
    // base type. This is the core type resolution mechanism, but should only
    // be used when types can actually be associated with each other / constrained.
    //
    // By design this function is called exactly once per handle in a recipe during
    // normalization, and should provide the same final answers regardless of the
    // ordering of handles within that recipe
    //
    // NOTE: you probably don't want to call this function, if you think you
    // do, talk to shans@.
    static processTypeList(baseType, list, options = {}) {
        const newBaseType = type_TypeVariable.make('');
        if (baseType) {
            newBaseType.variable.resolution = baseType;
        }
        baseType = newBaseType;
        const concreteTypes = [];
        // baseType might be a variable (and is definitely a variable if no baseType was available).
        // Some of the list might contain variables too.
        // First attempt to merge all the variables into the baseType
        //
        // If the baseType is a variable then this results in a single place to manipulate the constraints
        // of all the other connected variables at the same time.
        for (const item of list) {
            if (item.type.resolvedType().hasVariable) {
                baseType = type_checker_TypeChecker._tryMergeTypeVariable(baseType, item.type, options);
                if (baseType == null) {
                    return null;
                }
            }
            else {
                concreteTypes.push(item);
            }
        }
        for (const item of concreteTypes) {
            if (item.relaxed) {
                // Skip relaxed handles, as they do not constrain the type.
                continue;
            }
            if (!type_checker_TypeChecker._tryMergeConstraints(baseType, item, options)) {
                return null;
            }
        }
        return type_checker_TypeChecker.getResolution(baseType.resolvedType(), options);
    }
    static _tryMergeTypeVariable(base, onto, options = {}) {
        const [primitiveBase, primitiveOnto] = type_Type.unwrapPair(base.resolvedType(), onto.resolvedType());
        switch (when(primitiveBase instanceof type_TypeVariable, primitiveOnto instanceof type_TypeVariable)) {
            case when(true, true): {
                // base, onto both variables.
                const result = primitiveBase.variable.maybeMergeConstraints(primitiveOnto.variable);
                if (result === false) {
                    return null;
                }
                primitiveOnto.variable.resolution = primitiveBase;
                return base;
            }
            case when(true, false):
                // base variable, onto not.
                if (!primitiveBase.variable.isValidResolutionCandidate(primitiveOnto).result) {
                    return null;
                }
                primitiveBase.variable.resolution = primitiveOnto;
                return base;
            case when(false, true):
                // onto variable, base not.
                if (!primitiveOnto.variable.isValidResolutionCandidate(primitiveBase).result) {
                    return null;
                }
                primitiveOnto.variable.resolution = primitiveBase;
                return onto;
            default:
                break;
        }
        if (primitiveBase instanceof type_InterfaceType && primitiveOnto instanceof type_InterfaceType) {
            const result = primitiveBase.interfaceInfo.tryMergeTypeVariablesWith(primitiveOnto.interfaceInfo);
            if (result == null) {
                return null;
            }
            return new type_InterfaceType(result);
        }
        else if ((primitiveBase.isTypeContainer() && primitiveBase.hasVariable)
            || (primitiveOnto.isTypeContainer() && primitiveOnto.hasVariable)) {
            // Cannot merge [~a] with a type that is not a variable and not a collection.
            return null;
        }
        throw new Error('tryMergeTypeVariable shouldn\'t be called on two types without any type variables');
    }
    static _tryMergeConstraints(handleType, { type, relaxed, direction }, options = {}) {
        const [handleInnerTypes, connectionInnerTypes] = type_Type.tryUnwrapMulti(handleType.resolvedType(), type.resolvedType());
        // If both handle and connection are matching type containers with multiple arguments,
        // merge constraints pairwaise for all inner types.
        if (handleInnerTypes != null) {
            if (handleInnerTypes.length !== connectionInnerTypes.length)
                return false;
            for (let i = 0; i < handleInnerTypes.length; i++) {
                if (!this._tryMergeConstraints(handleInnerTypes[i], { type: connectionInnerTypes[i], relaxed, direction }, options)) {
                    return false;
                }
            }
            return true;
        }
        const [primitiveHandleType, primitiveConnectionType] = type_Type.unwrapPair(handleType.resolvedType(), type.resolvedType());
        if (primitiveHandleType instanceof type_TypeVariable) {
            if (primitiveConnectionType.isTypeContainer()) {
                if (primitiveHandleType.variable.resolution != null
                    || primitiveHandleType.variable.canReadSubset != null
                    || primitiveHandleType.variable.canWriteSuperset != null) {
                    // Resolved and/or constrained variables can only represent Entities, not sets.
                    return false;
                }
                // If this is an undifferentiated variable then we need to create structure to match against. That's
                // allowed because this variable could represent anything, and it needs to represent this structure
                // in order for type resolution to succeed.
                if (primitiveConnectionType instanceof type_CollectionType) {
                    primitiveHandleType.variable.resolution = new type_CollectionType(type_TypeVariable.make('a'));
                }
                else if (primitiveConnectionType instanceof type_BigCollectionType) {
                    primitiveHandleType.variable.resolution = new type_BigCollectionType(type_TypeVariable.make('a'));
                }
                else if (primitiveConnectionType instanceof type_ReferenceType) {
                    primitiveHandleType.variable.resolution = new type_ReferenceType(type_TypeVariable.make('a'));
                }
                else if (primitiveConnectionType instanceof type_MuxType) {
                    primitiveHandleType.variable.resolution = new type_MuxType(type_TypeVariable.make('a'));
                }
                else if (primitiveConnectionType instanceof type_TupleType) {
                    primitiveHandleType.variable.resolution = new type_TupleType(primitiveConnectionType.innerTypes.map((_, idx) => type_TypeVariable.make(`a${idx}`)));
                }
                else {
                    throw new TypeError(`Unrecognized type container: ${primitiveConnectionType.tag}`);
                }
                // Call recursively to unwrap and merge constraints of potentially multiple type variables (e.g. for tuples).
                return this._tryMergeConstraints(primitiveHandleType.resolvedType(), { type: primitiveConnectionType, relaxed, direction }, options);
            }
            if (direction === 'writes' || direction === 'reads writes' || direction === '`provides') {
                // the canReadSubset of the handle represents the maximal type that can be read from the
                // handle, so we need to intersect out any type that is more specific than the maximal type
                // that could be written.
                if (!primitiveHandleType.variable.maybeMergeCanReadSubset(primitiveConnectionType.canWriteSuperset)) {
                    return false;
                }
            }
            if (!relaxed) {
                // Requirements for relaxed handle connections are not currently enforced.
                if (direction === 'reads' || direction === 'reads writes' || direction === '`consumes') {
                    // the canWriteSuperset of the handle represents the maximum lower-bound type that is read from the handle,
                    // so we need to union it with the type that wants to be read here.
                    if (!primitiveHandleType.variable.maybeMergeCanWriteSuperset(primitiveConnectionType.canReadSubset)) {
                        return false;
                    }
                }
            }
        }
        else {
            if (primitiveConnectionType.tag !== primitiveHandleType.tag) {
                return false;
            }
            if (direction === 'writes' || direction === 'reads writes') {
                if (!type_checker_TypeChecker._writeConstraintsApply(primitiveHandleType, primitiveConnectionType)) {
                    return false;
                }
            }
            if (!relaxed) {
                // Requirements for relaxed handle connections are not currently enforced.
                if (direction === 'reads' || direction === 'reads writes') {
                    if (!type_checker_TypeChecker._readConstraintsApply(primitiveHandleType, primitiveConnectionType)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    static _writeConstraintsApply(handleType, connectionType) {
        // this connection wants to write to this handle. If the written type is
        // more specific than the canReadSubset then it isn't violating the maximal type
        // that can be read.
        const writtenType = connectionType.canWriteSuperset;
        if (writtenType == null || handleType.canReadSubset == null) {
            return true;
        }
        if (writtenType.isAtLeastAsSpecificAs(handleType.canReadSubset)) {
            return true;
        }
        return false;
    }
    static _readConstraintsApply(handleType, connectionType) {
        // this connection wants to read from this handle. If the read type
        // is less specific than the canWriteSuperset, then it isn't violating
        // the maximum lower-bound read type.
        const readType = connectionType.canReadSubset;
        if (readType == null || handleType.canWriteSuperset == null) {
            return true;
        }
        if (handleType.canWriteSuperset.isAtLeastAsSpecificAs(readType)) {
            return true;
        }
        return false;
    }
    // Compare two types to see if they could be potentially resolved (in the absence of other
    // information). This is used as a filter when selecting compatible handles or checking
    // validity of recipes. This function returning true never implies that full type resolution
    // will succeed, but if the function returns false for a pair of types that are associated
    // then type resolution is guaranteed to fail.
    //
    // left, right: {type, direction, connection}
    static compareTypes(left, right) {
        const resolvedLeft = left.type.resolvedType();
        const resolvedRight = right.type.resolvedType();
        const [leftInnerTypes, rightInnerTypes] = type_Type.tryUnwrapMulti(resolvedLeft, resolvedRight);
        if (rightInnerTypes !== null) {
            if (leftInnerTypes.length !== rightInnerTypes.length)
                return false;
            for (let i = 0; i < leftInnerTypes.length; i++) {
                if (!this.compareTypes({ type: leftInnerTypes[i], direction: left.direction, connection: left.connection }, { type: rightInnerTypes[i], direction: right.direction, connection: right.connection })) {
                    return false;
                }
            }
            return true;
        }
        const [leftType, rightType] = type_Type.unwrapPair(resolvedLeft, resolvedRight);
        // a variable is compatible with a set only if it is unconstrained.
        if (leftType instanceof type_TypeVariable && rightType.isTypeContainer()) {
            return !(leftType.variable.canReadSubset || leftType.variable.canWriteSuperset);
        }
        if (rightType instanceof type_TypeVariable && leftType.isTypeContainer()) {
            return !(rightType.variable.canReadSubset || rightType.variable.canWriteSuperset);
        }
        if (leftType instanceof type_TypeVariable || rightType instanceof type_TypeVariable) {
            // TODO: everything should use this, eventually. Need to implement the
            // right functionality in Interfaces first, though.
            return type_Type.canMergeConstraints(leftType, rightType);
        }
        if ((leftType === undefined) !== (rightType === undefined)) {
            return false;
        }
        if (leftType === rightType) {
            return true;
        }
        if (leftType.tag !== rightType.tag) {
            return false;
        }
        if (leftType instanceof type_SlotType) {
            return true;
        }
        // TODO: we need a generic way to evaluate type compatibility
        //       interfaces + entities + etc
        if (leftType instanceof type_InterfaceType && rightType instanceof type_InterfaceType) {
            if (leftType.interfaceInfo.equals(rightType.interfaceInfo)) {
                return true;
            }
        }
        if (!(leftType instanceof type_EntityType) || !(rightType instanceof type_EntityType)) {
            return false;
        }
        const leftIsSub = leftType.entitySchema.isAtLeastAsSpecificAs(rightType.entitySchema);
        const leftIsSuper = rightType.entitySchema.isAtLeastAsSpecificAs(leftType.entitySchema);
        if (leftIsSuper && leftIsSub) {
            return true;
        }
        if (!leftIsSuper && !leftIsSub) {
            return false;
        }
        const [superclass, subclass] = leftIsSuper ? [left, right] : [right, left];
        // treat handle types as if they were 'reads writes' connections. Note that this
        // guarantees that the handle's type will be preserved, and that the fact
        // that the type comes from a handle rather than a connection will also
        // be preserved.
        const superDirection = superclass.direction || (superclass.connection ? superclass.connection.direction : 'reads writes');
        const subDirection = subclass.direction || (subclass.connection ? subclass.connection.direction : 'reads writes');
        if (superDirection === 'reads') {
            return true;
        }
        if (subDirection === 'writes') {
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=type-checker.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/arcs-types/enums.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// String-based enums.
// TODO: convert to actual enums so that they can be iterated over.


//# sourceMappingURL=enums.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/arcs-types/check.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


class Check {
    constructor(target, fieldPath, expression) {
        this.target = target;
        this.fieldPath = fieldPath;
        this.expression = expression;
    }
    toManifestString() {
        let targetString = this.targetString;
        if (this.target.discriminator === 'CSCS') {
            // CSCS => slot. For slots we have to add the "data" keyword after the
            // slot name.
            targetString += ' data';
        }
        return `check ${targetString} ${this.expression.toManifestString()}`;
    }
    get targetString() {
        if (this.target.discriminator === 'HCS') {
            return [this.target.name, ...this.fieldPath].join('.');
        }
        else {
            return this.target.name;
        }
    }
}
/** A boolean expression inside a trust check. */
class CheckBooleanExpression {
    constructor(type, children) {
        this.type = type;
        this.children = children;
    }
    /**
     * @inheritdoc
     * @param requireParens Indicates whether to enclose the expression inside parentheses. All nested boolean expressions must have parentheses,
     *     but a top-level expression doesn't need to.
     */
    toManifestString(requireParens = false) {
        const str = this.children.map(child => child.toManifestString(/* requireParens= */ true)).join(` ${this.type} `);
        return requireParens ? `(${str})` : str;
    }
}
/** A check condition of the form 'check x is <tag>'. */
class check_CheckHasTag {
    constructor(tag, isNot) {
        this.tag = tag;
        this.isNot = isNot;
        this.type = CheckType.HasTag;
    }
    static fromASTNode(astNode) {
        return new check_CheckHasTag(astNode.tag, astNode.isNot);
    }
    toManifestString() {
        return `is ${this.isNot ? 'not ' : ''}${this.tag}`;
    }
}
/** A check condition of the form 'check x is from handle <handle>'. */
class check_CheckIsFromHandle {
    constructor(parentHandle, isNot) {
        this.parentHandle = parentHandle;
        this.isNot = isNot;
        this.type = CheckType.IsFromHandle;
    }
    static fromASTNode(astNode, handleConnectionMap) {
        const parentHandle = handleConnectionMap.get(astNode.parentHandle);
        if (!parentHandle) {
            throw new Error(`Unknown "check is from handle" handle name: ${astNode.parentHandle}.`);
        }
        return new check_CheckIsFromHandle(parentHandle, astNode.isNot);
    }
    toManifestString() {
        return `is ${this.isNot ? 'not ' : ''}from handle ${this.parentHandle.name}`;
    }
}
/** A check condition of the form 'check x is from output <output>'. */
class check_CheckIsFromOutput {
    constructor(output, isNot) {
        this.output = output;
        this.isNot = isNot;
        this.type = CheckType.IsFromOutput;
    }
    static fromASTNode(astNode, handleConnectionMap) {
        const output = handleConnectionMap.get(astNode.output);
        if (!output) {
            throw new Error(`Unknown "check is from output" output name: ${astNode.output}.`);
        }
        return new check_CheckIsFromOutput(output, astNode.isNot);
    }
    toManifestString() {
        return `is ${this.isNot ? 'not ' : ''}from output ${this.output.name}`;
    }
}
/** A check condition of the form 'check x is from store <store reference>'. */
class check_CheckIsFromStore {
    constructor(storeRef, isNot) {
        this.storeRef = storeRef;
        this.isNot = isNot;
        this.type = CheckType.IsFromStore;
    }
    static fromASTNode(astNode) {
        return new check_CheckIsFromStore({
            type: astNode.storeRef.type,
            store: astNode.storeRef.store,
        }, astNode.isNot);
    }
    toManifestString() {
        let store = this.storeRef.store;
        if (this.storeRef.type === 'id') {
            // Put the ID inside single-quotes.
            store = `'${store}'`;
        }
        return `is ${this.isNot ? 'not ' : ''}from store ${store}`;
    }
}
/** A check condition of the form 'check x (A => B)'. */
class check_CheckImplication {
    constructor(antecedent, consequent) {
        this.antecedent = antecedent;
        this.consequent = consequent;
        this.type = CheckType.Implication;
        this.isNot = false;
    }
    static fromASTNode(astNode, handleConnectionMap) {
        const antecedent = createCheckExpression(astNode.antecedent, handleConnectionMap);
        const consequent = createCheckExpression(astNode.consequent, handleConnectionMap);
        return new check_CheckImplication(antecedent, consequent);
    }
    toManifestString() {
        return `(${this.antecedent.toManifestString(/* requireParens= */ true)} => ${this.consequent.toManifestString(/* requireParens= */ true)})`;
    }
}
/** Converts the given AST node into a CheckCondition object. */
function createCheckCondition(astNode, handleConnectionMap) {
    switch (astNode.checkType) {
        case CheckType.HasTag:
            return check_CheckHasTag.fromASTNode(astNode);
        case CheckType.IsFromHandle:
            return check_CheckIsFromHandle.fromASTNode(astNode, handleConnectionMap);
        case CheckType.IsFromStore:
            return check_CheckIsFromStore.fromASTNode(astNode);
        case CheckType.IsFromOutput:
            return check_CheckIsFromOutput.fromASTNode(astNode, handleConnectionMap);
        case CheckType.Implication:
            return check_CheckImplication.fromASTNode(astNode, handleConnectionMap);
        default:
            throw new Error(`Unknown check type: ${JSON.stringify(astNode)}`);
    }
}
/** Converts the given AST node into a CheckExpression object. */
function createCheckExpression(astNode, handleConnectionMap) {
    if (astNode.kind === 'check-boolean-expression') {
        external_assert_default()(astNode.children.length >= 2, 'Boolean check expressions must have at least two children.');
        return new CheckBooleanExpression(astNode.operator, astNode.children.map(child => createCheckExpression(child, handleConnectionMap)));
    }
    else {
        return createCheckCondition(astNode, handleConnectionMap);
    }
}
/** Converts the given AST node into a Check object. */
function createCheck(checkTarget, astNode, handleConnectionMap) {
    const expression = createCheckExpression(astNode.expression, handleConnectionMap);
    return new Check(checkTarget, astNode.target.fieldPath, expression);
}
//# sourceMappingURL=check.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/field-path.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * Resolves a field path against the given Type. Returns the Type referenced by
 * the field path if valid. Throws an exception if the field path is invalid.
 */
function resolveFieldPathType(fieldPath, type) {
    if (fieldPath.length === 0) {
        return type;
    }
    if (typeof type === 'string') {
        throw new FieldPathError(`Field path '${fieldPath.join('.')}' could not be resolved because the target type is a primitive: '${type}'.`);
    }
    if (type.isTupleType()) {
        return resolveForTuple(fieldPath, type);
    }
    else if (type.isTypeContainer()) {
        return resolveFieldPathType(fieldPath, type.getContainedType());
    }
    const schema = type.getEntitySchema();
    if (!schema) {
        if (type_InterfaceInfo.isTypeVar(type)) {
            const innerType = type.canWriteSuperset || type.variable.resolution;
            if (innerType == null) {
                throw new FieldPathError(`Type variable ${type} does not contain field '${fieldPath[0]}'.`);
            }
            return resolveFieldPathType(fieldPath, type.canWriteSuperset);
        }
        else {
            throw new FieldPathError(`Expected type to contain an entity schema: ${type}.`);
        }
    }
    return resolveForSchema(fieldPath, schema);
}
/** Checks a field path for a particular field definition. */
function resolveForField(fieldPath, field) {
    switch (field.kind) {
        case 'kotlin-primitive':
        case 'schema-primitive': {
            // Field path must end here.
            if (fieldPath.length === 1) {
                return field.getType();
            }
            else {
                throw new FieldPathError(`Field path '${fieldPath.join('.')}' could not be resolved because '${fieldPath[1]}' is a primitive.`);
            }
        }
        case 'schema-collection':
        case 'schema-ordered-list': {
            // Check inner type.
            return resolveForField(fieldPath, field.getFieldType());
        }
        case 'schema-nested':
        case 'schema-reference': {
            // Check rest of field path against inner type.
            return resolveForSchema(fieldPath.slice(1), field.getEntityType().entitySchema);
        }
        default:
            throw new FieldPathError(`Unsupported field type: ${JSON.stringify(field)}`);
    }
}
/** Checks a field path against the given Schema. */
function resolveForSchema(fieldPath, schema) {
    if (fieldPath.length === 0) {
        return new type_EntityType(schema);
    }
    const fieldName = fieldPath[0];
    if (!(fieldName in schema.fields)) {
        throw new FieldPathError(`Schema '${schema.toInlineSchemaString()}' does not contain field '${fieldName}'.`);
    }
    const field = schema.fields[fieldName];
    return resolveForField(fieldPath, field);
}
function resolveForTuple(fieldPath, tupleType) {
    if (fieldPath.length === 0) {
        return tupleType;
    }
    const first = fieldPath[0];
    const component = parseTupleAccessor(first);
    if (component >= tupleType.innerTypes.length) {
        throw new FieldPathError(`The ${first} tuple component was requested but tuple only has ${tupleType.innerTypes.length} components.`);
    }
    return resolveFieldPathType(fieldPath.slice(1), tupleType.innerTypes[component]);
}
const tupleAccessors = {
    'first': 0,
    'second': 1,
    'third': 2,
    'fourth': 3,
    'fifth': 4,
};
function parseTupleAccessor(field) {
    const result = tupleAccessors[field];
    if (result == null) {
        throw new FieldPathError(`Expected a tuple component accessor of the form 'first', 'second', etc., but found '${field}'.`);
    }
    return result;
}
class FieldPathError extends Error {
}
//# sourceMappingURL=field-path.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/arcs-types/claim.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


/**
 * A list of claims made by a particle on a specific handle (or on a field
 * inside a handle).
 */
class Claim {
    constructor(handle, fieldPath, claims) {
        this.handle = handle;
        this.fieldPath = fieldPath;
        this.claims = claims;
    }
    toManifestString() {
        const manifestStrings = this.claims.map(claim => claim.toManifestString());
        return `claim ${this.target} ${manifestStrings.join(' and ')}`;
    }
    get target() {
        return [this.handle.name, ...this.fieldPath].join('.');
    }
}
class claim_ClaimIsTag {
    constructor(isNot, tag) {
        this.isNot = isNot;
        this.tag = tag;
        this.type = ClaimType.IsTag;
    }
    static fromASTNode(astNode) {
        return new claim_ClaimIsTag(astNode.isNot, astNode.tag);
    }
    toManifestString() {
        return `is ${this.isNot ? 'not ' : ''}${this.tag}`;
    }
}
class claim_ClaimDerivesFrom {
    constructor(parentHandle, fieldPath) {
        this.parentHandle = parentHandle;
        this.fieldPath = fieldPath;
        this.type = ClaimType.DerivesFrom;
    }
    static fromASTNode(astNode, handleConnectionMap) {
        // Convert handle names into HandleConnectionSpec objects.
        const parentHandle = handleConnectionMap.get(astNode.parentHandle);
        if (!parentHandle) {
            throw new Error(`Unknown "derives from" handle name: ${parentHandle}.`);
        }
        resolveFieldPathType(astNode.fieldPath, parentHandle.type);
        return new claim_ClaimDerivesFrom(parentHandle, astNode.fieldPath);
    }
    get target() {
        return [this.parentHandle.name, ...this.fieldPath].join('.');
    }
    toManifestString() {
        return `derives from ${this.target}`;
    }
}
function createClaim(handle, astNode, handleConnectionMap) {
    const claims = astNode.expression.map(claimNode => {
        switch (claimNode.claimType) {
            case ClaimType.IsTag:
                return claim_ClaimIsTag.fromASTNode(claimNode);
            case ClaimType.DerivesFrom:
                return claim_ClaimDerivesFrom.fromASTNode(claimNode, handleConnectionMap);
            default:
                throw new Error('Unknown claim type.');
        }
    });
    return new Claim(handle, astNode.fieldPath, claims);
}
//# sourceMappingURL=claim.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/arcs-types/particle-spec.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */









function asType(t) {
    return (t instanceof type_Type) ? t : type_Type.fromLiteral(t);
}
function asTypeLiteral(t) {
    return (t instanceof type_Type) ? t.toLiteral() : t;
}
function isRoot({ name, tags, id, type, fate }) {
    const rootNames = [
        'root',
        'toproot',
        'modal'
    ];
    if ((fate && fate !== '`slot') || (type && !type.slandleType())) {
        // If this is a handle that is not a Slandle, it cannot be a root slot.
        return false;
    }
    // Checks that, if the id exists, it starts with the root id prefx.
    const prefix = 'rootslotid-';
    if (id && id.lastIndexOf(prefix, 0) === 0) {
        const rootName = id.substr(prefix.length);
        if (rootNames.includes(rootName)) {
            return true;
        }
    }
    return rootNames.includes(name) || tags.some(tag => rootNames.includes(tag));
}
class particle_spec_HandleConnectionSpec {
    constructor(rawData, typeVarMap) {
        this.parentConnection = null;
        this.discriminator = 'HCS';
        this.rawData = rawData;
        this.direction = rawData.direction;
        this.relaxed = rawData.relaxed;
        this.name = rawData.name;
        this.type = asType(rawData.type).mergeTypeVariablesByName(typeVarMap);
        this.isOptional = rawData.isOptional;
        this.tags = rawData.tags || [];
        this.dependentConnections = [];
        this.annotations = rawData.annotations || [];
        this.expression = rawData.expression;
    }
    instantiateDependentConnections(particle, typeVarMap) {
        for (const dependentArg of this.rawData.dependentConnections) {
            const dependentConnection = particle.createConnection(dependentArg, typeVarMap);
            dependentConnection.parentConnection = this;
            this.dependentConnections.push(dependentConnection);
        }
    }
    toSlotConnectionSpec() {
        // TODO: Remove in SLANDLESv2
        const slotType = this.type.slandleType();
        if (!slotType) {
            return undefined;
        }
        const isSet = this.type.isCollectionType();
        const slotInfo = slotType.getSlot();
        return {
            discriminator: 'CSCS',
            name: this.name,
            isOptional: this.isOptional,
            direction: this.direction,
            tags: this.tags,
            dependentConnections: this.dependentConnections.map(conn => conn.toSlotConnectionSpec()),
            // Fakes
            isRequired: !this.isOptional,
            isSet,
            type: slotType,
            handles: slotInfo.handle ? [slotInfo.handle] : [],
            formFactor: slotInfo.formFactor,
            provideSlotConnections: this.dependentConnections.map(conn => conn.toSlotConnectionSpec()),
        };
    }
    get isInput() {
        // TODO: we probably don't really want host to be here.
        // TODO: do we want to consider any here?
        return this.direction === 'reads' || this.direction === 'reads writes' || this.direction === 'hosts';
    }
    get isOutput() {
        // TODO: do we want to consider any here?
        return this.direction === 'writes' || this.direction === 'reads writes';
    }
    isCompatibleType(type) {
        return type_checker_TypeChecker.compareTypes({ type }, { type: this.type, direction: this.direction });
    }
    get annotations() { return this._annotations; }
    set annotations(annotations) {
        annotations.every(a => external_assert_default()(a.isValidForTarget('HandleConnection'), `Annotation '${a.name}' is invalid for HandleConnection`));
        this._annotations = annotations;
    }
    getAnnotation(name) {
        const annotations = this.findAnnotations(name);
        external_assert_default()(annotations.length <= 1, `Multiple annotations found for '${name}'. Use findAnnotations instead.`);
        return annotations.length === 0 ? null : annotations[0];
    }
    findAnnotations(name) {
        return this.annotations.filter(a => a.name === name);
    }
}
class particle_spec_ConsumeSlotConnectionSpec {
    constructor(slotModel) {
        this.discriminator = 'CSCS';
        this.name = slotModel.name;
        this.isRequired = slotModel.isRequired || false;
        this.isSet = slotModel.isSet || false;
        this.tags = slotModel.tags || [];
        this.formFactor = slotModel.formFactor; // TODO: deprecate form factors?
        this.handles = slotModel.handles || [];
        this.provideSlotConnections = [];
        if (!slotModel.provideSlotConnections) {
            return;
        }
        slotModel.provideSlotConnections.forEach(ps => {
            this.provideSlotConnections.push(new ProvideSlotConnectionSpec(ps));
        });
    }
    // Getters to 'fake' being a Handle.
    get isOptional() { return !this.isRequired; }
    get direction() { return '`consumes'; }
    get type() {
        //TODO(jopra): FIXME make the null handle optional.
        const slotT = type_SlotType.make(this.formFactor, null);
        if (this.isSet) {
            return slotT.collectionOf();
        }
        return slotT;
    }
    get dependentConnections() { return this.provideSlotConnections; }
}
class ProvideSlotConnectionSpec extends particle_spec_ConsumeSlotConnectionSpec {
    constructor(slotModel) {
        super(slotModel);
        this.check = slotModel.check;
    }
}
class particle_spec_ParticleSpec {
    constructor(model, options) {
        this._annotations = [];
        this.model = model;
        this.name = model.name;
        this.verbs = model.verbs;
        const typeVarMap = new Map();
        this.handleConnectionMap = new Map();
        model.args.forEach(arg => this.createConnection(arg, typeVarMap));
        // initialize descriptions patterns.
        model.description = model.description || {};
        this.validateDescription(model.description);
        this.pattern = model.description['pattern'];
        this.handleConnectionMap.forEach((connectionSpec, name) => {
            connectionSpec.pattern = model.description[name];
        });
        // Override handle types with ones provided from the override map. Type
        // variables with resolutions don't survive the cloning process, so they can
        // be added in here.
        if (options && options.handleTypeOverrides) {
            options.handleTypeOverrides.forEach((type, name) => {
                this.handleConnectionMap.get(name).type = type;
            });
        }
        this.external = model.external;
        this.implFile = model.implFile;
        this.implBlobUrl = model.implBlobUrl;
        this.modality = model.modality ? modality_Modality.create(model.modality) : modality_Modality.all;
        this.slotConnections = new Map();
        if (model.slotConnections) {
            model.slotConnections.forEach(s => this.slotConnections.set(s.name, new particle_spec_ConsumeSlotConnectionSpec(s)));
        }
        // Verify provided slots use valid handle connection names.
        this.slotConnections.forEach(slot => {
            slot.provideSlotConnections.forEach(ps => {
                ps.handles.forEach(v => external_assert_default()(this.handleConnectionMap.has(v), 'Cannot provide slot for nonexistent handle constraint ' + v));
            });
        });
        this.trustClaims = this.validateTrustClaims(model.trustClaims);
        this.trustChecks = this.validateTrustChecks(model.trustChecks);
        this.annotations = model.annotations || [];
    }
    createConnection(arg, typeVarMap) {
        const connection = new particle_spec_HandleConnectionSpec(arg, typeVarMap);
        if (this.handleConnectionMap.get(connection.name)) {
            throw new Error(`Particle Spec ${this.name} already has a handle connection named "${connection.name}".`);
        }
        this.handleConnectionMap.set(connection.name, connection);
        connection.instantiateDependentConnections(this, typeVarMap);
        return connection;
    }
    get handleConnections() {
        return this.connections;
    }
    get connections() {
        return [...this.handleConnectionMap.values()];
    }
    get inputs() {
        return this.connections.filter(a => a.isInput);
    }
    get outputs() {
        return this.connections.filter(a => a.isOutput);
    }
    get manifestNamespace() {
        return this.model.manifestNamespace;
    }
    isInput(param) {
        const connection = this.handleConnectionMap.get(param);
        return connection && connection.isInput;
    }
    isOutput(param) {
        const connection = this.handleConnectionMap.get(param);
        return connection && connection.isOutput;
    }
    getConnectionByName(name) {
        return this.handleConnectionMap.get(name);
    }
    getSlotSpec(slotName) {
        return this.slotConnections.get(slotName);
    }
    getSlandleSpec(slotName) {
        const slot = this.slotConnections.get(slotName);
        if (slot)
            return slot;
        const handleConn = this.handleConnectionMap.get(slotName);
        return handleConn.toSlotConnectionSpec();
    }
    slandleConnectionNames() {
        const slandleNames = this.handleConnections.filter(conn => conn.toSlotConnectionSpec()).map(conn => conn.name);
        return [...this.slotConnections.keys(), ...slandleNames];
    }
    slotConnectionNames() {
        return [...this.slotConnections.keys()];
    }
    /**
     * Returns true if there's a consume or provide connection named @name.
     */
    hasSlotConnectionName(name) {
        if (this.slotConnections.has(name)) {
            return true;
        }
        return [...this.slotConnections.values()].map(connection => {
            return connection.provideSlotConnections.map(pc => pc.name).includes(name);
        }).reduce((a, b) => a || b);
    }
    get primaryVerb() {
        return (this.verbs.length > 0) ? this.verbs[0] : undefined;
    }
    get annotations() { return this._annotations; }
    set annotations(annotations) {
        annotations.every(a => external_assert_default()(a.isValidForTarget('Particle'), `Annotation '${a.name}' is invalid for Particle`));
        this._annotations = annotations;
    }
    getAnnotation(name) {
        const annotations = this.findAnnotations(name);
        external_assert_default()(annotations.length <= 1, `Multiple annotations found for '${name}'. Use findAnnotations instead.`);
        return annotations.length === 0 ? null : annotations[0];
    }
    findAnnotations(name) {
        return this.annotations.filter(a => a.name === name);
    }
    get dataflowType() {
        const isolated = !!this.getAnnotation('isolated');
        const ingress = !!this.getAnnotation('ingress');
        const egress = !!this.getAnnotation('egress');
        return new particle_spec_ParticleDataflowType({ isolated, ingress, egress });
    }
    /**
     * Returns the egress type of this particle, according to the `@egress`
     * annotation on it. Returns null if no egress type was supplied, or if the
     * particle is not an egress particle.
     */
    get egressType() {
        const egressAnnotation = this.getAnnotation('egress');
        if (!egressAnnotation) {
            return null;
        }
        const egressType = egressAnnotation.params['type'];
        return egressType == null ? null : egressType;
    }
    isCompatible(modality) {
        return this.slandleConnectionNames().length === 0 || this.modality.intersection(modality).isResolved();
    }
    setImplBlobUrl(url) {
        this.model.implBlobUrl = this.implBlobUrl = url;
    }
    toLiteral() {
        const { args, name, verbs, description, external, implFile, implBlobUrl, modality, slotConnections, trustClaims, trustChecks, annotations, manifestNamespace } = this.model;
        const connectionToLiteral = ({ type, direction, relaxed, name, isOptional, dependentConnections, annotations, expression }) => ({ type: asTypeLiteral(type), direction, relaxed, name, isOptional, dependentConnections: dependentConnections.map(connectionToLiteral), annotations: annotations || [], expression });
        const argsLiteral = args.map(a => connectionToLiteral(a));
        return { args: argsLiteral, name, verbs, description, external, implFile, implBlobUrl, modality, slotConnections, trustClaims, trustChecks, annotations, manifestNamespace };
    }
    static fromLiteral(literal, options) {
        let { args, name, verbs, description, external, implFile, implBlobUrl, modality, slotConnections, trustClaims, trustChecks, annotations, manifestNamespace } = literal;
        const connectionFromLiteral = ({ type, direction, relaxed, name, isOptional, dependentConnections, expression }) => ({ type: asType(type), direction, relaxed, name, isOptional, dependentConnections: dependentConnections ? dependentConnections.map(connectionFromLiteral) : [], annotations: /*annotations ||*/ [], expression });
        args = args.map(connectionFromLiteral);
        return new particle_spec_ParticleSpec({ args, name, verbs: verbs || [], description, external, implFile, implBlobUrl, modality, slotConnections, trustClaims, trustChecks, annotations, manifestNamespace }, options);
    }
    // Note: this method shouldn't be called directly.
    clone(options) {
        return particle_spec_ParticleSpec.fromLiteral(this.toLiteral(), options);
    }
    // Note: this method shouldn't be called directly (only as part of particle copying).
    cloneWithResolutions(variableMap) {
        const handleTypeOverrides = new Map();
        this.handleConnectionMap.forEach((conn, name) => {
            handleTypeOverrides.set(name, conn.type._cloneWithResolutions(variableMap));
        });
        return this.clone({ handleTypeOverrides });
    }
    equals(other) {
        return JSON.stringify(this.toLiteral()) === JSON.stringify(other.toLiteral());
    }
    validateDescription(description) {
        Object.keys(description || []).forEach(d => {
            external_assert_default()(['kind', 'location', 'pattern'].includes(d) || this.handleConnectionMap.has(d), `Unexpected description for ${d}`);
        });
    }
    toInterface() {
        // TODO: wat do?
        external_assert_default()(!this.slotConnections.size, 'please implement slots toInterface');
        const handles = this.model.args.map(({ type, name, direction }) => ({ type: asType(type), name, direction }));
        const slots = [];
        return type_InterfaceType.make(this.name, handles, slots);
    }
    toManifestString(builder = new IndentingStringBuilder()) {
        for (const annotation of this.annotations) {
            builder.push(annotation.toString());
        }
        let verbs = '';
        if (this.verbs.length > 0) {
            verbs = ' ' + this.verbs.map(verb => `&${verb}`).join(' ');
        }
        let line = '';
        if (this.external) {
            line += 'external ';
        }
        line += `particle ${this.name}${verbs}`;
        if (this.implFile) {
            line += ` in '${this.implFile}'`;
        }
        builder.push(line);
        const indentedBuilder = builder.withIndent();
        const writeConnection = (connection, builder) => {
            const dir = connection.direction === 'any' ? '' : `${preSlandlesDirectionToDirection(connection.direction, connection.isOptional)}`;
            const subresults = [
                `${connection.name}:`,
                dir,
                connection.relaxed ? RELAXATION_KEYWORD : '',
                connection.type.toString(),
                ...connection.annotations.map(a => a.toString()),
                ...connection.tags.map((tag) => `#${tag}`)
            ];
            builder.push(subresults.filter(s => s !== '').join(' '));
            for (const dependent of connection.dependentConnections) {
                writeConnection(dependent, builder.withIndent());
            }
        };
        for (const connection of this.handleConnections) {
            if (connection.parentConnection) {
                continue;
            }
            writeConnection(connection, indentedBuilder);
        }
        indentedBuilder.push(...this.trustClaims.map(claim => claim.toManifestString()), ...this.trustChecks.map(check => check.toManifestString()));
        this.modality.names.forEach(a => indentedBuilder.push(`modality ${a}`));
        const slotToString = (s, direction, builder) => {
            const tokens = [];
            tokens.push(`${s.name}:`);
            tokens.push(`${direction}${s.isRequired ? '' : '?'}`);
            const fieldSet = [];
            // TODO(jopra): Move the formFactor and handle to the slot type information.
            if (s.formFactor) {
                fieldSet.push(`formFactor: ${s.formFactor}`);
            }
            for (const handle of s.handles) {
                fieldSet.push(`handle: ${handle}`);
            }
            const fields = (fieldSet.length !== 0) ? ` {${fieldSet.join(', ')}}` : '';
            if (s.isSet) {
                tokens.push(`[Slot${fields}]`);
            }
            else {
                tokens.push(`Slot${fields}`);
            }
            if (s.tags.length > 0) {
                tokens.push(s.tags.map(a => `#${a}`).join(' '));
            }
            builder.push(`${tokens.join(' ')}`);
            if (s.provideSlotConnections) {
                // Provided slots.
                s.provideSlotConnections.forEach(p => slotToString(p, 'provides', builder.withIndent()));
            }
        };
        this.slotConnections.forEach(s => slotToString(s, 'consumes', indentedBuilder));
        // Description
        if (this.pattern) {
            indentedBuilder.push(`description \`${this.pattern}\``);
            indentedBuilder.withIndent(indentedBuilder => {
                this.handleConnectionMap.forEach(cs => {
                    if (cs.pattern) {
                        indentedBuilder.push(`${cs.name} \`${cs.pattern}\``);
                    }
                });
            });
        }
        return builder.toString();
    }
    toString() {
        return this.toManifestString();
    }
    validateTrustClaims(statements) {
        const results = [];
        if (statements) {
            statements.forEach(statement => {
                const target = [statement.handle, ...statement.fieldPath].join('.');
                const handle = this.handleConnectionMap.get(statement.handle);
                if (!handle) {
                    throw new Error(`Can't make a claim on unknown handle ${statement.handle}.`);
                }
                if (!handle.isOutput) {
                    throw new Error(`Can't make a claim on handle ${statement.handle} (not an output handle).`);
                }
                resolveFieldPathType(statement.fieldPath, handle.type);
                if (!handle.claims) {
                    handle.claims = [];
                }
                else if (handle.claims.some(claim => claim.target === target)) {
                    throw new Error(`Can't make multiple claims on the same target (${target}).`);
                }
                const particleClaim = createClaim(handle, statement, this.handleConnectionMap);
                handle.claims.push(particleClaim);
                results.push(particleClaim);
            });
        }
        return results;
    }
    validateTrustChecks(checks) {
        const results = [];
        if (checks) {
            const providedSlotNames = this.getProvidedSlotsByName();
            checks.forEach(check => {
                switch (check.target.targetType) {
                    case 'handle': {
                        const handleName = check.target.name;
                        const handle = this.handleConnectionMap.get(handleName);
                        if (!handle) {
                            throw new Error(`Can't make a check on unknown handle ${handleName}.`);
                        }
                        if (handle.direction === '`consumes' || handle.direction === '`provides') {
                            // Do slandles versions of slots checks and claims.
                            if (handle.direction === '`consumes') {
                                throw new Error(`Can't make a check on handle ${handleName}. Can only make checks on input and provided handles.`);
                            }
                        }
                        else if (!handle.isInput) {
                            throw new Error(`Can't make a check on handle ${handleName} with direction ${handle.direction} (not an input handle).`);
                        }
                        resolveFieldPathType(check.target.fieldPath, handle.type);
                        const checkObject = createCheck(handle, check, this.handleConnectionMap);
                        if (!handle.checks) {
                            handle.checks = [];
                        }
                        else if (handle.checks.some(c => c.targetString === checkObject.targetString)) {
                            throw new Error(`Can't make multiple checks on the same target (${checkObject.targetString}).`);
                        }
                        handle.checks.push(checkObject);
                        results.push(checkObject);
                        break;
                    }
                    case 'slot': {
                        const slotName = check.target.name;
                        const slotSpec = providedSlotNames.get(slotName);
                        if (!slotSpec) {
                            if (this.slotConnectionNames().includes(slotName)) {
                                throw new Error(`Slot ${slotName} is a consumed slot. Can only make checks on provided slots.`);
                            }
                            else {
                                throw new Error(`Can't make a check on unknown slot ${slotName}.`);
                            }
                        }
                        slotSpec.check = createCheck(slotSpec, check, this.handleConnectionMap);
                        results.push(slotSpec.check);
                        break;
                    }
                    default:
                        throw new Error('Unknown check target type.');
                }
            });
        }
        return results;
    }
    getProvidedSlotsByName() {
        const result = new Map();
        for (const consumeConnection of this.slotConnections.values()) {
            for (const provideConnection of consumeConnection.provideSlotConnections) {
                const name = provideConnection.name;
                if (result.has(name)) {
                    throw new Error(`Another slot with name '${name}' has already been provided by this particle.`);
                }
                result.set(name, provideConnection);
            }
        }
        return result;
    }
}
class particle_spec_ParticleDataflowType {
    constructor({ isolated, ingress, egress }) {
        external_assert_default()(!(isolated && ingress), 'Particle cannot be tagged with both @isolated and @ingress.');
        external_assert_default()(!(isolated && egress), 'Particle cannot be tagged with both @isolated and @egress.');
        if (!isolated && !ingress && !egress) {
            // Particles without any annotations are considered ingress and egress by
            // default.
            ingress = true;
            egress = true;
        }
        this.isolated = isolated;
        this.ingress = ingress;
        this.egress = egress;
    }
}
particle_spec_ParticleDataflowType.ISOLATED = new particle_spec_ParticleDataflowType({ isolated: true, ingress: false, egress: false });
particle_spec_ParticleDataflowType.INGRESS = new particle_spec_ParticleDataflowType({ isolated: false, ingress: true, egress: false });
particle_spec_ParticleDataflowType.EGRESS = new particle_spec_ParticleDataflowType({ isolated: false, ingress: false, egress: true });
particle_spec_ParticleDataflowType.INGRESS_AND_EGRESS = new particle_spec_ParticleDataflowType({ isolated: false, ingress: true, egress: true });
//# sourceMappingURL=particle-spec.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/description-formatter.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */



class description_formatter_DescriptionFormatter {
    constructor(particleDescriptions = [], storeDescById = {}) {
        this.particleDescriptions = particleDescriptions;
        this.storeDescById = storeDescById;
        this.seenHandles = new Set();
        this.seenParticles = new Set();
        this.excludeValues = false;
    }
    getDescription(recipe) {
        if (recipe.patterns.length > 0) {
            let recipePatterns = [];
            for (const pattern of recipe.patterns) {
                recipePatterns.push(this.patternToSuggestion(pattern, { _recipe: recipe }));
            }
            recipePatterns = recipePatterns.filter(pattern => Boolean(pattern));
            if (recipePatterns.length > 0) {
                // TODO(mmandlis): Sort the descriptions.
                return this._capitalizeAndPunctuate(this._joinDescriptions(recipePatterns));
            }
        }
        // Choose particles, sort them by rank and generate suggestions.
        const particlesSet = new Set(recipe.particles);
        let selectedDescriptions = this.particleDescriptions
            .filter(desc => (particlesSet.has(desc._particle) && this._isSelectedDescription(desc)));
        // Prefer particles that render UI, if any.
        if (selectedDescriptions.find(desc => (desc._particle.spec.slotConnections.size > 0))) {
            selectedDescriptions = selectedDescriptions.filter(desc => (desc._particle.spec.slotConnections.size > 0));
        }
        selectedDescriptions = selectedDescriptions.sort(description_formatter_DescriptionFormatter.sort);
        if (selectedDescriptions.length > 0) {
            return this._combineSelectedDescriptions(selectedDescriptions);
        }
        return undefined;
    }
    _isSelectedDescription(desc) {
        return !!desc.pattern;
    }
    getHandleDescription(recipeHandle) {
        const handleConnection = this._selectHandleConnection(recipeHandle) || recipeHandle.connections[0];
        return this._formatDescription(handleConnection);
    }
    // TODO(mmandlis): the override of this function in subclasses also overrides the output. We'll need to unify
    // this into an output type hierarchy before we can assign a useful type to the output of this function.
    // tslint:disable-next-line: no-any
    _combineSelectedDescriptions(selectedDescriptions, options = {}) {
        const suggestions = [];
        selectedDescriptions.forEach(particle => {
            if (!this.seenParticles.has(particle._particle)) {
                suggestions.push(this.patternToSuggestion(particle.pattern, particle));
            }
        });
        const jointDescription = this._joinDescriptions(suggestions);
        if (jointDescription) {
            if (options.skipFormatting) {
                return jointDescription;
            }
            else {
                return this._capitalizeAndPunctuate(jointDescription);
            }
        }
        return undefined;
    }
    // TODO(mmandlis): the override of this function in subclasses also overrides the output. We'll need to unify
    // this into an output type hierarchy before we can assign a useful type to the output of this function.
    // tslint:disable-next-line: no-any
    _joinDescriptions(strings) {
        const nonEmptyStrings = strings.filter(str => str);
        const count = nonEmptyStrings.length;
        if (count > 0) {
            // Combine descriptions into a sentence:
            // "A."
            // "A and b."
            // "A, b, ..., and z." (Oxford comma ftw)
            const delim = ['', '', ' and ', ', and '][Math.min(3, count)];
            const lastString = nonEmptyStrings.pop();
            return `${nonEmptyStrings.join(', ')}${delim}${lastString}`;
        }
        return undefined;
    }
    _joinTokens(tokens) {
        return tokens.join('');
    }
    _capitalizeAndPunctuate(sentence) {
        external_assert_default()(sentence);
        // "Capitalize, punctuate." (if the sentence doesn't end with a punctuation character).
        const last = sentence.length - 1;
        return `${sentence[0].toUpperCase()}${sentence.slice(1, last)}${sentence[last]}${sentence[last].match(/[a-z0-9()' >\]]/i) ? '.' : ''}`;
    }
    patternToSuggestion(pattern, particleDescription) {
        const tokens = this._initTokens(pattern, particleDescription);
        const tokenResults = tokens.map(token => this.tokenToString(token));
        if (tokenResults.filter(res => res == undefined).length === 0) {
            return this._joinTokens(tokenResults);
        }
        return undefined;
    }
    _initTokens(pattern, particleDescription) {
        pattern = pattern.replace(/</g, '&lt;');
        let results = [];
        while (pattern.length > 0) {
            const tokens = pattern.match(description_formatter_DescriptionFormatter.tokensRegex);
            let firstToken;
            let tokenIndex;
            if (tokens) {
                firstToken = tokens[0];
                tokenIndex = pattern.indexOf(firstToken);
            }
            else {
                firstToken = '';
                tokenIndex = pattern.length;
            }
            external_assert_default()(tokenIndex >= 0);
            const nextToken = pattern.substring(0, tokenIndex);
            if (nextToken.length > 0) {
                results.push({ text: nextToken });
            }
            if (firstToken.length > 0) {
                results = results.concat(this._initSubTokens(firstToken, particleDescription));
            }
            pattern = pattern.substring(tokenIndex + firstToken.length);
        }
        return results;
    }
    _initSubTokens(pattern, particleDescription) {
        const valueTokens = pattern.match(description_formatter_DescriptionFormatter.tokensInnerRegex);
        const handleNames = valueTokens[1].split('.');
        const extra = valueTokens.length === 3 ? valueTokens[2] : undefined;
        // Fetch the particle description by name from the value token - if it wasn't passed, this is a recipe description.
        if (!particleDescription._particle) {
            const particleName = handleNames.shift();
            if (particleName[0] !== particleName[0].toUpperCase()) {
                console.warn(`Invalid particle name '${particleName}' - must start with a capital letter.`);
                return [];
            }
            const particleDescriptions = this.particleDescriptions.filter(desc => {
                return desc._particle.name === particleName
                    // The particle description is from the current recipe.
                    && particleDescription._recipe.particles.find(p => p === desc._particle);
            });
            if (particleDescriptions.length === 0) {
                console.warn(`Cannot find particles with name ${particleName}.`);
                return [];
            }
            // Note: when an arc's active recipes contains several recipes, the last recipe's description
            // is used as the arc's description. If this last recipe's description has a description pattern
            // that references a particle that is also used in one of the previous recipes,
            // there will be a duplicate particle-description.
            particleDescription = particleDescriptions[particleDescriptions.length - 1];
        }
        const particle = particleDescription._particle;
        if (handleNames.length === 0) {
            // return a particle token
            return [{
                    particleName: particle.spec.name,
                    particleDescription
                }];
        }
        const handleConn = particle.connections[handleNames[0]];
        if (handleConn) { // handle connection
            external_assert_default()(handleConn.handle, 'Missing handle???');
            return [{
                    fullName: valueTokens[0],
                    handleName: handleConn.name,
                    storeId: handleConn.handle.id,
                    properties: handleNames.splice(1),
                    extra,
                    _handleConn: handleConn,
                    value: particleDescription._connections[handleConn.name].value
                }];
        }
        // slot connection
        if (handleNames.length !== 2) {
            if (handleNames.length === 1) {
                console.warn(`Unknown handle connection name '${handleNames[0]}'`);
            }
            else {
                console.warn(`Slot connections tokens must have exactly 2 names, found ${handleNames.length} in '${handleNames.join('.')}'`);
            }
            return [];
        }
        const providedSlotConn = particle.getSlotConnectionByName(handleNames[0]).providedSlots[handleNames[1]];
        external_assert_default()(providedSlotConn, `Could not find handle ${handleNames.join('.')}`);
        return [{
                fullName: valueTokens[0],
                consumeSlotName: handleNames[0],
                provideSlotName: handleNames[1],
                extra,
                _providedSlotConn: providedSlotConn
            }];
    }
    tokenToString(token) {
        if (token.text) {
            return token.text;
        }
        if (token.particleName) {
            return this._particleTokenToString(token);
        }
        if (token.handleName) {
            return this._handleTokenToString(token);
        }
        else if (token.consumeSlotName && token.provideSlotName) {
            return this._slotTokenToString(token);
        }
        throw new Error('no handle or slot name');
    }
    _particleTokenToString(token) {
        return this._combineSelectedDescriptions([token.particleDescription], { skipFormatting: true });
    }
    _handleTokenToString(token) {
        switch (token.extra) {
            case '_type_':
                return token._handleConn.type.toPrettyString().toLowerCase();
            case '_values_':
                return this._formatStoreValue(token.handleName, token.value);
            case '_name_':
                return this._formatDescription(token._handleConn);
            default: {
                external_assert_default()(!token.extra, `Unrecognized extra ${token.extra}`);
                // Transformation's hosted particle.
                if (token._handleConn.type instanceof type_InterfaceType) {
                    if (!token.value) {
                        return undefined;
                    }
                    external_assert_default()(token.value.interfaceValue, `Missing interface type value for '${token._handleConn.type}'.`);
                    const particleSpec = token.value.interfaceValue;
                    // TODO: call this.patternToSuggestion(...) to resolved expressions in the pattern template.
                    return particleSpec.pattern;
                }
                // singleton handle property.
                if (token.properties && token.properties.length > 0) {
                    return this._propertyTokenToString(token.handleName, token.value, token.properties);
                }
                // full handle description
                let description = this._formatDescriptionPattern(token._handleConn) ||
                    this._formatStoreDescription(token._handleConn);
                const storeValue = this._formatStoreValue(token.handleName, token.value);
                if (!description) {
                    // For singleton handle, if there is no real description (the type was used), use the plain value for description.
                    // TODO: should this look at type.getContainedType() (which includes references), or maybe just check for EntityType?
                    const storeType = token._handleConn.type;
                    if (storeValue && !this.excludeValues &&
                        !(storeType instanceof type_CollectionType) && !(storeType instanceof type_BigCollectionType)) {
                        return storeValue;
                    }
                }
                description = description || this._formatHandleType(token._handleConn);
                if (storeValue && !this.excludeValues && !this.seenHandles.has(token.storeId)) {
                    this.seenHandles.add(token.storeId);
                    return this._combineDescriptionAndValue(token, description, storeValue);
                }
                return description;
            }
        }
    }
    _combineDescriptionAndValue(token, description, storeValue) {
        if (description === storeValue) {
            return description;
        }
        return `${description} (${storeValue})`;
    }
    _slotTokenToString(token) {
        switch (token.extra) {
            case '_empty_':
                // TODO: also return false, if the consuming particles generate an empty description.
                return token._providedSlotConn.consumeConnections.length === 0;
            default:
                external_assert_default()(!token.extra, `Unrecognized slot extra ${token.extra}`);
        }
        const results = token._providedSlotConn.consumeConnections.map(consumeConn => {
            const particle = consumeConn.particle;
            const particleDescription = this.particleDescriptions.find(desc => desc._particle === particle);
            this.seenParticles.add(particle);
            return this.patternToSuggestion(particle.spec.pattern, particleDescription);
        });
        return this._joinDescriptions(results);
    }
    _propertyTokenToString(handleName, value, properties) {
        if (!value) {
            return '';
        }
        external_assert_default()(value.entityValue, `Cannot return property ${properties.join(',')} for non EntityType.`);
        // Use singleton value's property (eg. "09/15" for person's birthday)
        const valueVar = value.entityValue;
        if (value.entityValue) {
            let propertyValue = value.entityValue;
            for (const property of properties) {
                if (propertyValue) {
                    propertyValue = propertyValue[property];
                }
            }
            if (propertyValue) {
                return this._formatEntityProperty(handleName, properties, propertyValue);
            }
        }
    }
    _formatEntityProperty(handleName, properties, value) {
        return value;
    }
    _formatStoreValue(handleName, value) {
        if (value) {
            if (value.collectionValues) {
                return this._formatCollection(handleName, value.collectionValues);
            }
            if (value.bigCollectionValues) {
                return this._formatBigCollection(handleName, value.bigCollectionValues);
            }
            if (value.entityValue) {
                return this._formatSingleton(handleName, value);
            }
            throw new Error(`invalid store type for handle ${handleName}`);
        }
        return undefined;
    }
    _formatCollection(handleName, values) {
        if (values[0].name) {
            if (values.length > 2) {
                return `${values[0].name} plus ${values.length - 1} other items`;
            }
            return values.map(v => v.name).join(', ');
        }
        else {
            return `${values.length} items`;
        }
    }
    // TODO(mmandlis): the override of this function in subclasses also overrides the output. We'll need to unify
    // this into an output type hierarchy before we can assign a useful type to the output of this function.
    // tslint:disable-next-line: no-any
    _formatBigCollection(handleName, firstValue) {
        return `collection of items like ${firstValue.rawData.name}`;
    }
    _formatSingleton(handleName, value) {
        const entityValue = value.entityValue;
        if (value.valueDescription) {
            let valueDescription = value.valueDescription;
            let matches;
            while (matches = valueDescription.match(/\${([a-zA-Z0-9.]+)}/)) {
                valueDescription = valueDescription.replace(matches[0], entityValue[matches[1]]);
            }
            return valueDescription;
        }
        if (entityValue['name']) {
            return entityValue['name'];
        }
    }
    _formatDescription(handleConnection) {
        return this._formatDescriptionPattern(handleConnection) ||
            this._formatStoreDescription(handleConnection) ||
            this._formatHandleType(handleConnection);
    }
    _formatDescriptionPattern(handleConnection) {
        let chosenConnection = handleConnection;
        // For "out" connection, use its own description
        // For "in" connection, use description of the highest ranked out connection with description.
        if (!chosenConnection.spec.isOutput) {
            const otherConnection = this._selectHandleConnection(handleConnection.handle);
            if (otherConnection) {
                chosenConnection = otherConnection;
            }
        }
        const chosenParticleDescription = this.particleDescriptions.find(desc => desc._particle === chosenConnection.particle);
        const handleDescription = chosenParticleDescription ? chosenParticleDescription._connections[chosenConnection.name] : null;
        // Add description to result array.
        if (handleDescription && handleDescription.pattern) {
            // Add the connection spec's description pattern.
            return this.patternToSuggestion(handleDescription.pattern, chosenParticleDescription);
        }
        return undefined;
    }
    _formatStoreDescription(handleConn) {
        if (handleConn.handle) {
            if (!handleConn.handle.id) {
                return undefined;
            }
            const storeDescription = this.storeDescById[handleConn.handle.id];
            const handleType = this._formatHandleType(handleConn);
            // Use the handle description available in the arc (if it is different than type name).
            if (!!storeDescription && storeDescription !== handleType) {
                return storeDescription;
            }
        }
        return undefined;
    }
    _formatHandleType(handleConnection) {
        const type = handleConnection.handle && handleConnection.handle.type.isResolved() ? handleConnection.handle.type : handleConnection.type;
        return type.toPrettyString().toLowerCase();
    }
    _selectHandleConnection(recipeHandle) {
        const possibleConnections = recipeHandle.connections.filter(connection => {
            // Choose connections with patterns (manifest-based or dynamic).
            const connectionSpec = connection.spec;
            const particleDescription = this.particleDescriptions.find(desc => desc._particle === connection.particle);
            return !!connectionSpec.pattern ||
                (!!particleDescription && !!particleDescription._connections[connection.name].pattern);
        });
        possibleConnections.sort((c1, c2) => {
            const isOutput1 = c1.spec.isOutput;
            const isOutput2 = c2.spec.isOutput;
            if (isOutput1 !== isOutput2) {
                // Prefer output connections
                return isOutput1 ? -1 : 1;
            }
            const d1 = this.particleDescriptions.find(desc => desc._particle === c1.particle);
            const d2 = this.particleDescriptions.find(desc => desc._particle === c2.particle);
            // Sort by particle's rank in descending order.
            return d2._rank - d1._rank;
        });
        if (possibleConnections.length > 0) {
            return possibleConnections[0];
        }
    }
    static sort(p1, p2) {
        // Root slot comes first.
        const hasRoot1 = [...p1._particle.spec.slotConnections.values()].some(slotSpec => isRoot(slotSpec));
        const hasRoot2 = [...p2._particle.spec.slotConnections.values()].some(slotSpec => isRoot(slotSpec));
        if (hasRoot1 !== hasRoot2) {
            return hasRoot1 ? -1 : 1;
        }
        // Sort by rank
        if (p1._rank !== p2._rank) {
            return p2._rank - p1._rank;
        }
        // Sort by number of singleton slots.
        let p1Slots = 0;
        let p2Slots = 0;
        p1._particle.spec.slotConnections.forEach((slotSpec) => { if (!slotSpec.isSet)
            ++p1Slots; });
        p2._particle.spec.slotConnections.forEach((slotSpec) => { if (!slotSpec.isSet)
            ++p2Slots; });
        return p2Slots - p1Slots;
    }
}
description_formatter_DescriptionFormatter.tokensRegex = /\${[a-zA-Z0-9.]+}(?:\.[_a-zA-Z]+)?/g;
description_formatter_DescriptionFormatter.tokensInnerRegex = /\${([a-zA-Z0-9.]+)}(?:\.([_a-zA-Z]+))?/;
//# sourceMappingURL=description-formatter.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/sourcemapped-stacktrace-node.js
/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// This is only relevant in the web devtools, but we need to
// ensure that the stack trace is passed through on node
// so that system exceptions are plumbed properly.
const mapStackTrace = (x, f) => f([x]);
//# sourceMappingURL=sourcemapped-stacktrace-node.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/arc-exceptions.js
/** An exception that is to be propagated back to the host. */
class PropagatedException extends Error {
    constructor(cause, method, particleId, particleName) {
        super();
        this.cause = cause;
        this.method = method;
        this.particleId = particleId;
        this.particleName = particleName;
        this.stack += `\nCaused by: ${this.cause.stack}`;
    }
    toLiteral() {
        return {
            exceptionType: this.constructor.name,
            cause: {
                name: this.cause.name,
                message: this.cause.message,
                stack: this.cause.stack,
            },
            method: this.method,
            particleId: this.particleId,
            particleName: this.particleName,
            stack: this.stack,
        };
    }
    static fromLiteral(literal) {
        const cause = literal.cause;
        let exception;
        switch (literal.exceptionType) {
            case AuditException.name:
                exception = new AuditException(cause, literal.method, literal.particleId, literal.particleName);
                break;
            case SystemException.name:
                exception = new SystemException(cause, literal.method, literal.particleId, literal.particleName);
                break;
            case UserException.name:
                exception = new UserException(cause, literal.method, literal.particleId, literal.particleName);
                break;
            case PropagatedException.name:
                exception = new PropagatedException(cause, literal.method, literal.particleId, literal.particleName);
                break;
            default:
                throw new Error(`Unknown exception type: ${JSON.stringify(literal)}`);
        }
        exception.stack = literal.stack;
        return exception;
    }
}
/** An exception thrown in Arcs runtime code. */
class SystemException extends PropagatedException {
    get message() {
        const particleName = this.particleName ? this.particleName : this.particleId;
        return `SystemException: exception ${this.cause.name} raised when invoking system function ${this.method} on behalf of particle ${particleName}: ${this.cause.message}`;
    }
}
/** An exception thrown in the user particle code (as opposed to an error in the Arcs runtime). */
class UserException extends PropagatedException {
    get message() {
        const particleName = this.particleName ? this.particleName : this.particleId;
        return `UserException: exception ${this.cause.name} raised when invoking function ${this.method} on particle ${particleName}: ${this.cause.message}`;
    }
}
class AuditException extends PropagatedException {
    get message() {
        const particleName = this.particleName ? this.particleName : this.particleId;
        return `AuditException: exception ${this.cause.name} raised when invoking function ${this.method} on particle ${particleName}: ${this.cause.message}`;
    }
}
const systemHandlers = [];
function reportSystemException(arc, exception) {
    // TODO: handle reporting of system exceptions that have come from stores.
    // At the moment, a store reporting an exception does not supply the arc that the
    // exception belongs to.
    if (arc == null) {
        return;
    }
    for (const handler of systemHandlers) {
        handler(arc, exception);
    }
}
function reportGlobalException(arc, exception) {
    for (const handler of systemHandlers) {
        handler(arc, exception);
    }
}
function registerSystemExceptionHandler(handler) {
    if (!systemHandlers.includes(handler)) {
        systemHandlers.push(handler);
    }
}
function removeSystemExceptionHandler(handler) {
    const idx = systemHandlers.indexOf(handler);
    if (idx > -1) {
        systemHandlers.splice(idx, 1);
    }
}
const defaultSystemExceptionHandler = (arc, exception) => {
    if (exception instanceof PropagatedException) {
        if (exception.particleName && exception.method) {
            console.log(`Exception in particle '${exception.particleName}', method '${exception.method}'`);
        }
        else if (exception.particleName) {
            console.log(`Exception in particle '${exception.particleName}', unknown method`);
        }
        else if (exception.method) {
            console.log(`Exception in unknown particle, method '${exception.method}'`);
        }
        else if (exception.cause) {
            console.log(`Exception in unknown particle, cause '${exception.cause.stack}'`, exception.cause);
        }
        else {
            console.log(exception.message || exception);
        }
    }
    else {
        console.log(exception.message || exception);
    }
    arc.dispose();
};
registerSystemExceptionHandler(defaultSystemExceptionHandler);
//# sourceMappingURL=arc-exceptions.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/store-interface.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * This file exists to break a circular dependency between Store and the ActiveStore implementations.
 * Source code outside of the storage directory should not import this file directly; instead use
 * store.ts, which re-exports all the useful symbols.
 */
var StorageMode;
(function (StorageMode) {
    StorageMode[StorageMode["Direct"] = 0] = "Direct";
    StorageMode[StorageMode["Backing"] = 1] = "Backing";
    StorageMode[StorageMode["ReferenceMode"] = 2] = "ReferenceMode";
})(StorageMode || (StorageMode = {}));
var ProxyMessageType;
(function (ProxyMessageType) {
    ProxyMessageType[ProxyMessageType["SyncRequest"] = 0] = "SyncRequest";
    ProxyMessageType[ProxyMessageType["ModelUpdate"] = 1] = "ModelUpdate";
    ProxyMessageType[ProxyMessageType["Operations"] = 2] = "Operations";
})(ProxyMessageType || (ProxyMessageType = {}));
//# sourceMappingURL=store-interface.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/policy/ingress-validation.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


// Helper class for validating ingress fields and capabilities.
class ingress_validation_IngressValidation {
    constructor(policies) {
        this.policies = policies;
        this.capabilityByFieldPath = new Map();
        this.maxReadSchemas = {};
        for (const policy of this.policies) {
            for (const target of policy.targets) {
                const capabilities = target.toCapabilities();
                for (const field of target.fields) {
                    this.initCapabilitiesMap([target.schemaName], field, capabilities);
                }
            }
        }
        this.maxReadSchemas = ingress_validation_IngressValidation.getMaxReadSchemas(this.policies);
    }
    initCapabilitiesMap(fieldPaths, field, capabilities) {
        const paths = [...fieldPaths, field.name];
        if (field.subfields.length === 0) {
            this.addCapabilities(paths.join('.'), capabilities);
        }
        for (const subField of field.subfields) {
            this.initCapabilitiesMap(paths, subField, capabilities);
        }
    }
    addCapabilities(fieldPath, capabilities) {
        if (!this.capabilityByFieldPath.has(fieldPath)) {
            this.capabilityByFieldPath.set(fieldPath, []);
        }
        this.capabilityByFieldPath.get(fieldPath).push(...capabilities);
    }
    getFieldCapabilities(fieldPath) {
        return this.capabilityByFieldPath.get(fieldPath);
    }
    // Returns success, if all `create` handles in the recipe are declared with
    // capabilities that comply with the set of policies. Otherwise, returns a
    // combination of all encountered errors.
    validateIngressCapabilities(recipe) {
        return IngressValidationResult.every(recipe, recipe.handles.filter(h => h.fate === 'create')
            .map(h => this.validateHandleCapabilities(h)));
    }
    // For the given handle's type, returns a map of all allowed Capabilities by
    // field name:
    // - If Handle's type is covered by the policy, all fields in the Handle's
    // type schema must be included in the policy.
    // - Otherwise the capabilities will be determined by capabilities of all the
    // Handles its data is derived from.
    findHandleCapabilities(handle, capabilitiesByField, seenHandles = new Set()) {
        external_assert_default()(handle.type.maybeEnsureResolved({ restrictToMinBound: true }));
        seenHandles.add(handle);
        if (this.policiesContainType(handle.type.resolvedType())) {
            const fieldPaths = this.collectSchemaFieldPaths(handle.type.resolvedType().getEntitySchema());
            for (const fieldPath of fieldPaths) {
                const fieldCapabilities = this.getFieldCapabilities(fieldPath);
                if (fieldCapabilities == null) {
                    return IngressValidationResult.failWith(handle, `Missing capabilities for ${fieldPath}: is it mentioned in policy?`);
                }
                if (!capabilitiesByField.has(fieldPath)) {
                    capabilitiesByField.set(fieldPath, []);
                }
                capabilitiesByField.get(fieldPath).push(...fieldCapabilities);
            }
        }
        else {
            // All input connections of all particles writing into this handle.
            const sourceParticles = handle.connections.filter(conn => conn.isOutput)
                .map(conn => conn.particle);
            if (sourceParticles.length === 0) {
                return IngressValidationResult.failWith(handle, `Handle '${handle.id}' has no matching target type ` +
                    `${handle.type.resolvedType().toString()} in policies, and no source particles.`);
            }
            const sourceConnections = [];
            for (const sourceParticle of sourceParticles) {
                const particleInputs = Object.values(sourceParticle.connections)
                    .filter(conn => conn.isInput && !seenHandles.has(conn.handle));
                if (particleInputs.length === 0) {
                    return IngressValidationResult.failWith(handle, `Handle '${handle.id}' has no matching target type ` +
                        `${handle.type.resolvedType().toString()} in policies, and ` +
                        `contributing Particle ${sourceParticle.name} has no inputs.`);
                }
                sourceConnections.push(...particleInputs);
            }
            for (const sourceConn of sourceConnections) {
                const result = this.findHandleCapabilities(sourceConn.handle, capabilitiesByField);
                if (!result.success) {
                    return result;
                }
            }
        }
        return IngressValidationResult.success(handle);
    }
    // Returns success, if the type of the handle, restricted according with the
    // set of policies, has capabilities that are compliant with the policies'
    // retention and maxAge permissions. Otherwise, returns a combination of all
    // encountered errors.
    validateHandleCapabilities(handle) {
        const capabilitiesByField = new Map();
        const result = this.findHandleCapabilities(handle, capabilitiesByField);
        if (!result.success)
            return result;
        // Iterate over all fields of the `handle` restricted type, and for each field
        // verify that at least one of the field's Capabilities (according to the
        // set of policies) allows ingress with the given `handle` Capabilities.
        for (const [fieldPath, fieldCapabilities] of capabilitiesByField.entries()) {
            const fieldResults = fieldCapabilities.map(fc => fc.isAllowedForIngress(handle.capabilities));
            if (!fieldResults.some(r => r.success)) {
                result.addResult(IngressValidationResult.failWith(handle, `Failed validating ingress for field '${fieldPath}' of Handle ` +
                    `'${handle.id || handle.connections[0].getQualifiedName()}'`, fieldResults.filter(r => !r.success)));
            }
        }
        return result;
    }
    collectSchemaFieldPaths(schema) {
        const fieldPaths = [];
        for (const [fieldName, field] of Object.entries(schema.fields)) {
            fieldPaths.push(...this.collectFieldPaths(schema.name, fieldName, field));
        }
        return fieldPaths;
    }
    collectFieldPaths(fieldPrefix, fieldName, field) {
        const fieldPaths = [];
        if (field.isPrimitive || field.isKotlinPrimitive) {
            fieldPaths.push(`${fieldPrefix}.${fieldName}`);
        }
        else if (field.getEntityType()) {
            for (const [subfieldName, subfield] of Object.entries(field.getEntityType().entitySchema.fields)) {
                fieldPaths.push(...this.collectFieldPaths([fieldPrefix, fieldName].join('.'), subfieldName, subfield));
            }
        }
        else {
            external_assert_default()(`Unsupported field kind: ${field.kind}`);
        }
        return fieldPaths;
    }
    // Returns a type by the given name, combined from all corresponding type
    // restrictions provided by the given list of policies.
    policiesContainType(type) {
        return this.policies.some(policy => policy.targets.some(target => target.schemaName === type.getEntitySchema().name));
    }
    // Returns the max readable schemas for all schemas mentioned in the policies.
    static getMaxReadSchemas(policies) {
        const maxReadSchemas = {};
        for (const policy of policies) {
            for (const target of policy.targets) {
                const targetSchema = target.getMaxReadSchema();
                ingress_validation_IngressValidation.updateMaxReadSchemas(maxReadSchemas, targetSchema);
                // Update the accessible fields for any nested references.
                Object.values(targetSchema.fields).forEach(f => {
                    ingress_validation_IngressValidation.updateMaxReadSchemasForReferences(maxReadSchemas, f);
                });
            }
        }
        return maxReadSchemas;
    }
    static updateMaxReadSchemasForReferences(maxReadSchemas, field) {
        // Multiple fields like unions, tuples, are not supported.
        external_assert_default()(field.getFieldTypes() == null, 'Unions & tuples are not supported!');
        // Recurse into the underlying field types and update the
        // schemas as needed.
        const underlyingField = field.getFieldType();
        if (underlyingField != null) {
            ingress_validation_IngressValidation.updateMaxReadSchemasForReferences(maxReadSchemas, underlyingField);
        }
        const entityType = field.getEntityType();
        if (entityType == null)
            return;
        const targetSchema = entityType.getEntitySchema();
        if (field.isReference) {
            ingress_validation_IngressValidation.updateMaxReadSchemas(maxReadSchemas, targetSchema);
        }
        else if (field.isInline) {
            Object.values(targetSchema.fields).forEach(f => ingress_validation_IngressValidation.updateMaxReadSchemasForReferences(maxReadSchemas, f));
        }
        return;
    }
    static updateMaxReadSchemas(maxReadSchemas, targetSchema) {
        for (const name of targetSchema.names) {
            const currentMaxReadSchema = maxReadSchemas[name];
            if (currentMaxReadSchema == null) {
                maxReadSchemas[name] = targetSchema;
            }
            else {
                maxReadSchemas[name] = schema_Schema.union(currentMaxReadSchema, targetSchema);
            }
        }
    }
    // Return a new type where all the top-level schemas have been replaced
    // with the max read schema according to the given `policies`. Returns
    // null if the given type cannot be handled.
    //
    // Suppose that we have types `Foo {a, b, c, d, e, f}` and `Bar {w, x, y, z}`.
    // Policy is as follows:
    //   policy MyPolicy {
    //     from Foo access {a, c, e}
    //     from Bar access {w, z}
    //   }
    //
    // For various types, the return value of this method is as follows:
    //
    //    Foo -> Foo {a, c, e}
    //   [Foo] -> [Foo {a, c, e}]
    //   [&Foo] -> [&Foo {a, c, e}]
    //   (Foo, Bar) -> (Foo {a, c, e}, Bar {w, z})
    //   List<inline Foo> -> List<inline Foo {a, c, e}>
    //   Blah -> null
    //   (Foo, Blah) -> null
    //   ...
    getMaxReadType(type, errors) {
        switch (type.tag) {
            case 'Entity': {
                const schema = type.getEntitySchema();
                external_assert_default()(schema.names.length === 1, `Cannot deal with schemas with more than one name yet.`);
                const newSchema = this.maxReadSchemas[schema.names[0]];
                if (newSchema == null) {
                    errors === null || errors === void 0 ? void 0 : errors.push(`Schema '${schema.names[0]}' is not mentioned in policy`);
                    return null;
                }
                return new type_EntityType(newSchema);
            }
            case 'Collection': {
                const newCollectionType = this.getMaxReadType(type.getContainedType(), errors);
                if (newCollectionType == null)
                    return null;
                return new type_CollectionType(newCollectionType);
            }
            case 'Tuple': {
                const newInnerTypes = type.getContainedTypes().map(t => this.getMaxReadType(t, errors));
                if (newInnerTypes.includes(null))
                    return null;
                return new type_TupleType(newInnerTypes);
            }
            case 'Reference': {
                const newReferredType = this.getMaxReadType(type.getContainedType(), errors);
                if (newReferredType == null)
                    return null;
                return new type_ReferenceType(newReferredType);
            }
            case 'Singleton': {
                const newInnerType = this.getMaxReadType(type.getContainedType(), errors);
                if (newInnerType == null)
                    return null;
                return new type_SingletonType(newInnerType);
            }
            case 'TypeVariable': {
                const typeVar = type.variable;
                if (type.isResolved()) {
                    const maxReadType = this.getMaxReadType(type.resolvedType(), errors);
                    return (maxReadType == null)
                        ? null
                        : type_TypeVariable.make('', maxReadType, null, typeVar.resolveToMaxType);
                }
                const canReadSubset = type.canReadSubset;
                // Note that `canReadSubset` captures the constraints induced by the
                // writes to a connection/handle. If `canReadSubset` is null, this
                // type variable represents a connection/handle that was not written
                // to. Therefore, simply return the given type itself.
                if (canReadSubset == null)
                    return type;
                // Otherwise, create a new type variable that would represent
                // the max read type.
                const maxReadType = this.getMaxReadType(canReadSubset, errors);
                if (maxReadType == null)
                    return null;
                // Set `newCanWriteSuperset` to the max read type according to policy. We
                // should make sure that the `canWriteSuperset` is consistent with the
                // `canReadSubset` of the type variable, which can be achieved by using
                // the `restrictTypeRanges` method.
                const newCanWriteSuperset = maxReadType.restrictTypeRanges(canReadSubset);
                return type_TypeVariable.make('', newCanWriteSuperset, canReadSubset, typeVar.resolveToMaxType);
            }
            default:
                return null;
        }
    }
}
class IngressValidationResult {
    constructor(key, errors = []) {
        this.key = key;
        this.errors = errors;
        this.results = [];
    }
    get success() {
        return this.errors.length === 0 && this.results.every(r => r.success);
    }
    addError(error) { this.errors.push(error); }
    addResult(result) { this.results.push(result); }
    static success(key) {
        return new IngressValidationResult(key);
    }
    static failWith(key, error, results = []) {
        const result = new IngressValidationResult(key, [error]);
        result.results.push(...results);
        return result;
    }
    // Returns successful result, if all results in the given list are a success.
    // Otherwise, returns a combination of all error results.
    static every(key, results) {
        const combined = new IngressValidationResult(key);
        for (const result of results) {
            if (!result.success) {
                combined.addResult(result);
            }
        }
        return combined;
    }
    toString() {
        if (this.success) {
            return 'Validation result: Success';
        }
        else {
            return `Validation result: Failure\n ${this.errorsToString('  ')}`;
        }
    }
    errorsToString(prefix = '') {
        return [
            ...this.errors.map(e => `${prefix}${e}`),
            ...this.results.map(r => r.errorsToString(`${prefix}  `))
        ].join('\n');
    }
}
//# sourceMappingURL=ingress-validation.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/capabilities.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


var CapabilityComparison;
(function (CapabilityComparison) {
    CapabilityComparison[CapabilityComparison["LessStrict"] = 0] = "LessStrict";
    CapabilityComparison[CapabilityComparison["Equivalent"] = 1] = "Equivalent";
    CapabilityComparison[CapabilityComparison["Stricter"] = 2] = "Stricter";
})(CapabilityComparison || (CapabilityComparison = {}));
// Base class for all store capabilities.
class Capability {
    constructor(tag) {
        this.tag = tag;
    }
    isEquivalent(other) {
        return this.compare(other) === CapabilityComparison.Equivalent;
    }
    contains(other) {
        return this.isEquivalent(other);
    }
    isLessStrict(other) {
        return this.compare(other) === CapabilityComparison.LessStrict;
    }
    isSameOrLessStrict(other) {
        return [CapabilityComparison.LessStrict, CapabilityComparison.Equivalent]
            .includes(this.compare(other));
    }
    isStricter(other) {
        return this.compare(other) === CapabilityComparison.Stricter;
    }
    isSameOrStricter(other) {
        return [CapabilityComparison.Stricter, CapabilityComparison.Equivalent]
            .includes(this.compare(other));
    }
    /**
     * Returns true, if the given Capability is not null and at least as strict as this.
     */
    isAllowedForIngress(other) {
        return other && this.isSameOrLessStrict(other);
    }
    static fromAnnotations(annotations = []) {
        throw new Error('not implemented');
    }
    isCompatible(other) {
        return this.tag === other.tag;
    }
    toRange() { return new capabilities_CapabilityRange(this, this); }
}
// The persistence kinds in order from most to least restrictive.
var PersistenceKind;
(function (PersistenceKind) {
    PersistenceKind["None"] = "none";
    PersistenceKind["InMemory"] = "inMemory";
    PersistenceKind["OnDisk"] = "onDisk";
    PersistenceKind["Unrestricted"] = "unrestricted";
})(PersistenceKind || (PersistenceKind = {}));
class capabilities_Persistence extends Capability {
    constructor(kind = PersistenceKind.None) {
        super(capabilities_Persistence.tag);
        this.kind = kind;
    }
    static fromAnnotations(annotations = []) {
        const kinds = new Set();
        for (const annotation of annotations) {
            if ([PersistenceKind.OnDisk, 'persistent'].includes(annotation.name)) {
                kinds.add(PersistenceKind.OnDisk);
            }
            if ([PersistenceKind.InMemory, 'tiedToArc', 'tiedToRuntime'].includes(annotation.name)) {
                kinds.add(PersistenceKind.InMemory);
            }
        }
        if (kinds.size === 0) {
            return null;
        }
        external_assert_default()(kinds.size === 1, `Containing multiple persistence capabilities: ${annotations.map(a => a.toString()).join(' ')}`);
        return new capabilities_Persistence([...kinds][0]);
    }
    setMostRestrictive(other) {
        if (this.compare(other) === CapabilityComparison.LessStrict) {
            this.kind = other.kind;
        }
        return true;
    }
    setLeastRestrictive(other) {
        if (this.compare(other) === CapabilityComparison.Stricter) {
            this.kind = other.kind;
        }
        return true;
    }
    compare(other) {
        external_assert_default()(this.isCompatible(other));
        const otherPersistence = other;
        if (this.kind === otherPersistence.kind) {
            return CapabilityComparison.Equivalent;
        }
        if (Object.values(PersistenceKind).indexOf(this.kind) <
            Object.values(PersistenceKind).indexOf(otherPersistence.kind)) {
            return CapabilityComparison.Stricter;
        }
        return CapabilityComparison.LessStrict;
    }
    /**
     * Returns true, Persistence kinds are equivalent.
     */
    isAllowedForIngress(other) {
        return other && this.isEquivalent(other);
    }
    toDebugString() { return this.kind.toString(); }
    static none() { return new capabilities_Persistence(PersistenceKind.None); }
    static inMemory() { return new capabilities_Persistence(PersistenceKind.InMemory); }
    static onDisk() { return new capabilities_Persistence(PersistenceKind.OnDisk); }
    static unrestricted() { return new capabilities_Persistence(PersistenceKind.Unrestricted); }
    static any() { return new capabilities_CapabilityRange(capabilities_Persistence.unrestricted(), capabilities_Persistence.none()); }
}
capabilities_Persistence.tag = 'persistence';
var TtlUnits;
(function (TtlUnits) {
    TtlUnits["Millis"] = "ms";
    TtlUnits["Minutes"] = "m";
    TtlUnits["Hours"] = "h";
    TtlUnits["Days"] = "d";
    TtlUnits["Infinite"] = "infinite";
})(TtlUnits || (TtlUnits = {}));
// TTL as Capability.
class capabilities_Ttl extends Capability {
    constructor(count = 0, units = TtlUnits.Millis) {
        super(capabilities_Ttl.tag);
        this._count = count;
        this._units = units;
    }
    get count() { return this._count; }
    get units() { return this._units; }
    get millis() {
        if (this.isInfinite)
            return null;
        switch (this.units) {
            case TtlUnits.Millis:
                return this.count;
            case TtlUnits.Minutes:
                return this.count * 60 * 1000;
            case TtlUnits.Hours:
                return this.count * 60 * 60 * 1000;
            case TtlUnits.Days:
                return this.count * 24 * 60 * 60 * 1000;
            default:
                throw new Error(`Unsupported ttl units ${this.units}`);
        }
    }
    calculateExpiration(start = new Date()) {
        if (this.isInfinite)
            return null;
        return new Date(start.getTime() + this.millis);
    }
    get isInfinite() { return this.units === TtlUnits.Infinite; }
    compare(other) {
        external_assert_default()(this.isCompatible(other));
        const otherTtl = other;
        if (this.isInfinite || otherTtl.isInfinite) {
            return this.isInfinite === otherTtl.isInfinite
                ? CapabilityComparison.Equivalent : this.isInfinite
                ? CapabilityComparison.LessStrict : CapabilityComparison.Stricter;
        }
        const millis = this.millis;
        const otherMillis = otherTtl.millis;
        return (millis === otherMillis)
            ? CapabilityComparison.Equivalent : (millis > otherMillis)
            ? CapabilityComparison.LessStrict : CapabilityComparison.Stricter;
    }
    setMostRestrictive(other) {
        if (this.compare(other) === CapabilityComparison.LessStrict) {
            const otherTtl = other;
            this._count = otherTtl.count;
            this._units = otherTtl.units;
        }
        return true;
    }
    setLeastRestrictive(other) {
        if (this.compare(other) === CapabilityComparison.Stricter) {
            const otherTtl = other;
            this._count = otherTtl.count;
            this._units = otherTtl.units;
        }
        return true;
    }
    static fromAnnotations(annotations = []) {
        const ttlAnnotations = annotations.filter(annotation => annotation.name === 'ttl');
        if (ttlAnnotations.length === 0) {
            return null;
        }
        external_assert_default()(ttlAnnotations.length === 1, `Containing multiple TTL annotations`);
        const annotation = ttlAnnotations[0];
        return capabilities_Ttl.fromString(annotation.params['value'].toString());
    }
    static fromString(ttlStr) {
        if (!ttlStr) {
            return capabilities_Ttl.infinite();
        }
        const ttlTokens = ttlStr.match(/([0-9]+)[ ]*(day[s]?|hour[s]?|minute[s]?|[d|h|m])$/);
        external_assert_default()(ttlTokens && ttlTokens.length === 3, `Invalid ttl: ${ttlStr}`);
        return new capabilities_Ttl(Number(ttlTokens[1]), capabilities_Ttl.ttlUnitsFromString(ttlTokens[2]));
    }
    static fromLiteral(data) {
        if (data.units === TtlUnits.Infinite) {
            return capabilities_Ttl.infinite();
        }
        return new capabilities_Ttl(data.count, data.units);
    }
    toLiteral() {
        return { count: this.count, units: this.units };
    }
    static ttlUnitsFromString(units) {
        if ([TtlUnits.Minutes, 'minutes', 'minute'].includes(units)) {
            return TtlUnits.Minutes;
        }
        if ([TtlUnits.Hours, 'hours', 'hour'].includes(units)) {
            return TtlUnits.Hours;
        }
        if ([TtlUnits.Days, 'days', 'days'].includes(units)) {
            return TtlUnits.Days;
        }
        throw new Error(`Unsupported ttl units ${units}`);
    }
    toDebugString() {
        return this.isInfinite ? `infinite` : `${this.count}${this.units}`;
    }
    static infinite() { return new capabilities_Ttl(null, TtlUnits.Infinite); }
    static minutes(count) { return new capabilities_Ttl(count, TtlUnits.Minutes); }
    static hours(count) { return new capabilities_Ttl(count, TtlUnits.Hours); }
    static days(count) { return new capabilities_Ttl(count, TtlUnits.Days); }
    static zero() { return new capabilities_Ttl(0, TtlUnits.Millis); }
    static any() { return new capabilities_CapabilityRange(capabilities_Ttl.infinite(), capabilities_Ttl.zero()); }
}
capabilities_Ttl.tag = 'ttl';
class capabilities_BooleanCapability extends Capability {
    constructor(tag, value = false) {
        super(tag);
        this.value = value;
    }
    setMostRestrictive(other) {
        if (this.compare(other) === CapabilityComparison.LessStrict) {
            this.value = other.value;
        }
        return true;
    }
    setLeastRestrictive(other) {
        if (this.compare(other) === CapabilityComparison.Stricter) {
            this.value = other.value;
        }
        return true;
    }
    /**
     * Returns true, if the value is `false`, meaning that the policies don't
     * enforce this capability, hence it may or may not be specified in the
     * Handle's capabilities set. Otherwise calls the superclass implementation.
     */
    isAllowedForIngress(other) {
        return !this.value || super.isAllowedForIngress(other);
    }
    compare(other) {
        external_assert_default()(this.isCompatible(other));
        const otherCapability = other;
        if (this.value === otherCapability.value) {
            return CapabilityComparison.Equivalent;
        }
        return this.value ? CapabilityComparison.Stricter : CapabilityComparison.LessStrict;
    }
}
class capabilities_Queryable extends capabilities_BooleanCapability {
    constructor(value = false) {
        super(capabilities_Queryable.tag, value);
    }
    static fromAnnotations(annotations = []) {
        const queryableAnnotations = annotations.filter(annotation => annotation.name === 'queryable');
        if (queryableAnnotations.length === 0) {
            return null;
        }
        external_assert_default()(queryableAnnotations.length === 1, `Containing multiple queryable annotations`);
        return new capabilities_Queryable(true);
    }
    toDebugString() {
        return this.value ? 'queryable' : 'notQueryable';
    }
    static any() { return new capabilities_CapabilityRange(new capabilities_Queryable(false), new capabilities_Queryable(true)); }
}
capabilities_Queryable.tag = 'queryable';
// This is an inferred only capabilities that used to distinguish between
// ramdisk and volatile memory. Currently only introduced for backward
// compatibility in tests.
class capabilities_Shareable extends capabilities_BooleanCapability {
    constructor(value = false) {
        super(capabilities_Shareable.tag, value);
    }
    static fromAnnotations(annotations = []) {
        const shareableAnnotations = annotations.filter(annotation => ['shareable', 'tiedToRuntime'].includes(annotation.name));
        if (shareableAnnotations.length === 0) {
            return null;
        }
        external_assert_default()(shareableAnnotations.length === 1, `Containing multiple queryable annotations`);
        return new capabilities_Shareable(true);
    }
    toDebugString() {
        return this.value ? 'shareable' : 'notShareable';
    }
    static any() { return new capabilities_CapabilityRange(new capabilities_Shareable(false), new capabilities_Shareable(true)); }
}
capabilities_Shareable.tag = 'shareable';
class capabilities_Encryption extends capabilities_BooleanCapability {
    constructor(value = false) {
        super(capabilities_Encryption.tag, value);
    }
    static fromAnnotations(annotations = []) {
        const encryptedAnnotations = annotations.filter(annotation => annotation.name === 'encrypted');
        if (encryptedAnnotations.length === 0) {
            return null;
        }
        external_assert_default()(encryptedAnnotations.length === 1, `Containing multiple encrypted annotations`);
        return new capabilities_Encryption(true);
    }
    toDebugString() {
        return this.value ? 'encrypted' : 'notEncrypted';
    }
    static any() { return new capabilities_CapabilityRange(new capabilities_Encryption(false), new capabilities_Encryption(true)); }
}
capabilities_Encryption.tag = 'encryption';
/**
 * Support for delete propagation with hard references at the driver level (the driver is able to
 * delete all entities that contain a given reference).
 */
class DeletePropagation extends capabilities_BooleanCapability {
    constructor(value = false) {
        super(DeletePropagation.tag, value);
    }
    toDebugString() {
        return this.value ? 'delete-propagation' : 'no-delete-propagation';
    }
    static any() { return new capabilities_CapabilityRange(new DeletePropagation(false), new DeletePropagation(true)); }
}
DeletePropagation.tag = 'delete-propagation';
class capabilities_CapabilityRange extends Capability {
    constructor(min, max) {
        super(capabilities_CapabilityRange.tag);
        this.min = min;
        this.max = max || min;
        external_assert_default()(this.min.isSameOrLessStrict(this.max));
    }
    isEquivalent(other) {
        if (other.tag === capabilities_CapabilityRange.tag) {
            const range = other;
            return this.min.isEquivalent(range.min) && this.max.isEquivalent(range.max);
        }
        return this.min.isEquivalent(other) && this.max.isEquivalent(other);
    }
    isCompatible(other) {
        if (other.tag === capabilities_CapabilityRange.tag) {
            return this.min.isCompatible(other.min);
        }
        return this.min.isCompatible(other);
    }
    contains(other) {
        if (other.tag === capabilities_CapabilityRange.tag) {
            const range = other;
            return this.min.isSameOrLessStrict(range.min) && this.max.isSameOrStricter(range.max);
        }
        return this.min.isSameOrLessStrict(other) && this.max.isSameOrStricter(other);
    }
    compare(other) {
        throw new Error('not supported');
    }
    setMostRestrictive(other) {
        throw new Error('not supported');
    }
    setLeastRestrictive(other) {
        throw new Error('not supported');
    }
    toRange() { return this; }
    /**
     * Returns true if the minimum of this range allows ingress of the given `other` capability.
     */
    isAllowedForIngress(other) {
        return this.min.isAllowedForIngress(other && other.isCompatible(this)
            ? other.min : other);
    }
    toDebugString() {
        if (this.min.isEquivalent(this.max)) {
            return this.min.toDebugString();
        }
        return `${this.min.toDebugString()} - ${this.max.toDebugString()}`;
    }
}
capabilities_CapabilityRange.tag = 'range';
// Capabilities are a grouping of individual capabilities.
class capabilities_Capabilities {
    constructor(ranges = []) {
        this.ranges = [];
        for (const capability of ranges) {
            this.ranges.push(capability.toRange());
        }
    }
    static create(ranges = []) {
        return new capabilities_Capabilities(ranges);
    }
    getPersistence() {
        const range = this.getWithTag(capabilities_Persistence.tag);
        if (range) {
            external_assert_default()(range.min.isEquivalent(range.max));
            return range.min;
        }
        return undefined;
    }
    getTtl() {
        const range = this.getWithTag(capabilities_Ttl.tag);
        if (range) {
            external_assert_default()(range.min.isEquivalent(range.max));
            return range.min;
        }
        return undefined;
    }
    isEncrypted() {
        const encryption = this.getWithTag(capabilities_Encryption.tag);
        return encryption ? encryption.min.value : undefined;
    }
    isQueryable() {
        const queryable = this.getWithTag(capabilities_Queryable.tag);
        return queryable ? queryable.min.value : undefined;
    }
    isShareable() {
        const shareable = this.getWithTag(capabilities_Shareable.tag);
        return shareable ? shareable.min.value : undefined;
    }
    getWithTag(tag) {
        return this.ranges.find(range => range.min.tag === tag);
    }
    static fromAnnotations(annotations = []) {
        const ranges = [];
        for (const parser of [capabilities_Persistence.fromAnnotations,
            capabilities_Encryption.fromAnnotations,
            capabilities_Ttl.fromAnnotations,
            capabilities_Queryable.fromAnnotations,
            capabilities_Shareable.fromAnnotations]) {
            const capability = parser(annotations);
            if (capability) {
                ranges.push(capability);
            }
        }
        return new capabilities_Capabilities(ranges);
    }
    setCapability(capability) {
        let existing = this.getWithTag(capability.tag);
        if (existing) {
            existing = capability.toRange();
        }
        else {
            this.ranges.push(capability.toRange());
        }
        return true;
    }
    isEmpty() { return this.ranges.length === 0; }
    isEquivalent(other) {
        return this.ranges.length === other.ranges.length &&
            other.ranges.every(otherRange => this.hasEquivalent(otherRange));
    }
    hasEquivalent(capability) {
        return this.ranges.some(range => {
            return range.isCompatible(capability) && range.isEquivalent(capability);
        });
    }
    contains(capability) {
        const range = this.findCompatible(capability);
        return range && range.contains(capability);
    }
    containsAll(other) {
        return other.ranges.every(otherRange => this.contains(otherRange));
    }
    findCompatible(capability) {
        return this.ranges.find(range => range.isCompatible(capability));
    }
    /**
     * Returns true, if all ranges of capabilities are equally or less
     * restrictive as the given handle's capabilities. The errors list will
     * contain messages on non complying ranges.
     */
    isAllowedForIngress(handleCapabilities) {
        for (const range of this.ranges) {
            const handleRange = handleCapabilities.findCompatible(range.min);
            if (!range.isAllowedForIngress(handleRange)) {
                return IngressValidationResult.failWith(this, `Capabilities ${this.toDebugString()} failed to validate ingress: ` +
                    `'${range.min.toDebugString()}' is not compatible for ingress with ` +
                    `'${handleRange ? handleRange.toDebugString() : 'unspecified'}'`);
            }
        }
        return IngressValidationResult.success(this);
    }
    toDebugString() {
        return `{${this.ranges.map(range => range.toDebugString()).join(', ')}}`;
    }
}
//# sourceMappingURL=capabilities.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/storage-key.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class StorageKey {
    constructor(protocol) {
        this.protocol = protocol;
    }
    toLiteral() { return { protocol: this.protocol, key: this.toString() }; }
    subKeyWithComponent(component) {
        return this.childWithComponent(component);
    }
    childKeyForBackingElement(id) {
        return this.childWithComponent(id);
    }
    childKeyForArcInfo() {
        return this.subKeyWithComponent('arc-info');
    }
    childKeyForHandle(id) {
        return this.subKeyWithComponent(`handle/${id}`);
    }
    childKeyForSuggestions(id) {
        return this.subKeyWithComponent(`suggestion/${id}`);
    }
    childKeyForSearch(id) {
        return this.subKeyWithComponent(`search/${id}`);
    }
    embedKey() {
        return this.toString().replace(/\{/g, '{{').replace(/\}/g, '}}');
    }
    static unembedKey(key) {
        return key.replace(/\}\}/g, '}').replace(/\{\{/g, '}');
    }
}
StorageKey.fromLiteral = null;
//# sourceMappingURL=storage-key.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/reference-mode-storage-key.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

class reference_mode_storage_key_ReferenceModeStorageKey extends StorageKey {
    constructor(backingKey, storageKey) {
        super(reference_mode_storage_key_ReferenceModeStorageKey.protocol);
        this.backingKey = backingKey;
        this.storageKey = storageKey;
    }
    toString() {
        return `${this.protocol}://{${this.backingKey.embedKey()}}{${this.storageKey.embedKey()}}`;
    }
    childWithComponent(component) {
        return new reference_mode_storage_key_ReferenceModeStorageKey(this.backingKey, this.storageKey.childWithComponent(component));
    }
    static fromString(key, parse) {
        const match = key.match(/^reference-mode:\/\/{((?:\}\}|[^}])+)}{((?:\}\}|[^}])+)}$/);
        if (!match) {
            throw new Error(`Not a valid ReferenceModeStorageKey: ${key}.`);
        }
        const [_, backingKey, storageKey] = match;
        return new reference_mode_storage_key_ReferenceModeStorageKey(parse(StorageKey.unembedKey(backingKey)), parse(StorageKey.unembedKey(storageKey)));
    }
}
reference_mode_storage_key_ReferenceModeStorageKey.protocol = 'reference-mode';
//# sourceMappingURL=reference-mode-storage-key.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/store-info.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */





/** Assorted properties about a store. */
class store_info_StoreInfo {
    constructor(opts) {
        this.id = opts.id;
        this.name = opts.name;
        this.originalId = opts.originalId;
        this.source = opts.source;
        this.origin = opts.origin;
        this.description = opts.description;
        this.includeKey = opts.includeKey;
        this.storageKey = opts.storageKey;
        this.claims = opts.claims;
        this.annotations = opts.annotations;
        this.type = opts.type;
        this.model = opts.model;
        this.versionToken = opts.versionToken;
        this.exists = opts.exists;
        if (this.type && this.type.isMux) {
            this.mode = StorageMode.Backing;
        }
        else {
            this.mode = this.storageKey instanceof reference_mode_storage_key_ReferenceModeStorageKey ? StorageMode.ReferenceMode : StorageMode.Direct;
        }
    }
    static fromLiteral(literal) {
        return new store_info_StoreInfo({
            id: literal.id, type: type_Type.fromLiteral(literal.type),
            storageKey: StorageKey.fromLiteral(literal.storageKey)
        });
    }
    toLiteral() {
        return { id: this.id, type: this.type.toLiteral(), storageKey: this.storageKey.toLiteral() };
    }
    clone(overrides) {
        return new store_info_StoreInfo({
            id: overrides.id || this.id,
            name: overrides.name || this.name,
            originalId: overrides.originalId || this.originalId,
            source: overrides.source || this.source,
            origin: overrides.origin || this.origin,
            includeKey: overrides.includeKey || this.includeKey,
            storageKey: overrides.storageKey || this.storageKey,
            type: overrides.type || this.type,
            claims: overrides.claims || this.claims,
            annotations: overrides.annotations || this.annotations,
            model: overrides.model || this.model,
            versionToken: overrides.versionToken || this.versionToken
        });
    }
    get apiChannelMappingId() { return this.id; }
    _compareTo(other) {
        let cmp;
        cmp = compareStrings(this.name, other.name);
        if (cmp !== 0)
            return cmp;
        cmp = compareStrings(this.versionToken, other.versionToken);
        if (cmp !== 0)
            return cmp;
        cmp = compareStrings(this.source, other.source);
        if (cmp !== 0)
            return cmp;
        cmp = compareStrings(this.id, other.id);
        if (cmp !== 0)
            return cmp;
        return 0;
    }
    // TODO: Make these tags live inside StoreInfo.
    toManifestString(opts) {
        opts = opts || {};
        if (opts.overrides) {
            return this.clone(opts.overrides).toManifestString({ handleTags: opts.handleTags });
        }
        const builder = new IndentingStringBuilder();
        if ((this.annotations || []).length > 0) {
            builder.push(...this.annotations.map(a => a.toString()));
        }
        const handleStr = [];
        handleStr.push(`store`);
        if (this.name) {
            handleStr.push(`${this.name}`);
        }
        handleStr.push(`of ${this.type.toString()}`);
        if (this.id) {
            handleStr.push(`'${this.id}'`);
        }
        if (this.originalId) {
            handleStr.push(`!!${this.originalId}`);
        }
        if (this.versionToken != null) {
            handleStr.push(`@${this.versionToken}`);
        }
        if (opts.handleTags && opts.handleTags.length) {
            handleStr.push(`${opts.handleTags.map(tag => `#${tag}`).join(' ')}`);
        }
        if (this.source) {
            if (this.origin === 'file') {
                handleStr.push(`in '${this.source}'`);
            }
            else {
                handleStr.push(`in ${this.source}`);
                if (this.includeKey) {
                    handleStr.push(`at '${this.includeKey}'`);
                }
            }
        }
        else if (this.storageKey) {
            handleStr.push(`at '${this.storageKey}'`);
        }
        builder.push(handleStr.join(' '));
        builder.withIndent(builder => {
            if (this.claims && this.claims.size > 0) {
                for (const [target, claims] of this.claims) {
                    const claimClause = target.length ? `claim field ${target}` : 'claim';
                    builder.push(`${claimClause} is ${claims.map(claim => claim.tag).join(' and is ')}`);
                }
            }
            if (this.description) {
                builder.push(`description \`${this.description}\``);
            }
        });
        return builder.toString();
    }
    static isSingletonInterfaceStore(store) {
        return (store.type.isSingleton && store.type.getContainedType().isInterface);
    }
    isSingletonInterfaceStore() {
        return (this.type.isSingleton && this.type.getContainedType().isInterface);
    }
    static isSingletonEntityStore(store) {
        return store.isSingletonEntityStore();
    }
    isSingletonEntityStore() {
        return (this.type.isSingleton && this.type.getContainedType().isEntity);
    }
    static isCollectionEntityStore(store) {
        return store.isCollectionEntityStore();
    }
    isCollectionEntityStore() {
        return (this.type.isCollection && this.type.getContainedType().isEntity);
    }
    isSingletonReferenceStore() {
        return (this.type.isSingleton && this.type.getContainedType().isReference);
    }
    isCollectionReferenceStore() {
        return (this.type.isCollection && this.type.getContainedType().isReference);
    }
    isMuxEntityStore() {
        return (this.type.isMuxType());
    }
    entityHasName(name) {
        return this.type.getContainedType().isEntity && this.type.getContainedType().getEntitySchema().names.includes(name);
    }
}
//# sourceMappingURL=store-info.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/storage-proxy.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */







/**
 * Mediates between one or more Handles and the backing store. The store can be outside the PEC or
 * directly connected to the StorageProxy.
 */
class storage_proxy_StorageProxy {
    constructor(store, ttl = capabilities_Ttl.infinite()) {
        this.store = store;
        this.ttl = ttl;
        this.handles = [];
        this.listenerAttached = false;
        this.keepSynced = false;
        this.synchronized = false;
        this.modelHasSynced = () => undefined;
        this.type = store.storeInfo.type;
        this.crdt = new (this.type.crdtInstanceConstructor())();
        this.storageKey = store.storeInfo.storageKey ? store.storeInfo.storageKey.toString() : null;
        this.scheduler = new storage_proxy_StorageProxyScheduler();
    }
    get storeInfo() { return this.store.storeInfo; }
    async pause() {
        await this.scheduler.pause();
    }
    unpause() {
        this.scheduler.unpause();
    }
    getStorageFrontend() {
        return this.store.getStorageFrontend();
    }
    async idle() {
        return this.scheduler.idle;
    }
    reportExceptionInHost(exception) {
        // TODO: Encapsulate source-mapping of the stack trace once there are more users of the port.RaiseSystemException() call.
        if (mapStackTrace) {
            mapStackTrace(exception.cause.stack, mappedStack => {
                exception.cause.stack = mappedStack;
                this.store.reportExceptionInHost(exception);
            });
        }
        else {
            this.store.reportExceptionInHost(exception);
        }
    }
    registerHandle(handle) {
        // Check whether we're synchronized up-front; it's possible that calling requestSynchronization
        // will result in immediate delivery of a message that causes us to become synchronized
        // partway through running this method. If that's the case, the normal notifySync process
        // will kick in and we don't need to notifySyncForHandle explicitly. We only need to do that
        // if we were *already* synchronized
        const isSynchronized = this.synchronized;
        // Attach an event listener to the backing store when the first handle is registered.
        if (!this.listenerAttached) {
            this.store.setCallback(x => this.onMessage(x));
            this.listenerAttached = true;
        }
        if (!handle.canRead) {
            return;
        }
        this.handles.push(handle);
        // Change to synchronized mode as soon as we get any handle configured with keepSynced and send
        // a request to get the full model (once).
        // TODO: drop back to non-sync mode if all handles re-configure to !keepSynced.
        if (handle.options.keepSynced) {
            if (!this.keepSynced) {
                this.requestSynchronization().catch(e => {
                    this.reportExceptionInHost(new SystemException(e, handle.key, 'StorageProxy::registerHandle'));
                });
                this.keepSynced = true;
            }
            // If a handle configured for sync notifications registers after we've received the full
            // model, notify it immediately.
            if (handle.options.notifySync && isSynchronized) {
                this.notifySyncForHandle(handle);
            }
        }
        return;
    }
    deregisterHandle(handleIn) {
        this.scheduler.dropMessages(handleIn);
        this.handles = this.handles.filter(handle => handle !== handleIn);
    }
    versionCopy() {
        const version = {};
        for (const [k, v] of Object.entries(this.crdt.getData().version)) {
            version[k] = v;
        }
        return version;
    }
    async applyOp(op) {
        if (!this.crdt.applyOperation(op)) {
            return false;
        }
        const message = {
            type: ProxyMessageType.Operations,
            operations: [op],
        };
        await this.store.onProxyMessage(message);
        this.notifyUpdate(op, options => options.notifyUpdate);
        return true;
    }
    async getParticleView() {
        if (this.synchronized) {
            return this.getParticleViewAssumingSynchronized();
        }
        else {
            const promise = new Promise((resolve) => {
                this.modelHasSynced = () => {
                    this.modelHasSynced = () => undefined;
                    resolve(this.crdt.getParticleView());
                };
            });
            // Request a new model, it will come back asynchronously with a ModelUpdate message.
            await this.requestSynchronization();
            return promise;
        }
    }
    getParticleViewAssumingSynchronized() {
        if (!this.synchronized) {
            throw new Error('AssumingSynchronized variant called but proxy is not synchronized');
        }
        return this.crdt.getParticleView();
    }
    /**
     * Set synchronized state and call notifySync if not currently synced. If initialModel is
     * provided, pass this to notifySync, otherwise notifySync will generate a model from
     * the CRDT data.
     */
    setSynchronized(initialModel = null) {
        if (!this.synchronized) {
            this.synchronized = true;
            this.notifySync(initialModel);
        }
    }
    clearSynchronized() {
        if (this.synchronized) {
            this.synchronized = false;
            this.notifyDesync();
        }
    }
    async onMessage(message) {
        switch (message.type) {
            case ProxyMessageType.ModelUpdate:
                {
                    const { modelChange } = this.crdt.merge(message.model);
                    if (this.synchronized) {
                        // if the particle is already synchronized, try to interpret this update
                        // as a sequence of operations. If that's impossible (because merge returned)
                        // a model rather than operations) then clear synchronization so that
                        // the particle knows to expect a resync message with the new model
                        if (modelChange.changeType === ChangeType.Operations) {
                            modelChange.operations.forEach(op => this.notifyUpdate(op, options => !options.keepSynced && options.notifyUpdate));
                            break;
                        }
                        this.clearSynchronized();
                    }
                    this.setSynchronized();
                    // NOTE: this.modelHasSynced used to run after this.synchronized
                    // was set to true but before notifySync() was called. Is that a problem?
                    this.modelHasSynced();
                    break;
                }
            case ProxyMessageType.Operations: {
                // Immediately notify any handles that are not configured with keepSynced but do want updates.
                message.operations.forEach(op => this.notifyUpdate(op, options => !options.keepSynced && options.notifyUpdate));
                // Bail if we're not in synchronized mode.
                if (!this.keepSynced) {
                    return;
                }
                const initialModel = this.crdt.getParticleView();
                for (const op of message.operations) {
                    if (!this.crdt.applyOperation(op)) {
                        // If we cannot cleanly apply ops, sync the whole model.
                        this.clearSynchronized();
                        await this.requestSynchronization();
                        return;
                    }
                    if (!this.synchronized) {
                        // If we didn't think we were synchronized but the operation applied cleanly,
                        // then actually we were synchronized after all. Tell the handle that.
                        this.setSynchronized(initialModel);
                    }
                    // Notify handles configured with keepSynced.
                    this.notifyUpdate(op, options => options.keepSynced && options.notifyUpdate);
                }
                break;
            }
            case ProxyMessageType.SyncRequest:
                await this.store.onProxyMessage({ type: ProxyMessageType.ModelUpdate, model: this.crdt.getData() });
                break;
            default:
                throw new CRDTError(`Invalid operation provided to onMessage, message: ${message}`);
        }
        return;
    }
    notifyUpdate(operation, predicate) {
        for (const handle of this.handles) {
            if (predicate(handle.options)) {
                this.scheduler.enqueue(handle.particle, handle, { type: HandleMessageType.Update, op: operation });
            }
        }
    }
    notifySync(initialModel = null) {
        const model = initialModel ? initialModel : this.crdt.getParticleView();
        for (const handle of this.handles) {
            if (handle.options.notifySync) {
                this.scheduler.enqueue(handle.particle, handle, { type: HandleMessageType.Sync, model });
            }
        }
    }
    notifySyncForHandle(handle) {
        const model = this.crdt.getParticleView();
        this.scheduler.enqueue(handle.particle, handle, { type: HandleMessageType.Sync, model });
    }
    notifyDesync() {
        for (const handle of this.handles) {
            if (handle.options.notifyDesync) {
                this.scheduler.enqueue(handle.particle, handle, { type: HandleMessageType.Desync });
            }
        }
    }
    async requestSynchronization() {
        await this.store.onProxyMessage({ type: ProxyMessageType.SyncRequest });
    }
}
class storage_proxy_NoOpStorageProxy extends storage_proxy_StorageProxy {
    constructor() {
        super({
            // tslint:disable-next-line: no-any
            storeInfo: new store_info_StoreInfo({ id: null, type: type_EntityType.make([], {}) }),
            setCallback: (_) => { },
            reportExceptionInHost: (_) => { },
            onProxyMessage: async (_) => { },
            getStorageFrontend: null
        });
    }
    async idle() {
        return new Promise(resolve => { });
    }
    getStorageFrontend() {
        return null;
    }
    reportExceptionInHost(exception) { }
    registerHandle(handle) {
        return {};
    }
    deregisterHandle(handle) { }
    versionCopy() {
        return null;
    }
    async applyOp(op) {
        return new Promise(resolve => { });
    }
    async getParticleView() {
        return new Promise(resolve => { });
    }
    getParticleViewAssumingSynchronized() {
        return [null, {}];
    }
    async getData() {
        return new Promise(resolve => { });
    }
    async onMessage(message) {
    }
    notifyUpdate(operation, predicate) { }
    notifySync() { }
    notifySyncForHandle(handle) { }
    notifyDesync() { }
    async pause() { }
    unpause() { }
    async requestSynchronization() {
        return new Promise(resolve => { });
    }
}
var HandleMessageType;
(function (HandleMessageType) {
    HandleMessageType[HandleMessageType["Sync"] = 0] = "Sync";
    HandleMessageType[HandleMessageType["Desync"] = 1] = "Desync";
    HandleMessageType[HandleMessageType["Update"] = 2] = "Update";
})(HandleMessageType || (HandleMessageType = {}));
class storage_proxy_StorageProxyScheduler {
    constructor() {
        this._scheduled = false;
        this._queues = new Map();
        this._idleResolver = null;
        this._idle = null;
        this.paused = false;
        this._scheduled = false;
        // Particle -> {Handle -> [Queue of events]}
        this._queues = new Map();
    }
    enqueue(particle, handle, args) {
        if (!this._queues.has(particle)) {
            this._queues.set(particle, new Map());
        }
        const byHandle = this._queues.get(particle);
        if (!byHandle.has(handle)) {
            byHandle.set(handle, []);
        }
        const queue = byHandle.get(handle);
        queue.push(args);
        this._schedule();
    }
    get busy() {
        return this._queues.size > 0;
    }
    _updateIdle() {
        if (this._idleResolver && !this.busy) {
            this._idleResolver();
            this._idle = null;
            this._idleResolver = null;
        }
    }
    async pause() {
        await this.idle;
        this.paused = true;
    }
    unpause() {
        this.paused = false;
        this._schedule();
    }
    dropMessages(handle) {
        for (const byHandle of this._queues.values()) {
            if (byHandle.has(handle)) {
                byHandle.delete(handle);
            }
        }
    }
    get idle() {
        if (!this.busy) {
            return Promise.resolve();
        }
        if (!this._idle) {
            this._idle = new Promise(resolve => this._idleResolver = resolve);
        }
        return this._idle;
    }
    _schedule() {
        if (this._scheduled) {
            return;
        }
        this._scheduled = true;
        setTimeout(() => {
            this._scheduled = false;
            this._dispatch();
        }, 0);
    }
    _dispatch() {
        if (this.paused) {
            return;
        }
        // TODO: should we process just one particle per task?
        while (this._queues.size > 0) {
            const particle = [...this._queues.keys()][0];
            const byHandle = this._queues.get(particle);
            this._queues.delete(particle);
            for (const [handle, queue] of byHandle.entries()) {
                for (const update of queue) {
                    this._dispatchUpdate(handle, update).catch(e => handle.storageProxy.reportExceptionInHost(new SystemException(e, 'StorageProxyScheduler::_dispatch', handle.key)));
                }
            }
        }
        this._updateIdle();
    }
    async _dispatchUpdate(handle, update) {
        switch (update.type) {
            case HandleMessageType.Sync:
                handle.onSync(update.model);
                break;
            case HandleMessageType.Desync:
                await handle.onDesync();
                break;
            case HandleMessageType.Update:
                handle.onUpdate(update.op);
                break;
            default:
                console.error('Ignoring unknown update', update);
        }
    }
}
//# sourceMappingURL=storage-proxy.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/entity.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */






function getInternals(entity) {
    return getStorableInternals(entity);
}
// This class holds extra entity-related fields used by the runtime. Instances of this are stored
// in their parent Entity via a Symbol-based key. This allows Entities to hold whatever field names
// their Schemas describe without any possibility of names clashing. For example, an Entity can have
// an 'id' field that is distinct (in both value and type) from the id field here. Access to this
// class should be via the static helpers in Entity.
class entity_EntityInternals {
    constructor(entity, entityClass, schema, frontend, userIDComponent) {
        this.entity = entity;
        this.entityClass = entityClass;
        this.schema = schema;
        this.frontend = frontend;
        this.userIDComponent = userIDComponent;
        // TODO: Only the Arc that "owns" this Entity should be allowed to mutate it.
        this.mutable = true;
    }
    getId() {
        if (this.id === undefined) {
            throw new Error('no id');
        }
        return this.id;
    }
    getStorageKey() {
        if (this.id === undefined) {
            throw new Error('entity has not yet been stored!');
        }
        if (this.storageKey === undefined) {
            throw new Error('entity has been stored but storage key was not recorded against entity');
        }
        return this.storageKey;
    }
    getEntityClass() {
        return this.entityClass;
    }
    getCreationTimestamp() {
        if (this.id === undefined) {
            throw new Error('entity has not yet been stored!');
        }
        if (this.creationTimestamp === undefined) {
            throw new Error('entity has been stored but creation timestamp was not recorded against entity');
        }
        return this.creationTimestamp;
    }
    getExpirationTimestamp() {
        if (this.id === undefined) {
            throw new Error('entity has not yet been stored!');
        }
        return this.expirationTimestamp;
    }
    isIdentified() {
        return this.id !== undefined;
    }
    hasCreationTimestamp() {
        return this.creationTimestamp !== undefined;
    }
    hasExpirationTimestamp() {
        return this.expirationTimestamp !== undefined;
    }
    identify(identifier, storageKey, creationTimestamp, expirationTimestamp) {
        external_assert_default()(!this.isIdentified(), 'identify() called on already identified entity');
        this.id = identifier;
        this.storageKey = storageKey;
        this.creationTimestamp = creationTimestamp;
        this.expirationTimestamp = expirationTimestamp;
        const components = identifier.split(':');
        const uid = components.lastIndexOf('uid');
        this.userIDComponent = uid > 0 ? components.slice(uid + 1).join(':') : '';
    }
    createIdentity(parentId, idGenerator, storageKey, ttl) {
        external_assert_default()(!this.isIdentified(), 'createIdentity() called on already identified entity');
        external_assert_default()(!this.hasExpirationTimestamp(), 'createIdentity() called on entity with expirationTimestamp');
        let id;
        if (this.userIDComponent) {
            // TODO: Stop creating IDs by manually concatenating strings.
            id = `${parentId.toString()}:uid:${this.userIDComponent}`;
        }
        else {
            id = idGenerator.newChildId(parentId).toString();
        }
        this.storageKey = storageKey;
        this.id = id;
        this.setExpiration(ttl);
    }
    setExpiration(ttl) {
        external_assert_default()(ttl, `ttl cannot be null`);
        const now = new Date();
        this.creationTimestamp = now;
        if (!ttl.isInfinite) {
            this.expirationTimestamp = ttl.calculateExpiration(now);
        }
    }
    isMutable() {
        return this.mutable;
    }
    /**
     * Prevents further mutation of this Entity instance. Note that calling this method only affects
     * this particular Entity instance; the entity it represents (in a data store somewhere) can
     * still be mutated by others. Also note that this doesn't necessarily offer any security against
     * malicious developers.
     */
    makeImmutable() {
        this.mutable = false;
    }
    /**
     * Mutates the entity. Supply either the new data for the entity, which replaces the existing
     * entity's data entirely, or a mutation function. The supplied mutation function will be called
     * with a mutable copy of the entity's data. The mutations performed by that function will be
     * reflected in the original entity instance (i.e. mutations applied in place).
     */
    mutate(mutation) {
        if (!this.mutable) {
            throw new Error('Entity is immutable.');
        }
        let newData;
        // Using typeof instead of instanceof here, because apparently sometimes lambdas aren't an instance of Function... :-/
        if (typeof mutation === 'function') {
            newData = this.dataClone();
            mutation(newData);
        }
        else {
            newData = mutation;
        }
        // Note that this does *not* trigger the error in the Entity's Proxy 'set' trap, because we're
        // applying the field updates directly to the original Entity instance (this.entity), not the
        // Proxied version returned by the Entity constructor. Not confusing at all!
        sanitizeAndApply(this.entity, newData, this.schema, this.frontend);
        // TODO: Send mutations to data store.
    }
    toLiteral() {
        return JSON.parse(JSON.stringify(this.entity));
    }
    dataClone() {
        const clone = {};
        for (const [name, desc] of Object.entries(this.schema.fields)) {
            const value = this.entity[name];
            if (value !== undefined) {
                if (desc && desc.kind === 'schema-reference') {
                    if (value) {
                        clone[name] = value.dataClone();
                    }
                }
                else if (desc && ['schema-collection', 'schema-tuple'].includes(desc.kind)) {
                    if (value) {
                        clone[name] = [...value].map(a => this.cloneValue(a));
                    }
                }
                else if (desc && desc.kind === 'schema-nested') {
                    const data = getInternals(value).dataClone();
                    clone[name] = new (value.constructor)(data);
                }
                else {
                    clone[name] = this.cloneValue(value);
                }
            }
        }
        return clone;
    }
    cloneValue(value) {
        if (value == null || ['string', 'boolean', 'number'].includes(typeof (value))) {
            return value;
        }
        if (value.constructor.name === 'Uint8Array') {
            return Uint8Array.from(value);
        }
        if (typeof value.length === 'number') {
            return value.slice().map(this.cloneValue);
        }
        return value.dataClone();
    }
    serialize() {
        const serializedEntity = {
            id: this.id,
            rawData: this.dataClone()
        };
        if (this.hasCreationTimestamp()) {
            serializedEntity.creationTimestamp = this.creationTimestamp.getTime();
        }
        if (this.hasExpirationTimestamp()) {
            serializedEntity.expirationTimestamp = this.expirationTimestamp.getTime();
        }
        return serializedEntity;
    }
    debugLog() {
        // Here be dragons! Create a copy of the entity class but with an enumerable version of this
        // internals object so it will appear in the log output, with a few tweaks for better display.
        const original = this.entity;
        // The 'any' type is required to modify some readonly fields below.
        // tslint:disable-next-line: no-any
        const copy = new entity_EntityInternals(null, this.entityClass, this.schema, null, this.userIDComponent);
        copy.id = this.id;
        // Force '.entity' to show as '[Circular]'.
        copy.entity = copy;
        // We don't want to log the storageFrontend object but showing '.frontend' as null
        // could be confusing, so omit it altogether.
        delete copy.frontend;
        // Set up a class that looks the same as the real entity, copy the schema fields in, add an
        // enumerable version of the copied internals, and use console.dir to show the full object.
        // Node displays the name set up with defineProperty below, but Chrome uses the name of the
        // class variable defined here, so we'll call that entity.
        const entity = class extends entity_Entity {
            constructor() {
                super();
                Object.assign(this, original);
                this[SYMBOL_INTERNALS] = copy;
            }
            debugLog() { }
        };
        if (original.constructor.name) {
            Object.defineProperty(entity, 'name', { value: original.constructor.name });
        }
        console.dir(new entity(), { depth: null });
    }
}
class entity_Entity extends Storable {
    toString() {
        const fields = Object.entries(this).map(([name, value]) => `${name}: ${JSON.stringify(value)}`);
        return `${this.constructor.name} { ${fields.join(', ')} }`;
    }
    // Dynamically constructs a new JS class for the entity type represented by the given schema.
    // This creates a new class which extends the Entity base class and implements the required
    // static properties, then returns a Proxy wrapping that to guard against incorrect field writes.
    static createEntityClass(schema, frontend) {
        const clazz = class extends entity_Entity {
            constructor(data, userIDComponent) {
                super();
                external_assert_default()(data, `can't construct entity with null data`);
                external_assert_default()(!userIDComponent || userIDComponent.indexOf(':') === -1, `user IDs must not contain the ':' character`);
                // We want the SYMBOL_INTERNALS property to be non-enumerable so any copies made of this
                // entity (e.g. via Object.assign) pick up only the plain data fields from the schema, and
                // not the EntityInternals object (which should be unique to this instance).
                Object.defineProperty(this, SYMBOL_INTERNALS, {
                    value: new entity_EntityInternals(this, clazz, schema, frontend, userIDComponent),
                    enumerable: false
                });
                sanitizeAndApply(this, data, schema, frontend);
                // We don't want a 'get' trap here because JS accesses various fields as part of routine
                // system behaviour, and making sure we special case all of them is going to be brittle.
                // For example: when returning an object from an async function, JS needs to check if the
                // object is a 'thenable' (so it knows whether to wrap it in a Promise or not), and it does
                // this by checking for the existence of a 'then' method. Not trapping 'get' is ok because
                // callers who try to read fields that aren't in the schema will just get 'undefined', which
                // is idiomatic for JS anyway.
                return new Proxy(this, {
                    set: (target, name, value) => {
                        throw new Error(`Tried to modify entity field '${name}'. Use the mutate method instead.`);
                    }
                });
            }
            static get type() {
                // TODO: should the entity's key just be its type?
                // Should it just be called type in that case?
                return new type_EntityType(schema);
            }
            static get key() {
                return { tag: 'entity', schema };
            }
            static get schema() {
                return schema;
            }
            toString() {
                const entry2field = (name, value) => `${name}: ${JSON.stringify(value)}`;
                const object2string = (object, schema) => {
                    const fields = Object.entries(object).map(([name, value]) => {
                        if (schema.fields[name].kind === 'schema-nested') {
                            return `${name}: ${object2string(value, schema.fields[name].getEntityType().entitySchema)}`;
                        }
                        return entry2field(name, value);
                    });
                    return `{ ${fields.join(', ')} }`;
                };
                return `${this.constructor.name} ${object2string(this, schema)}`;
            }
            debugLog() { }
        };
        // Override the name property to use the name of the entity given in the schema.
        Object.defineProperty(clazz, 'name', { value: schema.name });
        return clazz;
    }
    static id(entity) {
        return getInternals(entity).getId();
    }
    static storageKey(entity) {
        return getInternals(entity).getStorageKey();
    }
    static creationTimestamp(entity) {
        return Storable.creationTimestamp(entity);
    }
    static expirationTimestamp(entity) {
        return Storable.expirationTimestamp(entity);
    }
    static entityClass(entity) {
        return getInternals(entity).getEntityClass();
    }
    static isIdentified(entity) {
        return getInternals(entity).isIdentified();
    }
    static identify(entity, identifier, storageKey, creationTimestamp, expirationTimestamp) {
        getInternals(entity).identify(identifier, storageKey, creationTimestamp ? new Date(creationTimestamp) : undefined, expirationTimestamp ? new Date(expirationTimestamp) : undefined);
        return entity;
    }
    static createIdentity(entity, parentId, idGenerator, storageKey, ttl) {
        getInternals(entity).createIdentity(parentId, idGenerator, storageKey, ttl);
    }
    static isMutable(entity) {
        return getInternals(entity).isMutable();
    }
    static makeImmutable(entity) {
        getInternals(entity).makeImmutable();
    }
    static mutate(entity, mutation) {
        getInternals(entity).mutate(mutation);
    }
    static toLiteral(entity) {
        return getInternals(entity).toLiteral();
    }
    static dataClone(entity) {
        return getInternals(entity).dataClone();
    }
    static serialize(entity) {
        return getInternals(entity).serialize();
    }
    // Because the internals object is non-enumerable, console.log(entity) in Node only shows the
    // schema-based fields; use this function to log a more complete record of the entity in tests.
    // Chrome's console.log already shows the internals object so that's usually sufficient for
    // debugging, but this function can still be useful for logging a snapshot of an entity that
    // is later modified.
    static debugLog(entity) {
        getInternals(entity).debugLog();
    }
}
entity_Entity.sanitizeEntry = null;
entity_Entity.validateFieldAndTypes = null;
function sanitizeAndApply(target, data, schema, frontend) {
    const temp = { ...target };
    for (const [name, value] of Object.entries(data)) {
        const sanitizedValue = entity_Entity.sanitizeEntry(schema.fields[name], value, name, frontend);
        entity_Entity.validateFieldAndTypes(name, sanitizedValue, schema);
        temp[name] = sanitizedValue;
    }
    if (Flags.enforceRefinements) {
        const exception = refineData(data, schema);
        if (exception) {
            frontend.reportExceptionInHost(exception);
            return;
        }
    }
    // update target after ensuring that the data conforms to the refinements (if enforced)
    for (const [name, value] of Object.entries(temp)) {
        target[name] = value;
    }
}
function refineData(entity, schema) {
    for (const [name, value] of Object.entries(entity)) {
        const refDict = { [name]: value };
        const ref = schema.fields[name].refinement;
        if (ref && !ref.validateData(refDict)) {
            return new AuditException(new Error(`Entity schema field '${name}' does not conform to the refinement ${ref}`), 'refineData');
        }
    }
    const ref = schema.refinement;
    if (ref && !ref.validateData(entity)) {
        return new AuditException(new Error(`Entity data does not conform to the refinement ${ref}`), 'refineData');
    }
    return null;
}
//# sourceMappingURL=entity.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/random.js
/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class RNG {
}
/**
 * A basic random number generator using Math.random();
 */
class MathRandomRNG extends RNG {
    next() {
        return Math.random();
    }
}
// Singleton Pattern
const random = new MathRandomRNG();
class Random {
    static next() {
        return random.next();
    }
}
//# sourceMappingURL=random.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/id.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * Generates new IDs which are rooted in the current session. Only one IdGenerator should be instantiated for each running Arc, and all of the
 * IDs created should be created using that same IdGenerator instance.
 */
class id_IdGenerator {
    /** Use the newSession factory method instead. */
    constructor(currentSessionId) {
        this._nextComponentId = 0;
        this._currentSessionId = currentSessionId;
    }
    /** Generates a new random session ID to use when creating new IDs. */
    static newSession() {
        const sessionId = Math.floor(Random.next() * Math.pow(2, 50)) + '';
        return new id_IdGenerator(sessionId);
    }
    /**
     * Intended only for testing the IdGenerator class itself. Lets you specify the session ID manually. Prefer using the real
     * IdGenerator.newSession() method when testing other classes.
     */
    static createWithSessionIdForTesting(sessionId) {
        return new id_IdGenerator(sessionId);
    }
    newArcId(name) {
        return ArcId._newArcIdInternal(this._currentSessionId, name);
    }
    /**
     * Creates a new ID, as a child of the given parentId. The given subcomponent will be appended to the component hierarchy of the given ID, but
     * the generator's random session ID will be used as the ID's root.
     */
    newChildId(parentId, subcomponent = '') {
        // Append (and increment) a counter to the subcomponent, to ensure that it is unique.
        subcomponent += this._nextComponentId++;
        return Id._newIdInternal(this._currentSessionId, [...parentId.idTree, subcomponent]);
    }
    get currentSessionIdForTesting() {
        return this._currentSessionId;
    }
}
/**
 * An immutable object consisting of two components: a root, and an idTree. The root is the session ID from the particular session in which the
 * ID was constructed (see the IdGenerator class). The idTree is a list of subcomponents, forming a hierarchy of IDs (child IDs are created by
 * appending subcomponents to their parent ID's idTree).
 */
class Id {
    /** Protected constructor. Use IdGenerator to create new IDs instead. */
    constructor(root, idTree = []) {
        /** The components of the idTree. */
        this.idTree = [];
        this.root = root;
        this.idTree = idTree;
    }
    /** Creates a new ID. Use IdGenerator to create new IDs instead. */
    static _newIdInternal(root, idTree = []) {
        return new Id(root, idTree);
    }
    /** Parses a string representation of an ID (see toString). */
    static fromString(str) {
        const bits = str.split(':');
        if (bits[0].startsWith('!')) {
            const root = bits[0].slice(1);
            const idTree = bits.slice(1).filter(component => component.length > 0);
            return new Id(root, idTree);
        }
        else {
            return new Id('', bits);
        }
    }
    /** Returns the full ID string. */
    toString() {
        return `!${this.root}:${this.idTree.join(':')}`;
    }
    /** Returns the idTree as as string (without the root). */
    idTreeAsString() {
        return this.idTree.join(':');
    }
    equal(id) {
        if (id.root !== this.root || id.idTree.length !== this.idTree.length) {
            return false;
        }
        for (let i = 0; i < id.idTree.length; i++) {
            if (id.idTree[i] !== this.idTree[i]) {
                return false;
            }
        }
        return true;
    }
}
class ArcId extends Id {
    /** Creates a new Arc ID. Use IdGenerator to create new IDs instead. */
    static _newArcIdInternal(root, name) {
        return new ArcId(root, [name]);
    }
    /** Creates a new Arc ID with the given name. For convenience in unit testing only; otherwise use IdGenerator to create new IDs instead. */
    static newForTest(id) {
        return id_IdGenerator.newSession().newArcId(id);
    }
}
//# sourceMappingURL=id.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/handle.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */









/**
 * Base class for Handles.
 */
// TODO(shans): reduce required interface for Particle argument so that it's just an event target for updates.
// TODO(shans): can actor("key" in constructor) always be automatically derived from idGenerator?
class handle_Handle {
    constructor(key, storageProxy, idGenerator, particle, canRead, canWrite, name) {
        this.key = key;
        this.name = name;
        this.storageProxy = storageProxy;
        this.idGenerator = idGenerator;
        this.particle = particle;
        this.options = {
            keepSynced: true,
            notifySync: true,
            notifyUpdate: true,
            notifyDesync: false,
        };
        this.canRead = canRead;
        this.canWrite = canWrite;
        // TODO(shans): Be more principled about how to determine whether this is an
        // immediate mode handle or a standard handle.
        if (this.type instanceof type_EntityType) {
            this.serializer = new handle_PreEntityMutationSerializer(this.type, (e) => { this.createIdentityFor(e); }, this.storageProxy.getStorageFrontend());
        }
        else if (this.type.getContainedType() instanceof type_EntityType) {
            this.serializer = new handle_PreEntityMutationSerializer(this.type.getContainedType(), (e) => { this.createIdentityFor(e); }, this.storageProxy.getStorageFrontend());
        }
        else if (this.type.getContainedType() instanceof type_ReferenceType) {
            this.serializer = new ReferenceSerializer(this.type.getContainedType(), this.storageProxy.getStorageFrontend());
        }
        else {
            this.serializer = new handle_ParticleSpecSerializer(() => this.idGenerator.newChildId(Id.fromString(this._id)).toString());
        }
        this.storageProxy.registerHandle(this);
    }
    //TODO: this is used by multiplexer-dom-particle.ts, it probably won't work with this kind of store.
    get storage() {
        return this.storageProxy;
    }
    get type() {
        return this.storageProxy.type;
    }
    // TODO: after NG migration, this can be renamed to something like "apiChannelId()".
    get _id() {
        return this.storageProxy.storeInfo.id;
    }
    createIdentityFor(entity) {
        entity_Entity.createIdentity(entity, Id.fromString(this._id), this.idGenerator, this.storageProxy.storageKey, this.storageProxy.ttl);
    }
    toManifestString() {
        return `'${this._id}'`;
    }
    get entityClass() {
        if (this.type instanceof type_EntityType) {
            return entity_Entity.createEntityClass(this.type.entitySchema, this.storageProxy.getStorageFrontend());
        }
        const containedType = this.type.getContainedType();
        if (containedType instanceof type_EntityType) {
            return entity_Entity.createEntityClass(containedType.entitySchema, this.storageProxy.getStorageFrontend());
        }
        return null;
    }
    // `options` may contain any of:
    // - keepSynced (bool): load full data on startup, maintain data in proxy and resync as required
    // - notifySync (bool): if keepSynced is true, call onHandleSync when the full data is received
    // - notifyUpdate (bool): if keepSynced is true, call onHandleUpdate for every change event received
    //     if the proxy is currently synchronized (i.e. updates received when desynced are ignored); if
    //     keepSynced is false, just notify for all updates
    // - notifyDesync (bool): if keepSynced is true, call onHandleDesync when desync is detected.
    configure(options) {
        external_assert_default()(this.canRead, 'configure can only be called on readable Handles');
        this.options = { ...this.options, ...options };
    }
    reportUserExceptionInHost(exception, particle, method) {
        this.storageProxy.reportExceptionInHost(new UserException(exception, method, this.key, particle.spec ? particle.spec.name : ''));
    }
    async onDesync() {
        external_assert_default()(this.canRead, 'onSync should not be called for non-readable handles');
        if (this.particle) {
            await this.particle.callOnHandleDesync(this, e => this.reportUserExceptionInHost(e, this.particle, 'onHandleDesync'));
        }
    }
    disable(particle) {
        this.storageProxy.deregisterHandle(this);
        this.storageProxy = new storage_proxy_NoOpStorageProxy();
    }
}
/**
 * This serializer allows particles to manipulate collections and singletons of Entities
 * before the Entity Mutation API (and CRDT stack) is live. Once entity mutation is
 * available then this class will be deprecated and removed, and CollectionHandle / SingletonHandle
 * will become wrappers that reconstruct collections from a collection of references and
 * multiple entity stacks.
 */
class handle_PreEntityMutationSerializer {
    constructor(type, createIdentityFor, frontend) {
        if (type instanceof type_EntityType) {
            this.entityClass = entity_Entity.createEntityClass(type.entitySchema, frontend);
            this.createIdentityFor = createIdentityFor;
        }
        else {
            throw new Error(`can't construct handle for entity mutation if type is not an entity type`);
        }
    }
    serialize(entity) {
        this.ensureHasId(entity);
        const serialization = entity[SYMBOL_INTERNALS].serialize();
        return serialization;
    }
    ensureHasId(entity) {
        if (!entity_Entity.isIdentified(entity)) {
            this.createIdentityFor(entity);
        }
    }
    deserialize(value, storageKey) {
        const { id, creationTimestamp, expirationTimestamp, rawData } = value;
        const entity = new this.entityClass(rawData);
        entity_Entity.identify(entity, id, storageKey, creationTimestamp, expirationTimestamp);
        return entity;
    }
}
class ReferenceSerializer {
    constructor(type, frontend) {
        this.type = type;
        this.frontend = frontend;
    }
    serialize(reference) {
        return reference.dataClone();
    }
    deserialize(value) {
        return handle_Handle.makeReference(value, this.type, this.frontend);
    }
    ensureHasId(reference) {
        // references must always have IDs
    }
}
/* Pass through the object to the storage stack, checking that it has an ID. */
// tslint:disable-next-line no-any
class handle_ParticleSpecSerializer {
    constructor(createIdentityFor) {
        this.createIdentityFor = createIdentityFor;
    }
    serialize(value) {
        // TODO(shanestephens): There should be IDs for particleSpecs that we use here at some point.
        const id = this.createIdentityFor();
        return { id, rawData: value.toLiteral() };
    }
    ensureHasId(entity) {
        // ID is checked in serialize method.
    }
    deserialize(value) {
        return particle_spec_ParticleSpec.fromLiteral(value.rawData);
    }
}
/**
 * A handle on a set of Entity data. Note that, as a set, a Collection can only
 * contain a single version of an Entity for each given ID. Further, no order is
 * implied by the set.
 */
// TODO(shanestephens): we can't guarantee the safety of this stack (except by the Type instance matching) - do we need the T
// parameter here?
class handle_CollectionHandle extends handle_Handle {
    async fetch(id) {
        if (!this.canRead) {
            throw new Error('Handle not readable');
        }
        const values = await this.toCRDTList();
        return this.serializer.deserialize(values.find(element => element.id === id), this.storageProxy.storageKey);
    }
    async add(entity) {
        if (!this.canWrite) {
            throw new Error('Handle not writeable');
        }
        this.serializer.ensureHasId(entity);
        const versionMap = this.storageProxy.versionCopy();
        versionMap[this.key] = (versionMap[this.key] || 0) + 1;
        const op = {
            type: CollectionOpTypes.Add,
            added: this.serializer.serialize(entity),
            actor: this.key,
            versionMap,
        };
        return this.storageProxy.applyOp(op);
    }
    async addFromData(entityData) {
        const entity = new this.entityClass(entityData);
        const result = await this.add(entity);
        return result ? entity : null;
    }
    async addMultiple(entities) {
        return Promise.all(entities.map(e => this.add(e))).then(array => array.every(Boolean));
    }
    async addMultipleFromData(entityData) {
        return Promise.all(entityData.map(e => this.addFromData(e)));
    }
    async remove(entity) {
        if (!this.canWrite) {
            throw new Error('Handle not writeable');
        }
        const op = {
            type: CollectionOpTypes.Remove,
            removed: this.serializer.serialize(entity),
            actor: this.key,
            versionMap: this.storageProxy.versionCopy(),
        };
        return this.storageProxy.applyOp(op);
    }
    async clear() {
        if (!this.canWrite) {
            throw new Error('Handle not writeable');
        }
        const values = await this.toCRDTList();
        for (const value of values) {
            const removeOp = {
                type: CollectionOpTypes.Remove,
                removed: value,
                actor: this.key,
                versionMap: this.storageProxy.versionCopy(),
            };
            if (!this.storageProxy.applyOp(removeOp)) {
                return false;
            }
        }
        return true;
    }
    async toList() {
        if (!this.canRead) {
            throw new Error('Handle not readable');
        }
        const list = await this.toCRDTList();
        return list.map(entry => this.serializer.deserialize(entry, this.storageProxy.storageKey));
    }
    async toCRDTList() {
        return [...await this.storageProxy.getParticleView()];
    }
    async fetchAll() {
        if (!this.canRead) {
            throw new Error('Handle not readable');
        }
        const list = await this.toCRDTList();
        return new Set(list.map(entry => this.serializer.deserialize(entry, this.storageProxy.storageKey)));
    }
    /**
     * onUpdate, onSync and onDesync *are async functions*, because they invoke callOnHandleUpdate,
     * which is async.
     *
     * However, they *must not introduce await points* before invoking callOnHandleUpdate, as
     * if they do there is a risk that they will be reordered.
     */
    async onUpdate(op) {
        external_assert_default()(this.canRead, 'onUpdate should not be called for non-readable handles');
        // FastForward cannot be expressed in terms of ordered added/removed, so pass a full model to
        // the particle.
        if (op.type === CollectionOpTypes.FastForward) {
            return this.onSync(this.storageProxy.getParticleViewAssumingSynchronized());
        }
        // Pass the change up to the particle.
        const update = { originator: ('actor' in op && this.key === op.actor) };
        if (op.type === CollectionOpTypes.Add) {
            update.added = [this.serializer.deserialize(op.added, this.storageProxy.storageKey)];
        }
        if (op.type === CollectionOpTypes.Remove) {
            update.removed = [this.serializer.deserialize(op.removed, this.storageProxy.storageKey)];
        }
        if (this.particle) {
            await this.particle.callOnHandleUpdate(this /*handle*/, update, e => this.reportUserExceptionInHost(e, this.particle, 'onHandleUpdate'));
        }
    }
    async onSync(model) {
        external_assert_default()(this.canRead, 'onSync should not be called for non-readable handles');
        if (this.particle) {
            await this.particle.callOnHandleSync(this /*handle*/, [...model].map(entry => this.serializer.deserialize(entry, this.storageProxy.storageKey)), e => this.reportUserExceptionInHost(e, this.particle, 'onHandleSync'));
        }
    }
}
/**
 * A handle on a single entity.
 */
class handle_SingletonHandle extends handle_Handle {
    async set(entity) {
        if (!this.canWrite) {
            throw new Error('Handle not writeable');
        }
        this.serializer.ensureHasId(entity);
        const versionMap = this.storageProxy.versionCopy();
        versionMap[this.key] = (versionMap[this.key] || 0) + 1;
        const op = {
            type: SingletonOpTypes.Set,
            value: this.serializer.serialize(entity),
            actor: this.key,
            versionMap,
        };
        return this.storageProxy.applyOp(op);
    }
    async setFromData(entityData) {
        const entity = new this.entityClass(entityData);
        const result = await this.set(entity);
        return result ? entity : null;
    }
    async clear() {
        if (!this.canWrite) {
            throw new Error('Handle not writeable');
        }
        // Sync the proxy before clearing in order to ensure we can clear values set by other actors.
        // TODO: if we expose wether the storage proxy is synchronized to the handle,
        // we could avoid introducing an unnecessary await here.
        await this.storageProxy.getParticleView();
        // Issue clear op.
        const op = {
            type: SingletonOpTypes.Clear,
            actor: this.key,
            versionMap: this.storageProxy.versionCopy(),
        };
        return this.storageProxy.applyOp(op);
    }
    async fetch() {
        if (!this.canRead) {
            throw new Error('Handle not readable');
        }
        const value = await this.storageProxy.getParticleView();
        return value == null ? null : this.serializer.deserialize(value, this.storageProxy.storageKey);
    }
    /**
     * onUpdate, onSync and onDesync *are async functions*, because they invoke callOnHandleUpdate,
     * which is async.
     *
     * However, they *must not introduce await points* before invoking callOnHandleUpdate, as
     * if they do there is a risk that they will be reordered.
     */
    async onUpdate(op) {
        external_assert_default()(this.canRead, 'onUpdate should not be called for non-readable handles');
        if (op.type === SingletonOpTypes.FastForward) {
            throw new Error('Unexpected FastForward operation.');
        }
        // Pass the change up to the particle.
        const update = { originator: (this.key === op.actor) };
        if (op.type === SingletonOpTypes.Set) {
            update.data = this.serializer.deserialize(op.value, this.storageProxy.storageKey);
        }
        // Nothing else to add (beyond oldData) for SingletonOpTypes.Clear.
        if (this.particle) {
            await this.particle.callOnHandleUpdate(this /*handle*/, update, e => this.reportUserExceptionInHost(e, this.particle, 'onHandleUpdate'));
        }
    }
    async onSync(model) {
        external_assert_default()(this.canRead, 'onSync should not be called for non-readable handles');
        if (this.particle) {
            await this.particle.callOnHandleSync(this /*handle*/, model == null ? model : this.serializer.deserialize(model, this.storageProxy.storageKey), e => this.reportUserExceptionInHost(e, this.particle, 'onHandleSync'));
        }
    }
}
/**
 * A handle on an entity.
 */
class handle_EntityHandle extends handle_Handle {
    constructor(key, storageProxy, idGenerator, particle, canRead, canWrite, muxId, name) {
        super(key, storageProxy, idGenerator, particle, canRead, canWrite, name);
        this.muxId = muxId;
    }
    async fetch() {
        const value = await this.storageProxy.getParticleView();
        if (value == null) {
            return null;
        }
        const serializedEntity = this.createSerializedEntity(value);
        return this.serializer.deserialize(serializedEntity, this.storageProxy.storageKey);
    }
    async mutate(mutation) {
        if (!this.canWrite)
            throw new Error('Handle not writable');
        let newData;
        const rawEntity = await this.storageProxy.getParticleView();
        const serializedEntity = rawEntity != null ? this.createSerializedEntity(rawEntity).rawData : {};
        if (typeof mutation === 'function') {
            newData = rawEntity != null ? this.createSerializedEntity(rawEntity).rawData : {};
            mutation(newData);
        }
        else {
            newData = mutation;
        }
        let versionMap = this.storageProxy.versionCopy();
        const updateVersionMap = () => {
            const updatedVersionMap = {};
            for (const [k, v] of Object.entries(versionMap)) {
                updatedVersionMap[k] = v;
            }
            updatedVersionMap[this.key] = (versionMap[this.key] || 0) + 1;
            versionMap = updatedVersionMap;
        };
        const operations = [];
        for (const field of Object.keys(rawEntity.singletons)) {
            if (serializedEntity[field] !== newData[field]) {
                if (newData[field] === null) {
                    // Clear OP
                    operations.push({ type: EntityOpTypes.Clear, field, actor: this.key, versionMap });
                }
                else {
                    // Set OP
                    updateVersionMap();
                    const referenceableValue = rawEntity.singletons[field]['value'] == undefined ? newData[field] : { id: newData[field].toString(), value: newData[field] };
                    operations.push({ type: EntityOpTypes.Set, field, value: referenceableValue, actor: this.key, versionMap });
                }
            }
        }
        for (const field of Object.keys(rawEntity.collections)) {
            const newDataSet = new Set(newData[field]);
            for (const value of new Set([...newData[field], ...serializedEntity[field]])) {
                if (!newDataSet.has(value)) {
                    // Remove Op
                    const referenceableValue = value.id == undefined ? { id: value.toString(), value } : value;
                    operations.push({ type: EntityOpTypes.Remove, field, removed: referenceableValue, actor: this.key, versionMap });
                }
                if (!serializedEntity[field].has(value)) {
                    // Add Op
                    updateVersionMap();
                    const referenceableValue = value.id == undefined ? { id: value.toString(), value } : value;
                    operations.push({ type: EntityOpTypes.Add, field, added: referenceableValue, actor: this.key, versionMap });
                }
            }
        }
        return Promise.all(operations.map(op => this.storageProxy.applyOp(op)));
    }
    createSerializedEntity(rawEntity) {
        const serializedEntity = { id: this.muxId, rawData: {} };
        // For primitives, only the value propery of the Referenceable should be included in the rawData of the serializedEntity.
        for (const [key, value] of Object.entries(rawEntity.singletons)) {
            if (value !== null && value['value'] !== undefined) {
                serializedEntity.rawData[key] = value['value'];
            }
            else {
                serializedEntity.rawData[key] = value;
            }
        }
        for (const [key, value] of Object.entries(rawEntity.collections)) {
            serializedEntity.rawData[key] = new Set();
            for (const elem of value.values()) {
                if (elem['value'] !== undefined) {
                    serializedEntity.rawData[key].add(elem['value']);
                }
                else {
                    serializedEntity.rawData[key].add(elem);
                }
            }
        }
        return serializedEntity;
    }
    onUpdate(update) { }
    async onSync(model) {
        external_assert_default()(this.canRead, 'onSync should not be called for non-readable handles');
        if (this.particle) {
            const serializedEntity = this.createSerializedEntity(model);
            await this.particle.callOnHandleSync(this, model == null ? model : this.serializer.deserialize(serializedEntity, this.storageProxy.storageKey), e => { this.reportUserExceptionInHost(e, this.particle, 'onHandleSync'); });
        }
    }
}
//# sourceMappingURL=handle.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/drivers/driver.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var Exists;
(function (Exists) {
    Exists[Exists["ShouldExist"] = 0] = "ShouldExist";
    Exists[Exists["ShouldCreate"] = 1] = "ShouldCreate";
    Exists[Exists["MayExist"] = 2] = "MayExist";
})(Exists || (Exists = {}));
// Interface that drivers must support.
//
// Note the threading of a version number here; each model provided
// by the driver to the Store (using the receiver) is paired with a version,
// as is each model sent from the Store to the driver (using Driver.send()).
//
// This threading is used to track whether driver state has changed while
// the Store is processing a particular model. send() should always fail
// if the version isn't exactly 1 greater than the current internal version.
class Driver {
    constructor(storageKey, exists) {
        this.storageKey = storageKey;
        this.exists = exists;
    }
}
//# sourceMappingURL=driver.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/entity-handle-factory.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

class entity_handle_factory_EntityHandleFactory {
    constructor(storageProxyMuxer, name) {
        this.storageProxyMuxer = storageProxyMuxer;
        this.name = name;
    }
    getHandle(muxId) {
        const storageProxy = this.storageProxyMuxer.getStorageProxy(muxId);
        const frontend = storageProxy.getStorageFrontend();
        return new handle_EntityHandle(frontend.generateID(), storageProxy, frontend.idGenerator, null, true, true, muxId);
    }
}
//# sourceMappingURL=entity-handle-factory.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/storage-proxy-muxer.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */



class storage_proxy_muxer_StorageProxyMuxer {
    constructor(storageEndpoint) {
        this.storageEndpoint = storageEndpoint;
        this.storageProxies = new BiMap();
        this.callbacks = {};
        this.storageKey = this.storageEndpoint.storeInfo.storageKey.toString();
        this.type = this.storageEndpoint.storeInfo.type;
    }
    get storeInfo() { return this.storageEndpoint.storeInfo; }
    getStorageProxy(muxId) {
        this.storageEndpoint.setCallback(this.onMessage.bind(this));
        if (!this.storageProxies.hasL(muxId)) {
            this.storageProxies.set(muxId, new storage_proxy_StorageProxy(this.createStorageCommunicationEndpoint(muxId, this.storageEndpoint, this)));
        }
        return this.storageProxies.getL(muxId);
    }
    createStorageCommunicationEndpoint(muxId, storageEndpoint, storageProxyMuxer) {
        return {
            get storeInfo() {
                return storageEndpoint.storeInfo;
            },
            async onProxyMessage(message) {
                message.muxId = muxId;
                await storageEndpoint.onProxyMessage(message);
            },
            setCallback(callback) {
                storageProxyMuxer.callbacks[muxId] = callback;
            },
            reportExceptionInHost(exception) {
                storageEndpoint.reportExceptionInHost(exception);
            },
            getStorageFrontend() {
                return storageEndpoint.getStorageFrontend();
            }
        };
    }
    async onMessage(message) {
        external_assert_default()(message.muxId != null);
        if (!this.callbacks[message.muxId]) {
            throw new Error('callback has not been set');
        }
        noAwait(this.callbacks[message.muxId](message));
    }
}
//# sourceMappingURL=storage-proxy-muxer.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/storage.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */






function storage_handleType(handle) {
    return handle.type;
}
async function newHandle(storeInfo, arc, options = {}) {
    storeInfo.exists = Exists.MayExist;
    return handleForStoreInfo(storeInfo, arc, options);
}
function handleForActiveStore(storeInfo, arc, options = {}) {
    const type = options.type || storeInfo.type;
    const storageKey = storeInfo.storageKey.toString();
    const idGenerator = arc.idGenerator;
    const particle = options.particle || null;
    const canRead = (options.canRead != undefined) ? options.canRead : true;
    const canWrite = (options.canWrite != undefined) ? options.canWrite : true;
    const name = options.name || null;
    const generateID = arc.generateID ? () => arc.generateID().toString() : () => '';
    if (storeInfo.type instanceof type_MuxType) {
        const muxStoreInfo = storeInfo;
        const proxyMuxer = new storage_proxy_muxer_StorageProxyMuxer(arc.storageService.getStorageEndpoint(muxStoreInfo));
        return new entity_handle_factory_EntityHandleFactory(proxyMuxer);
    }
    else {
        const proxy = new storage_proxy_StorageProxy(arc.storageService.getStorageEndpoint(storeInfo), options.ttl);
        if (type instanceof type_SingletonType) {
            // tslint:disable-next-line: no-any
            return new handle_SingletonHandle(generateID(), proxy, idGenerator, particle, canRead, canWrite, name);
        }
        else {
            // tslint:disable-next-line: no-any
            return new handle_CollectionHandle(generateID(), proxy, idGenerator, particle, canRead, canWrite, name);
        }
    }
}
async function handleForStoreInfo(storeInfo, arc, options) {
    await arc.storageService.getActiveStore(storeInfo);
    return handleForActiveStore(storeInfo, arc, options);
}
//# sourceMappingURL=storage.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/description.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */




class description_Description {
    constructor(storeDescById = {}, 
    // TODO(mmandlis): replace Particle[] with serializable json objects.
    arcRecipes, particleDescriptions = []) {
        this.storeDescById = storeDescById;
        this.arcRecipes = arcRecipes;
        this.particleDescriptions = particleDescriptions;
    }
    static async createForPlan(arc, plan) {
        const allParticles = plan.particles;
        const particleDescriptions = await description_Description.initDescriptionHandles(allParticles, arc);
        const storeDescById = {};
        for (const { id } of plan.handles) {
            const store = arc.findStoreById(id);
            if (store) {
                storeDescById[id] = arc.getStoreDescription(store);
            }
        }
        // ... and pass to the private constructor.
        return new description_Description(storeDescById, [{ patterns: plan.patterns, particles: plan.particles }], particleDescriptions);
    }
    /**
     * Create a new Description object for the given Arc with an
     * optional Relevance object.
     */
    static async create(arc, relevance) {
        // Execute async related code here
        const allParticles = [].concat(...arc.allDescendingArcs.map(arc => arc.activeRecipe.particles));
        const particleDescriptions = await description_Description.initDescriptionHandles(allParticles, arc, relevance);
        const storeDescById = {};
        for (const { id } of arc.activeRecipe.handles) {
            const store = arc.findStoreById(id);
            if (store) {
                storeDescById[id] = arc.getStoreDescription(store);
            }
        }
        // ... and pass to the private constructor.
        return new description_Description(storeDescById, arc.recipeDeltas, particleDescriptions);
    }
    getArcDescription(formatterClass = description_formatter_DescriptionFormatter) {
        const patterns = [].concat(...this.arcRecipes.map(recipe => recipe.patterns));
        const particles = [].concat(...this.arcRecipes.map(recipe => recipe.particles));
        const desc = new (formatterClass)(this.particleDescriptions, this.storeDescById).getDescription({
            patterns,
            particles
        });
        if (desc) {
            return desc;
        }
        return undefined;
    }
    getRecipeSuggestion(formatterClass = description_formatter_DescriptionFormatter) {
        const formatter = new (formatterClass)(this.particleDescriptions, this.storeDescById);
        return formatter.getDescription(this.arcRecipes[this.arcRecipes.length - 1]);
    }
    getHandleDescription(recipeHandle) {
        external_assert_default()(recipeHandle.connections.length > 0, 'handle has no connections?');
        const formatter = new description_formatter_DescriptionFormatter(this.particleDescriptions, this.storeDescById);
        formatter.excludeValues = true;
        return formatter.getHandleDescription(recipeHandle);
    }
    static getAllTokens(pattern) {
        const allTokens = [];
        const tokens = pattern.match(description_formatter_DescriptionFormatter.tokensRegex);
        for (let i = 0; i < tokens.length; ++i) {
            allTokens[i] = tokens[i].match(description_formatter_DescriptionFormatter.tokensInnerRegex)[1].split('.');
        }
        return allTokens;
    }
    static async initDescriptionHandles(allParticles, arc, relevance) {
        return Promise.all(allParticles.map(particle => description_Description._createParticleDescription(particle, arc, relevance)));
    }
    static async _createParticleDescription(particle, arc, relevance) {
        let pDesc = {
            _particle: particle,
            _connections: {}
        };
        if (relevance) {
            pDesc._rank = relevance.calcParticleRelevance(particle);
        }
        const descByName = await description_Description._getPatternByNameFromDescriptionHandle(particle, arc);
        pDesc = { ...pDesc, ...descByName };
        pDesc.pattern = pDesc.pattern || particle.spec.pattern;
        for (const handleConn of Object.values(particle.connections)) {
            const specConn = particle.spec.handleConnectionMap.get(handleConn.name);
            const pattern = descByName[handleConn.name] || specConn.pattern;
            pDesc._connections[handleConn.name] = {
                pattern,
                _handleConn: handleConn,
                value: await description_Description._prepareStoreValue(handleConn.handle.id, arc)
            };
        }
        return pDesc;
    }
    static async _getPatternByNameFromDescriptionHandle(particle, arc) {
        const descriptionConn = particle.connections['descriptions'];
        if (descriptionConn && descriptionConn.handle && descriptionConn.handle.id) {
            const descStore = arc.findStoreById(descriptionConn.handle.id);
            if (descStore) {
                const descHandle = await handleForStoreInfo(descStore, arc);
                const descByName = {};
                for (const d of await descHandle.toList()) {
                    descByName[d.key] = d.value;
                }
                return descByName;
            }
        }
        return {};
    }
    static async _prepareStoreValue(storeId, arc) {
        if (!arc) {
            return null;
        }
        const store = arc.findStoreById(storeId);
        if (!store) {
            return undefined;
        }
        if (store.type instanceof type_SingletonType && store.type.getContainedType() instanceof type_EntityType) {
            const handle = await handleForStoreInfo(store, arc);
            const entityValue = await handle.fetch();
            if (entityValue) {
                const schema = store.type.getEntitySchema();
                const valueDescription = schema ? schema.description.value : undefined;
                return { entityValue, valueDescription };
            }
        }
        else if (store.type instanceof type_SingletonType && store.type.getContainedType() instanceof type_InterfaceType) {
            const handle = await handleForStoreInfo(store, arc);
            const interfaceValue = await handle.fetch();
            if (interfaceValue) {
                return { interfaceValue };
            }
        }
        else if (store.type instanceof type_CollectionType) {
            const handle = await handleForStoreInfo(store, arc);
            const values = await handle.toList();
            if (values && values.length > 0) {
                return { collectionValues: values };
            }
        }
        return undefined;
    }
}
//# sourceMappingURL=description.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/gen/runtime/manifest-parser.js
// tslint:disable:no-any
// tslint:disable: only-arrow-functions
// tslint:disable: max-line-length
// tslint:disable: trailing-comma
// tslint:disable: interface-name
// tslint:disable: switch-default
// tslint:disable: object-literal-shorthand
// Generated by PEG.js v. 0.10.0 (ts-pegjs plugin v. 0.2.6 )
//
// https://pegjs.org/   https://github.com/metadevpro/ts-pegjs
// DO NOT EDIT, AUTOGENERATED from src/runtime/manifest-parser.pegjs


class manifest_parser_SyntaxError extends Error {
    constructor(message, expected, found, location) {
        super();
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, manifest_parser_SyntaxError);
        }
    }
    static buildMessage(expected, found) {
        function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s) {
            return s
                .replace(/\\/g, "\\\\")
                .replace(/"/g, "\\\"")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, (ch) => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x" + hex(ch));
        }
        function classEscape(s) {
            return s
                .replace(/\\/g, "\\\\")
                .replace(/\]/g, "\\]")
                .replace(/\^/g, "\\^")
                .replace(/-/g, "\\-")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, (ch) => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x" + hex(ch));
        }
        function describeExpectation(expectation) {
            switch (expectation.type) {
                case "literal":
                    return "\"" + literalEscape(expectation.text) + "\"";
                case "class":
                    const escapedParts = expectation.parts.map((part) => {
                        return Array.isArray(part)
                            ? classEscape(part[0]) + "-" + classEscape(part[1])
                            : classEscape(part);
                    });
                    return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
                case "any":
                    return "any character";
                case "end":
                    return "end of input";
                case "other":
                    return expectation.description;
            }
        }
        function describeExpected(expected1) {
            const descriptions = expected1.map(describeExpectation);
            let i;
            let j;
            descriptions.sort();
            if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                    if (descriptions[i - 1] !== descriptions[i]) {
                        descriptions[j] = descriptions[i];
                        j++;
                    }
                }
                descriptions.length = j;
            }
            switch (descriptions.length) {
                case 1:
                    return descriptions[0];
                case 2:
                    return descriptions[0] + " or " + descriptions[1];
                default:
                    return descriptions.slice(0, -1).join(", ")
                        + ", or "
                        + descriptions[descriptions.length - 1];
            }
        }
        function describeFound(found1) {
            return found1 ? "\"" + literalEscape(found1) + "\"" : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    }
}
function peg$parse(input, options) {
    options = options !== undefined ? options : {};
    const peg$FAILED = {};
    const peg$startRuleFunctions = { Manifest: peg$parseManifest };
    let peg$startRuleFunction = peg$parseManifest;
    const peg$c0 = function (items) {
        resetPaxelModes();
        const result = items.map(item => {
            const annotations = item[0];
            const manifestItem = item[2];
            manifestItem.annotationRefs = annotations.annotationRefs;
            return manifestItem;
        });
        checkNormal(result);
        return result;
    };
    const peg$c1 = function (annotationRefs) {
        return toAstNode({
            kind: 'annotation',
            annotationRefs: annotationRefs.map(aRef => aRef[1]),
        });
    };
    const peg$c2 = "resource";
    const peg$c3 = peg$literalExpectation("resource", false);
    const peg$c4 = function (name, body) {
        return toAstNode({
            kind: 'resource',
            name,
            data: body
        });
    };
    const peg$c5 = "start";
    const peg$c6 = peg$literalExpectation("start", false);
    const peg$c7 = function () { startIndent = indent; };
    const peg$c8 = function (lines) {
        return lines.map(line => line[0].substring(startIndent.length) + line[1]).join('');
    };
    const peg$c9 = /^[^\n]/;
    const peg$c10 = peg$classExpectation(["\n"], true, false);
    const peg$c11 = function () { return text(); };
    const peg$c12 = "store";
    const peg$c13 = peg$literalExpectation("store", false);
    const peg$c14 = "of";
    const peg$c15 = peg$literalExpectation("of", false);
    const peg$c16 = "!!";
    const peg$c17 = peg$literalExpectation("!!", false);
    const peg$c18 = function (name, type, id, originalId, version, tags, source, items) {
        items = optional(items, extractIndented, []);
        let description = null;
        const claims = [];
        for (const item of items) {
            if (item[0] === 'description') {
                if (description) {
                    error('You cannot provide more than one description.');
                }
                description = item[2];
            }
            else if (item['kind'] === 'manifest-storage-claim') {
                claims.push(item);
            }
            else {
                error(`Unknown ManifestStorageItem: ${item}`);
            }
        }
        return toAstNode({
            kind: 'store',
            name,
            type,
            id: optional(id, id => id[1], null),
            originalId: optional(originalId, originalId => originalId[1], null),
            version: optional(version, version => version[1], null),
            tags: optional(tags, tags => tags[1], null),
            source: source.source,
            origin: source.origin,
            storageKey: source.storageKey || null,
            entities: source.entities || null,
            description,
            claims,
        });
    };
    const peg$c19 = "in";
    const peg$c20 = peg$literalExpectation("in", false);
    const peg$c21 = function (source) { return toAstNode({ kind: 'manifest-storage-source', origin: 'file', source }); };
    const peg$c22 = "at";
    const peg$c23 = peg$literalExpectation("at", false);
    const peg$c24 = function (source, storageKey) {
        return toAstNode({
            kind: 'manifest-storage-source',
            origin: 'resource',
            source,
            storageKey: optional(storageKey, sk => sk[3], null)
        });
    };
    const peg$c25 = function (source) { return toAstNode({ kind: 'manifest-storage-source', origin: 'storage', source }); };
    const peg$c26 = "with";
    const peg$c27 = peg$literalExpectation("with", false);
    const peg$c28 = "{";
    const peg$c29 = peg$literalExpectation("{", false);
    const peg$c30 = ",";
    const peg$c31 = peg$literalExpectation(",", false);
    const peg$c32 = "}";
    const peg$c33 = peg$literalExpectation("}", false);
    const peg$c34 = function (parts, end) {
        return toAstNode({
            kind: 'manifest-storage-source',
            origin: 'inline',
            source: 'inline',
            entities: combineMultiLine(parts, end)
        });
    };
    const peg$c35 = function (parts, end) {
        return toAstNode({
            kind: 'entity-inline',
            fields: Object.assign({}, ...combineMultiLine(parts, end))
        });
    };
    const peg$c36 = ":";
    const peg$c37 = peg$literalExpectation(":", false);
    const peg$c38 = function (name, value) {
        return { [name]: value };
    };
    const peg$c39 = function (value) {
        return { kind: 'entity-value', value };
    };
    const peg$c40 = "[";
    const peg$c41 = peg$literalExpectation("[", false);
    const peg$c42 = "]";
    const peg$c43 = peg$literalExpectation("]", false);
    const peg$c44 = function (parts, end) {
        const value = combineMultiLine(parts, end);
        if (value.length > 1) {
            const typeFor = v => v.constructor.name === 'Uint8Array' ? 'bytes' : typeof (v);
            const firstType = typeFor(value[0]);
            if (value.some(item => typeFor(item) !== firstType)) {
                error('Collection fields for inline entities must have a consistent value type');
            }
        }
        return { kind: 'entity-collection', value };
    };
    const peg$c45 = "(";
    const peg$c46 = peg$literalExpectation("(", false);
    const peg$c47 = ")";
    const peg$c48 = peg$literalExpectation(")", false);
    const peg$c49 = function (parts, end) {
        return { kind: 'entity-tuple', value: combineMultiLine(parts, end) };
    };
    const peg$c50 = function (value) {
        // TODO(cypher1): This should not discard type and unit information.
        return value.value;
    };
    const peg$c51 = "true";
    const peg$c52 = peg$literalExpectation("true", true);
    const peg$c53 = "false";
    const peg$c54 = peg$literalExpectation("false", true);
    const peg$c55 = function (bool) {
        return bool.toLowerCase() === 'true';
    };
    const peg$c56 = "|";
    const peg$c57 = peg$literalExpectation("|", false);
    const peg$c58 = function (parts, end) {
        return new Uint8Array(combineMultiLine(parts, end));
    };
    const peg$c59 = "<";
    const peg$c60 = peg$literalExpectation("<", false);
    const peg$c61 = ">";
    const peg$c62 = peg$literalExpectation(">", false);
    const peg$c63 = function (id, entityStorageKey) {
        if (id.length === 0 || entityStorageKey.length === 0) {
            error('Reference fields for inline entities must have both an id and a storage key');
        }
        return { id, entityStorageKey };
    };
    const peg$c64 = /^[0-9a-f]/i;
    const peg$c65 = peg$classExpectation([["0", "9"], ["a", "f"]], false, true);
    const peg$c66 = function () {
        return Number('0x' + text());
    };
    const peg$c67 = "description";
    const peg$c68 = peg$literalExpectation("description", false);
    const peg$c69 = "claim";
    const peg$c70 = peg$literalExpectation("claim", false);
    const peg$c71 = "field";
    const peg$c72 = peg$literalExpectation("field", false);
    const peg$c73 = "is";
    const peg$c74 = peg$literalExpectation("is", false);
    const peg$c75 = "and";
    const peg$c76 = peg$literalExpectation("and", false);
    const peg$c77 = function (field, tag, rest) {
        const fieldPath = field ? field[2].split('.') : [];
        return toAstNode({
            kind: 'manifest-storage-claim',
            fieldPath,
            tags: [tag, ...rest.map(item => item[5])],
        });
    };
    const peg$c78 = "import";
    const peg$c79 = peg$literalExpectation("import", false);
    const peg$c80 = function (path) {
        return toAstNode({
            kind: 'import',
            path,
        });
    };
    const peg$c81 = peg$otherExpectation("an interface");
    const peg$c82 = "interface";
    const peg$c83 = peg$literalExpectation("interface", false);
    const peg$c84 = function (name, typeVars, items) {
        return toAstNode({
            kind: 'interface',
            name,
            args: optional(items, extractIndented, []).filter(item => item.kind === 'interface-argument'),
            slots: optional(items, extractIndented, []).filter(item => item.kind === 'interface-slot'),
        });
    };
    const peg$c85 = "?";
    const peg$c86 = peg$literalExpectation("?", false);
    const peg$c87 = function (name, direction, isOptional, type) { return buildInterfaceArgument(name, direction || 'any', isOptional, optional(type, t => t[1], null)); };
    const peg$c88 = function (direction, isOptional, type) { return buildInterfaceArgument(null, direction || 'any', isOptional, optional(type, t => t[1], null)); };
    const peg$c89 = function (isOptional, type) { return buildInterfaceArgument(null, 'any', isOptional, type); };
    const peg$c90 = "meta";
    const peg$c91 = peg$literalExpectation("meta", false);
    const peg$c92 = function (items) {
        items = items ? extractIndented(items) : [];
        return toAstNode({ kind: 'meta', items: items });
    };
    const peg$c93 = "name";
    const peg$c94 = peg$literalExpectation("name", false);
    const peg$c95 = function (name) {
        return toAstNode({ key: 'name', value: name, kind: 'name' });
    };
    const peg$c96 = "storageKey";
    const peg$c97 = peg$literalExpectation("storageKey", false);
    const peg$c98 = function (key) {
        return toAstNode({ key: 'storageKey', value: key, kind: 'storage-key' });
    };
    const peg$c99 = "namespace";
    const peg$c100 = peg$literalExpectation("namespace", false);
    const peg$c101 = function (namespace) {
        return toAstNode({ key: 'namespace', value: namespace, kind: 'namespace' });
    };
    const peg$c102 = "external";
    const peg$c103 = peg$literalExpectation("external", false);
    const peg$c104 = "particle";
    const peg$c105 = peg$literalExpectation("particle", false);
    const peg$c106 = function (external, name, verbs, implFile, items) {
        const args = [];
        const modality = [];
        let slotConnections = [];
        const trustClaims = [];
        const trustChecks = [];
        let description = null;
        let hasParticleHandleConnection = false;
        verbs = optional(verbs, parsedOutput => parsedOutput[1], []);
        external = !!external;
        implFile = optional(implFile, implFile => implFile[3], null);
        if (external && implFile) {
            error('Particles marked external cannot have an implementation file.');
        }
        items = optional(items, extractIndented, []);
        items.forEach(item => {
            if (item.kind === 'particle-interface') {
                if (/[A-Z]/.test(item.verb[0]) && item.verb !== name) {
                    error(`Verb ${item.verb} must start with a lower case character or be same as particle name.`);
                }
                verbs.push(item.verb);
                args.push(...item.args);
                hasParticleHandleConnection = true;
            }
            else if (item.kind === 'particle-argument') {
                args.push(item);
            }
            else if (item.kind === 'particle-slot') {
                slotConnections.push(item);
            }
            else if (item.kind === 'description') {
                description = {
                    kind: 'description',
                    location: location() // TODO: FIXME Get the locations of the item descriptions.
                };
                item.description.forEach(d => description[d.name] = d.pattern || d.patterns[0]);
            }
            else if (item.kind === 'claim') {
                trustClaims.push(item);
            }
            else if (item.kind === 'check') {
                trustChecks.push(item);
            }
            else if (item.modality) {
                modality.push(item.modality);
            }
            else {
                error(`Particle ${name} contains an unknown element: ${item.name} / ${item.kind}`);
            }
        });
        if (modality.length === 0) {
            // Add default modality
            modality.push('dom');
        }
        const buildHandleConnection = (slotConnection, direction) => {
            let type = toAstNode({ kind: 'slot-type', fields: [] });
            if (slotConnection.formFactor) {
                type.fields.push(toAstNode({
                    kind: 'slot-field',
                    name: 'formFactor',
                    value: slotConnection.formFactor.formFactor
                }));
            }
            if (direction === '`provides') {
                const provideConnection = slotConnection;
                if (provideConnection.handles && provideConnection.handles.length > 0) {
                    if (provideConnection.handles.length > 1) {
                        throw new Error("Only a single handle name per dependent provide connection is supported by slandles");
                    }
                    type.fields.push(toAstNode({
                        kind: 'slot-field',
                        name: 'handle',
                        value: provideConnection.handles[0]
                    }));
                }
            }
            if (slotConnection.isSet) {
                type = toAstNode({
                    kind: 'collection-type',
                    type: type
                });
            }
            return toAstNode({
                kind: 'particle-argument',
                direction: direction,
                type,
                isOptional: !slotConnection.isRequired,
                dependentConnections: [],
                name: slotConnection.name,
                tags: slotConnection.tags,
                annotations: [],
                expression: null
            });
        };
        if (Flags.defaultToSlandles) {
            for (const slotConnection of slotConnections) {
                const handleConnection = buildHandleConnection(slotConnection, '`consumes');
                for (const provideSlotConnection of slotConnection.provideSlotConnections) {
                    const dependentConnection = buildHandleConnection(provideSlotConnection, '`provides');
                    handleConnection.dependentConnections.push(dependentConnection);
                }
                args.push(handleConnection);
            }
            slotConnections = [];
        }
        return toAstNode({
            kind: 'particle',
            name,
            external,
            implFile,
            verbs,
            args,
            modality,
            slotConnections,
            description,
            hasParticleHandleConnection,
            trustClaims,
            trustChecks
        });
    };
    const peg$c107 = peg$otherExpectation("a particle item");
    const peg$c108 = function (target, expression) {
        const targetParts = target.split('.');
        const handle = targetParts[0];
        const fieldPath = targetParts.slice(1);
        return toAstNode({
            kind: 'claim',
            handle,
            fieldPath,
            expression,
        });
    };
    const peg$c109 = function (first, rest) {
        return [first, ...rest.map(item => item[3])];
    };
    const peg$c110 = "not";
    const peg$c111 = peg$literalExpectation("not", false);
    const peg$c112 = function (not, tag) {
        return toAstNode({
            kind: 'claim-is-tag',
            claimType: ClaimType.IsTag,
            isNot: not != null,
            tag,
        });
    };
    const peg$c113 = "derives";
    const peg$c114 = peg$literalExpectation("derives", false);
    const peg$c115 = "from";
    const peg$c116 = peg$literalExpectation("from", false);
    const peg$c117 = function (target) {
        const targetParts = target.split('.');
        const handle = targetParts[0];
        const fieldPath = targetParts.slice(1);
        return toAstNode({
            kind: 'claim-derives-from',
            claimType: ClaimType.DerivesFrom,
            parentHandle: handle,
            fieldPath,
        });
    };
    const peg$c118 = "check";
    const peg$c119 = peg$literalExpectation("check", false);
    const peg$c120 = function (target, expression) {
        return toAstNode({
            kind: 'check',
            target,
            expression,
        });
    };
    const peg$c121 = "data";
    const peg$c122 = peg$literalExpectation("data", false);
    const peg$c123 = function (target, isSlot) {
        const targetParts = target.split('.');
        const name = targetParts[0];
        const fieldPath = targetParts.slice(1);
        if (isSlot && fieldPath.length) {
            error('Checks on slots cannot specify a field');
        }
        return toAstNode({
            kind: 'check-target',
            targetType: isSlot ? 'slot' : 'handle',
            name,
            fieldPath,
        });
    };
    const peg$c124 = "or";
    const peg$c125 = peg$literalExpectation("or", false);
    const peg$c126 = function (left, rest) {
        if (rest.length === 0) {
            return left;
        }
        const operators = new Set(rest.map(item => item[1]));
        if (operators.size > 1) {
            expected(`You cannot combine 'and' and 'or' operations in a single check expression. You must nest them inside parentheses.`);
        }
        const operator = rest[0][1];
        return toAstNode({
            kind: 'check-boolean-expression',
            operator,
            children: [left, ...rest.map(item => item[3])],
        });
    };
    const peg$c127 = function (condition) { return condition; };
    const peg$c128 = "=>";
    const peg$c129 = peg$literalExpectation("=>", false);
    const peg$c130 = function (antecedent, consequent) {
        return toAstNode({
            kind: 'check-implication',
            checkType: CheckType.Implication,
            antecedent,
            consequent,
        });
    };
    const peg$c131 = function (isNot, tag) {
        return toAstNode({
            kind: 'check-has-tag',
            checkType: CheckType.HasTag,
            isNot: !!isNot,
            tag,
        });
    };
    const peg$c132 = "handle";
    const peg$c133 = peg$literalExpectation("handle", false);
    const peg$c134 = function (isNot, parentHandle) {
        return toAstNode({
            kind: 'check-is-from-handle',
            checkType: CheckType.IsFromHandle,
            isNot: !!isNot,
            parentHandle,
        });
    };
    const peg$c135 = "output";
    const peg$c136 = peg$literalExpectation("output", false);
    const peg$c137 = function (isNot, output) {
        return toAstNode({
            kind: 'check-is-from-output',
            checkType: CheckType.IsFromOutput,
            isNot: !!isNot,
            output,
        });
    };
    const peg$c138 = function (isNot, storeRef) {
        return toAstNode({
            kind: 'check-is-from-store',
            checkType: CheckType.IsFromStore,
            isNot: !!isNot,
            storeRef,
        });
    };
    const peg$c139 = function (name) { return toAstNode({ kind: 'store-reference', type: 'name', store: name }); };
    const peg$c140 = function (id) { return toAstNode({ kind: 'store-reference', type: 'id', store: id }); };
    const peg$c141 = function (arg, dependentConnections) {
        arg.dependentConnections = optional(dependentConnections, extractIndented, []);
        return arg;
    };
    const peg$c142 = function (name) {
        return name;
    };
    const peg$c143 = "=";
    const peg$c144 = peg$literalExpectation("=", false);
    const peg$c145 = function () {
        pushPaxelMode(true);
        return text();
    };
    const peg$c146 = function (name, direction, type, annotations, maybeTags, expression) {
        if (expression) {
            popPaxelMode();
        }
        return toAstNode({
            kind: 'particle-argument',
            direction: optional(direction, d => d[0], 'any'),
            type,
            isOptional: optional(direction, d => !!d[1], false),
            dependentConnections: [],
            name: name || (maybeTags && maybeTags[0]) || expected(`either a name or tags to be supplied ${name} ${maybeTags}`),
            tags: maybeTags || [],
            annotations: annotations || [],
            expression: optional(expression, e => e[3], null)
        });
    };
    const peg$c147 = peg$otherExpectation("a direction (e.g. reads writes, reads, writes, hosts, `consumes, `provides, any')");
    const peg$c148 = "reads";
    const peg$c149 = peg$literalExpectation("reads", false);
    const peg$c150 = " writes";
    const peg$c151 = peg$literalExpectation(" writes", false);
    const peg$c152 = "writes";
    const peg$c153 = peg$literalExpectation("writes", false);
    const peg$c154 = "hosts";
    const peg$c155 = peg$literalExpectation("hosts", false);
    const peg$c156 = "`consumes";
    const peg$c157 = peg$literalExpectation("`consumes", false);
    const peg$c158 = "`provides";
    const peg$c159 = peg$literalExpectation("`provides", false);
    const peg$c160 = /^[^a-zA-Z0-9]/;
    const peg$c161 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], true, false);
    const peg$c162 = peg$anyExpectation();
    const peg$c163 = function () {
        // TODO(jopra): Parse optionality properly.
        let dir = text();
        if (dir === 'reads? writes') {
            // Fix for faking proper capability set support with optionality.
            dir = 'reads writes';
        }
        return dir;
    };
    const peg$c164 = function (type, refinement) {
        type.refinement = refinement;
        return type;
    };
    const peg$c165 = "![";
    const peg$c166 = peg$literalExpectation("![", false);
    const peg$c167 = function (type) {
        return toAstNode({
            kind: 'singleton-type',
            type
        });
    };
    const peg$c168 = function (type) {
        return toAstNode({
            kind: 'collection-type',
            type,
        });
    };
    const peg$c169 = "BigCollection<";
    const peg$c170 = peg$literalExpectation("BigCollection<", false);
    const peg$c171 = function (type) {
        return toAstNode({
            kind: 'big-collection-type',
            type,
        });
    };
    const peg$c172 = "&";
    const peg$c173 = peg$literalExpectation("&", false);
    const peg$c174 = function (type) {
        return toAstNode({
            kind: 'reference-type',
            type,
        });
    };
    const peg$c175 = "#";
    const peg$c176 = peg$literalExpectation("#", false);
    const peg$c177 = function (type) {
        return toAstNode({
            kind: 'mux-type',
            type,
        });
    };
    const peg$c178 = peg$otherExpectation("a tuple of types (e.g. (A, &B, [C]))");
    const peg$c179 = function (first, rest) {
        return toAstNode({
            kind: 'tuple-type',
            types: [first].concat(rest.map(t => t[3])),
        });
    };
    const peg$c180 = peg$otherExpectation("a type variable (e.g. ~foo)");
    const peg$c181 = "~";
    const peg$c182 = peg$literalExpectation("~", false);
    const peg$c183 = function (name, constraint) {
        return toAstNode({
            kind: 'variable-type',
            name,
            constraint: optional(constraint, constraint => constraint[3], null),
        });
    };
    const peg$c184 = "Slot";
    const peg$c185 = peg$literalExpectation("Slot", false);
    const peg$c186 = /^[^a-z0-9_]/i;
    const peg$c187 = peg$classExpectation([["a", "z"], ["0", "9"], "_"], true, true);
    const peg$c188 = function (fields) {
        fields = optional(fields, fields => {
            const data = fields[2];
            if (data) {
                return [data[0]].concat(data[1].map(tail => tail[2]));
            }
            else {
                return [];
            }
        }, []);
        // TODO(jopra): Check for duplicate field names.
        return toAstNode({
            kind: 'slot-type',
            fields,
        });
    };
    const peg$c189 = function (name, value) {
        return toAstNode({
            kind: 'slot-field',
            name,
            value
        });
    };
    const peg$c190 = function (name) {
        return toAstNode({
            kind: 'type-name',
            name,
        });
    };
    const peg$c191 = function (head, tail) {
        return [head, ...tail.map(a => a[2])];
    };
    const peg$c192 = "modality";
    const peg$c193 = peg$literalExpectation("modality", false);
    const peg$c194 = function (modality) {
        return toAstNode({
            kind: 'particle-modality',
            modality,
        });
    };
    const peg$c195 = function (type) {
        let isSet = false;
        if (type.kind === 'collection-type') {
            isSet = true;
            type = type.type;
        }
        if (type.kind !== 'slot-type') {
            expected('a slot type');
        }
        type.isSet = isSet;
        return type;
    };
    const peg$c196 = "consumes";
    const peg$c197 = peg$literalExpectation("consumes", false);
    const peg$c198 = function (name, isOptional, type, maybeTags, items) {
        const provideSlotConnections = [];
        items = optional(items, extractIndented, []);
        items.forEach(item => {
            if (item.kind === 'provided-slot') {
                provideSlotConnections.push(item);
            }
            else {
                error('Unsupported particle slot item ', item);
            }
        });
        let formFactor = null;
        let isSet = false;
        if (type) {
            isSet = type.isSet;
            type.fields.forEach(({ name, value }) => {
                if (name === 'formFactor') {
                    if (!formFactor) {
                        formFactor = value;
                    }
                    else {
                        error('duplicate form factor for a slot');
                    }
                }
                else {
                    error(`unknown slot field named ${name} with value ${value}`);
                }
            });
        }
        return toAstNode({
            kind: 'particle-slot',
            name,
            tags: maybeTags || [],
            isRequired: !isOptional,
            isSet,
            formFactor,
            provideSlotConnections
        });
    };
    const peg$c199 = "provides";
    const peg$c200 = peg$literalExpectation("provides", false);
    const peg$c201 = function (name, isOptional, type, maybeTags) {
        const provideSlotConnections = [];
        let formFactor = null;
        const handles = [];
        let isSet = false;
        if (type) {
            isSet = type.isSet;
            type.fields.forEach(({ name, value }) => {
                if (name === 'formFactor') {
                    if (!formFactor) {
                        formFactor = value;
                    }
                    else {
                        error('duplicate form factor for a slot');
                    }
                }
                else if (name === 'handle') {
                    handles.push(value);
                }
                else {
                    error(`unknown slot field named ${name} with value ${value}`);
                }
            });
        }
        return toAstNode({
            kind: 'provided-slot',
            name,
            tags: maybeTags || [],
            isRequired: !isOptional,
            isSet,
            formFactor,
            handles
        });
    };
    const peg$c202 = function (pattern, handleDescriptions) {
        handleDescriptions = optional(handleDescriptions, extractIndented, []);
        const patterns = [];
        if (pattern) {
            patterns.push(pattern);
        }
        handleDescriptions.filter(desc => desc.name === 'pattern').forEach(p => patterns.push(p));
        handleDescriptions = handleDescriptions.filter(desc => desc.name !== 'pattern');
        return {
            kind: 'description',
            location: location(),
            description: [
                {
                    // TODO: this should be stored in a different field.
                    // TODO: FIXME
                    kind: 'default-description?',
                    location: location(),
                    name: 'pattern',
                    patterns: patterns,
                },
                ...handleDescriptions,
            ],
        };
    };
    const peg$c203 = function (name, pattern) {
        return toAstNode({
            kind: 'handle-description',
            name,
            pattern,
        });
    };
    const peg$c204 = "annotation";
    const peg$c205 = peg$literalExpectation("annotation", false);
    const peg$c206 = function (name, params, items) {
        const targets = optional(items, extractIndented, []).find(item => item.kind === 'annotation-targets');
        const multiple = optional(items, extractIndented, []).find(item => item.kind === 'annotation-multiple');
        return toAstNode({
            kind: 'annotation-node',
            name,
            params: optional(params, params => [params[2], ...(params[3].map(item => item[3]))], []),
            targets: targets ? targets.targets : [],
            retention: optional(items, extractIndented, []).find(item => item.kind === 'annotation-retention').retention,
            allowMultiple: multiple ? multiple.allowMultiple : false,
            doc: optional(optional(items, extractIndented, []).find(item => item.kind === 'annotation-doc'), d => d.doc, '')
        });
    };
    const peg$c207 = function (name, type) {
        return toAstNode({
            kind: 'annotation-param',
            name,
            type: type.type
        });
    };
    const peg$c208 = "Recipe";
    const peg$c209 = peg$literalExpectation("Recipe", false);
    const peg$c210 = "Particle";
    const peg$c211 = peg$literalExpectation("Particle", false);
    const peg$c212 = "HandleConnection";
    const peg$c213 = peg$literalExpectation("HandleConnection", false);
    const peg$c214 = "Store";
    const peg$c215 = peg$literalExpectation("Store", false);
    const peg$c216 = "Handle";
    const peg$c217 = peg$literalExpectation("Handle", false);
    const peg$c218 = "SchemaField";
    const peg$c219 = peg$literalExpectation("SchemaField", false);
    const peg$c220 = "Schema";
    const peg$c221 = peg$literalExpectation("Schema", false);
    const peg$c222 = "PolicyField";
    const peg$c223 = peg$literalExpectation("PolicyField", false);
    const peg$c224 = "PolicyTarget";
    const peg$c225 = peg$literalExpectation("PolicyTarget", false);
    const peg$c226 = "Policy";
    const peg$c227 = peg$literalExpectation("Policy", false);
    const peg$c228 = "targets:";
    const peg$c229 = peg$literalExpectation("targets:", false);
    const peg$c230 = function (targets) {
        return toAstNode({
            kind: 'annotation-targets',
            targets: optional(targets, t => [t[0], ...t[1].map(tail => tail[2])], [])
        });
    };
    const peg$c231 = "Source";
    const peg$c232 = peg$literalExpectation("Source", false);
    const peg$c233 = "Runtime";
    const peg$c234 = peg$literalExpectation("Runtime", false);
    const peg$c235 = "retention:";
    const peg$c236 = peg$literalExpectation("retention:", false);
    const peg$c237 = function (retention) {
        return toAstNode({
            kind: 'annotation-retention',
            retention
        });
    };
    const peg$c238 = "allowMultiple:";
    const peg$c239 = peg$literalExpectation("allowMultiple:", false);
    const peg$c240 = function (bool) {
        return toAstNode({
            kind: 'annotation-multiple',
            allowMultiple: bool.toLowerCase() === 'true'
        });
    };
    const peg$c241 = "doc:";
    const peg$c242 = peg$literalExpectation("doc:", false);
    const peg$c243 = function (doc) {
        return toAstNode({
            kind: 'annotation-doc',
            doc
        });
    };
    const peg$c244 = "@";
    const peg$c245 = peg$literalExpectation("@", false);
    const peg$c246 = function (name, params) {
        return toAstNode({
            kind: 'annotation-ref',
            name,
            params: optional(params, p => [p[3], ...p[5].map(tail => tail[3])], [])
        });
    };
    const peg$c247 = function (name, value) {
        return toAstNode({
            kind: 'annotation-named-param',
            name,
            value: value.value
        });
    };
    const peg$c248 = function (value) {
        return toAstNode({
            kind: 'annotation-simple-param',
            value
        });
    };
    const peg$c249 = function (head, tail) { return [head, ...(tail || [])]; };
    const peg$c250 = function (tags) { return tags; };
    const peg$c251 = "recipe";
    const peg$c252 = peg$literalExpectation("recipe", false);
    const peg$c253 = function (name, verbs, items) {
        verbs = optional(verbs, parsedOutput => parsedOutput[1], []);
        return toAstNode({
            kind: 'recipe',
            name: optional(name, name => name[1], null),
            verbs,
            items: optional(items, extractIndented, []),
        });
    };
    const peg$c254 = "as";
    const peg$c255 = peg$literalExpectation("as", false);
    const peg$c256 = /^[a-zA-Z0-9]/;
    const peg$c257 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
    const peg$c258 = function () { expected(`lower identifier`); };
    const peg$c259 = "*";
    const peg$c260 = peg$literalExpectation("*", false);
    const peg$c261 = function (ref, name, connections) {
        const handleConnections = [];
        const slotConnections = [];
        if (connections) {
            connections = extractIndented(connections);
            for (const conn of connections) {
                if (conn.kind === 'handle-connection') {
                    handleConnections.push(conn);
                }
                else {
                    slotConnections.push(conn);
                }
            }
        }
        return toAstNode({
            kind: 'recipe-particle',
            name: optional(name, name => name[1], null),
            ref,
            connections: handleConnections,
            slotConnections: slotConnections,
        });
    };
    const peg$c262 = "someof";
    const peg$c263 = peg$literalExpectation("someof", false);
    const peg$c264 = function (param, direction, relaxed, target, dependentConnections) {
        direction = optional(direction, d => d[0], null);
        target = optional(target, t => t, toAstNode({
            kind: 'handle-connection-components',
            name: null,
            particle: null,
            tags: []
        }));
        if (Flags.defaultToSlandles) {
            if (direction === 'consumes') {
                direction = '`consumes';
            }
            else if (direction === 'provides') {
                direction = '`provides';
            }
        }
        if (!Flags.useSlandles && (direction === 'consumes' || direction === 'provides')) {
            // RecipeParticleSlotConnection
            return toAstNode({
                kind: 'slot-connection',
                param: param || '*',
                direction,
                target,
                dependentSlotConnections: optional(dependentConnections, extractIndented, []),
            });
        }
        // RecipeParticleConnection
        return toAstNode({
            kind: 'handle-connection',
            param: param || '*',
            direction,
            relaxed: !!relaxed,
            target,
            dependentConnections: optional(dependentConnections, extractIndented, []),
        });
    };
    const peg$c265 = function (param, relaxed, target, dependentConnections) {
        return toAstNode({
            kind: 'handle-connection',
            param: param || '*',
            direction: 'any',
            relaxed: !!relaxed,
            target,
            dependentConnections: optional(dependentConnections, extractIndented, []),
        });
    };
    const peg$c266 = peg$otherExpectation("a particle connection target");
    const peg$c267 = function (param, tags) {
        param = optional(param, param => param, null);
        let name = null;
        let particle = null;
        if (param) {
            if (param[0].toUpperCase() === param[0]) {
                particle = param;
            }
            else {
                name = param;
            }
        }
        return toAstNode({
            kind: 'handle-connection-components',
            name,
            particle,
            tags: optional(tags, t => t[1], []),
        });
    };
    const peg$c268 = function (tags) {
        return toAstNode({
            kind: 'handle-connection-components',
            name: null,
            particle: null,
            tags
        });
    };
    const peg$c269 = function (from, direction, relaxed, to) {
        const anyTarget = toAstNode({
            kind: 'connection-target',
            targetType: 'localName',
            name: null,
            param: '*',
            tags: [],
        });
        return toAstNode({
            kind: 'connection',
            direction: optional(direction, d => d[0], 'any'),
            relaxed: !!relaxed,
            from: from || anyTarget,
            to,
        });
    };
    const peg$c270 = function (target) {
        return target;
    };
    const peg$c271 = "search";
    const peg$c272 = peg$literalExpectation("search", false);
    const peg$c273 = "tokens";
    const peg$c274 = peg$literalExpectation("tokens", false);
    const peg$c275 = function (phrase, tokens) {
        return toAstNode({
            kind: 'search',
            phrase,
            tokens: optional(tokens, tokens => tokens[1][2].map(t => t[1]), null)
        });
    };
    const peg$c276 = function (verbs, components) {
        const { param, tags } = components || { param: null, tags: [] };
        return toAstNode({
            kind: 'connection-target',
            targetType: 'verb',
            verbs,
            param,
            tags
        });
    };
    const peg$c277 = function (tags) {
        return toAstNode({
            kind: 'connection-target',
            targetType: 'tag',
            tags
        });
    };
    const peg$c278 = function (name, components) {
        const { param, tags } = components || { param: null, tags: [] };
        return toAstNode({
            kind: 'connection-target',
            targetType: 'localName',
            name,
            param,
            tags
        });
    };
    const peg$c279 = function (particle, components) {
        const { param, tags } = components || { param: null, tags: [] };
        return toAstNode({
            kind: 'connection-target',
            targetType: 'particle',
            particle,
            param,
            tags
        });
    };
    const peg$c280 = ".";
    const peg$c281 = peg$literalExpectation(".", false);
    const peg$c282 = function (param, tags) {
        return toAstNode({
            kind: 'connection-target-handle-components',
            param: optional(param, param => param, null),
            tags: optional(tags, tags => tags[1], []),
        });
    };
    const peg$c283 = "use";
    const peg$c284 = peg$literalExpectation("use", false);
    const peg$c285 = "map";
    const peg$c286 = peg$literalExpectation("map", false);
    const peg$c287 = "create";
    const peg$c288 = peg$literalExpectation("create", false);
    const peg$c289 = "copy";
    const peg$c290 = peg$literalExpectation("copy", false);
    const peg$c291 = "`slot";
    const peg$c292 = peg$literalExpectation("`slot", false);
    const peg$c293 = function (name, fate, ref, annotations) {
        return toAstNode({
            kind: 'handle',
            name,
            ref: optional(ref, ref => ref[1], emptyRef()),
            fate,
            annotations: annotations || []
        });
    };
    const peg$c294 = "join";
    const peg$c295 = peg$literalExpectation("join", false);
    const peg$c296 = function (name, first, rest) {
        return toAstNode({
            kind: 'synthetic-handle',
            name,
            associations: [first].concat(rest.map(t => t[3])),
        });
    };
    const peg$c297 = "require";
    const peg$c298 = peg$literalExpectation("require", false);
    const peg$c299 = function (items) {
        return toAstNode({
            kind: 'require',
            items: extractIndented(items),
        });
    };
    const peg$c300 = function (name, ref) {
        return toAstNode({
            kind: 'require-handle',
            name: optional(name, name => name[1], null),
            ref: optional(ref, ref => ref[1], emptyRef()),
        });
    };
    const peg$c301 = function (tag) { return tag; };
    const peg$c302 = function (head, tail) { return [head, ...(tail && tail[1] || [])]; };
    const peg$c303 = peg$otherExpectation("a verb (e.g. &Verb)");
    const peg$c304 = function (verb) { return verb; };
    const peg$c305 = function (name, tags) {
        return toAstNode({
            kind: 'name-and-tag-list',
            name: name,
            tags: tags = optional(tags, list => list[1], [])
        });
    };
    const peg$c306 = function (name) {
        // TODO(jopra): Likely covered by previous case.
        return toAstNode({
            kind: 'name-and-tag-list',
            name: name,
            tags: []
        });
    };
    const peg$c307 = function (tags) {
        return toAstNode({
            kind: 'name-and-tag-list',
            name: tags[0],
            tags: tags
        });
    };
    const peg$c308 = function (name) {
        return toAstNode({
            kind: 'particle-ref',
            name,
            verbs: [],
            tags: []
        });
    };
    const peg$c309 = function (verb) {
        return toAstNode({
            kind: 'particle-ref',
            verbs: [verb],
            tags: []
        });
    };
    const peg$c310 = function (id, tags) {
        return toAstNode({
            kind: 'handle-ref',
            id,
            tags: tags || [],
        });
    };
    const peg$c311 = function (name, tags) {
        return toAstNode({
            kind: 'handle-ref',
            name,
            tags: tags || [],
        });
    };
    const peg$c312 = function (tags) {
        return toAstNode({
            kind: 'handle-ref',
            tags: tags || [],
        });
    };
    const peg$c313 = function (tags) {
        return toAstNode({
            kind: 'handle-ref',
            tags,
        });
    };
    const peg$c314 = "slot";
    const peg$c315 = peg$literalExpectation("slot", false);
    const peg$c316 = function (name, ref) {
        if (Flags.defaultToSlandles) {
            return toAstNode({
                kind: 'handle',
                name,
                ref: optional(ref, ref => ref[1], emptyRef()),
                fate: '`slot',
                annotations: []
            });
        }
        return toAstNode({
            kind: 'slot',
            ref: optional(ref, ref => ref[1], emptyRef()),
            name,
        });
    };
    const peg$c317 = function (names, fields) {
        return toAstNode({
            kind: SchemaFieldKind.Inline,
            names: optional(names, names => names.map(name => name[0]).filter(name => name !== '*'), ['*']),
            fields: optional(fields, fields => fields.map(x => x[0]), [])
        });
    };
    const peg$c318 = function (name, type) {
        if (type) {
            type = optional(type, ty => ty[2], null);
        }
        return toAstNode({
            kind: SchemaFieldKind.InlineField,
            name,
            type
        });
    };
    const peg$c319 = function () {
        return toAstNode({
            kind: SchemaFieldKind.InlineField,
            name: '*',
            type: null,
        });
    };
    const peg$c320 = "schema";
    const peg$c321 = peg$literalExpectation("schema", false);
    const peg$c322 = function (names, parents) {
        return toAstNode({
            kind: 'schema',
            names: names.map(name => name[1]).filter(name => name !== '*'),
            parents: optional(parents, parents => parents, []),
        });
    };
    const peg$c323 = function (items) {
        return items.map(item => item[0]);
    };
    const peg$c324 = function (items) {
        return optional(items, extractIndented, []);
    };
    const peg$c325 = "alias";
    const peg$c326 = peg$literalExpectation("alias", false);
    const peg$c327 = function (spec, alias, items) {
        return toAstNode({
            ...spec,
            kind: 'schema',
            items,
            alias
        });
    };
    const peg$c328 = function (spec, items) {
        return toAstNode({
            ...spec,
            kind: 'schema',
            items,
        });
    };
    const peg$c329 = "extends";
    const peg$c330 = peg$literalExpectation("extends", false);
    const peg$c331 = function (first, rest) {
        return [first, ...(rest.map(item => item[3]))];
    };
    const peg$c332 = function (field) {
        if (!field.type) {
            expected('a type (required for schema fields)');
        }
        field.kind = 'schema-field';
        return toAstNode(field);
    };
    const peg$c333 = /^[^\n\]}]/;
    const peg$c334 = peg$classExpectation(["\n", "]", "}"], true, false);
    const peg$c335 = function () { expected('a schema type'); };
    const peg$c336 = function (type, refinement, annotations) {
        if (!Flags.fieldRefinementsAllowed && refinement) {
            error('field refinements are unsupported');
        }
        type.refinement = refinement;
        type.annotations = annotations || [];
        return type;
    };
    const peg$c337 = function (schema) {
        return toAstNode({
            kind: SchemaFieldKind.Collection,
            schema,
            refinement: null
        });
    };
    const peg$c338 = "List<";
    const peg$c339 = peg$literalExpectation("List<", false);
    const peg$c340 = function (schema) {
        return toAstNode({
            kind: SchemaFieldKind.OrderedList,
            schema
        });
    };
    const peg$c341 = function (schema) {
        return toAstNode({
            kind: SchemaFieldKind.Reference,
            schema
        });
    };
    const peg$c342 = "Text";
    const peg$c343 = peg$literalExpectation("Text", false);
    const peg$c344 = "URL";
    const peg$c345 = peg$literalExpectation("URL", false);
    const peg$c346 = "Number";
    const peg$c347 = peg$literalExpectation("Number", false);
    const peg$c348 = "BigInt";
    const peg$c349 = peg$literalExpectation("BigInt", false);
    const peg$c350 = "Boolean";
    const peg$c351 = peg$literalExpectation("Boolean", false);
    const peg$c352 = "Bytes";
    const peg$c353 = peg$literalExpectation("Bytes", false);
    const peg$c354 = "Instant";
    const peg$c355 = peg$literalExpectation("Instant", false);
    const peg$c356 = "Duration";
    const peg$c357 = peg$literalExpectation("Duration", false);
    const peg$c358 = function (type) {
        return toAstNode({
            kind: SchemaFieldKind.Primitive,
            type,
            refinement: null,
            annotations: [],
        });
    };
    const peg$c359 = "inline";
    const peg$c360 = peg$literalExpectation("inline", false);
    const peg$c361 = function (schema) {
        return toAstNode({
            kind: SchemaFieldKind.Nested,
            schema
        });
    };
    const peg$c362 = function (qualifier, rest) {
        const result = [qualifier, ...rest.map(x => x[1])];
        for (let i = result.length - 1; i > 0; i--) {
            result[i].qualifier = result[i - 1];
        }
        for (let i = result.length - 2; i > 0; i--) {
            if (result[i].kind === 'paxel-select') {
                error('Paxel expressions cannot have non-trailing \'select\'');
            }
        }
        if (qualifier.kind !== 'paxel-from') {
            error('Paxel expressions must begin with \'from\'');
        }
        const select = result.pop();
        if (select.kind !== 'paxel-select') {
            error('Paxel expressions must end with \'select\'');
        }
        return select;
    };
    const peg$c363 = function (expr) {
        // Attaches entire expression text to the top level paxel expression node.
        expr.unparsedPaxelExpression = text();
        return expr;
    };
    const peg$c364 = peg$otherExpectation("a scope lookup or a sub-expression,e.g. from p in (paxel expression)");
    const peg$c365 = function (expr) {
        return expr;
    };
    const peg$c366 = peg$otherExpectation("Expression for iterating over a sequence stored in a scope, e.g. from p in inputHandle");
    const peg$c367 = function (iterVar, source) {
        return toAstNode({
            kind: 'paxel-from',
            iterationVar: iterVar,
            qualifier: null,
            source
        });
    };
    const peg$c368 = peg$otherExpectation("Expression for filtering a sequence, e.g. where p < 10");
    const peg$c369 = "where";
    const peg$c370 = peg$literalExpectation("where", false);
    const peg$c371 = function (condition) {
        return toAstNode({
            kind: 'paxel-where',
            condition
        });
    };
    const peg$c372 = peg$otherExpectation("Expression for introducing a new identifier, e.g. let x = 10");
    const peg$c373 = "let";
    const peg$c374 = peg$literalExpectation("let", false);
    const peg$c375 = function (varName, expression) {
        return toAstNode({
            kind: 'paxel-let',
            varName: varName,
            expression
        });
    };
    const peg$c376 = peg$otherExpectation("Expression for mapping a sequence to new values, e.g. select p + 1");
    const peg$c377 = "select";
    const peg$c378 = peg$literalExpectation("select", false);
    const peg$c379 = function (expression) {
        return toAstNode({
            kind: 'paxel-select',
            expression
        });
    };
    const peg$c380 = peg$otherExpectation("Expression instantiating a new Arcs entity, e.g. new Foo {x: bar.x}");
    const peg$c381 = "new";
    const peg$c382 = peg$literalExpectation("new", false);
    const peg$c383 = function (names, fields) {
        return toAstNode({
            kind: 'expression-entity',
            names: optional(names, names => names.map(name => name[0]).filter(name => name !== '*'), ['*']),
            fields
        });
    };
    const peg$c384 = function (field, rest) {
        return [field].concat(rest.map(rfield => rfield[2]));
    };
    const peg$c385 = function (fieldName, expression) {
        return toAstNode({
            kind: 'expression-entity-field',
            name: fieldName,
            expression
        });
    };
    const peg$c386 = peg$otherExpectation("a dotted scope chain, starting at a root param, e.g. param.schemaFieldName.schemaFieldName");
    const peg$c387 = "Byte";
    const peg$c388 = peg$literalExpectation("Byte", false);
    const peg$c389 = "Short";
    const peg$c390 = peg$literalExpectation("Short", false);
    const peg$c391 = "Int";
    const peg$c392 = peg$literalExpectation("Int", false);
    const peg$c393 = "Long";
    const peg$c394 = peg$literalExpectation("Long", false);
    const peg$c395 = "Char";
    const peg$c396 = peg$literalExpectation("Char", false);
    const peg$c397 = "Float";
    const peg$c398 = peg$literalExpectation("Float", false);
    const peg$c399 = "Double";
    const peg$c400 = peg$literalExpectation("Double", false);
    const peg$c401 = function (type) {
        return toAstNode({
            kind: SchemaFieldKind.KotlinPrimitive,
            type,
            refinement: null
        });
    };
    const peg$c402 = function (first, rest) {
        const types = [first];
        for (const type of rest) {
            types.push(type[3]);
        }
        return toAstNode({ kind: SchemaFieldKind.Union, types, refinement: null, annotations: [] });
    };
    const peg$c403 = function (first, rest) {
        const types = [first];
        for (const type of rest) {
            types.push(type[3]);
        }
        return toAstNode({ kind: SchemaFieldKind.Tuple, types, refinement: null, annotations: [] });
    };
    const peg$c404 = function (expression) {
        return toAstNode({ kind: 'refinement', expression });
    };
    const peg$c405 = /^[^\]]/;
    const peg$c406 = peg$classExpectation(["]"], true, false);
    const peg$c407 = function () { expected("a valid refinement expression"); };
    const peg$c408 = function (leftExpr, tail) {
        for (const part of tail) {
            const operator = part[1];
            const rightExpr = part[3];
            leftExpr = toAstNode({ kind: 'binary-expression-node', leftExpr, rightExpr, operator });
        }
        return leftExpr;
    };
    const peg$c409 = "==";
    const peg$c410 = peg$literalExpectation("==", false);
    const peg$c411 = "!=";
    const peg$c412 = peg$literalExpectation("!=", false);
    const peg$c413 = "<=";
    const peg$c414 = peg$literalExpectation("<=", false);
    const peg$c415 = ">=";
    const peg$c416 = peg$literalExpectation(">=", false);
    const peg$c417 = "?:";
    const peg$c418 = peg$literalExpectation("?:", false);
    const peg$c419 = function (leftExpr, tail) {
        for (const part of tail) {
            if (!isPaxelMode())
                error(`If null operator '?:' is only allowed in paxel expressions`);
            const operator = part[1];
            const rightExpr = part[3];
            leftExpr = toAstNode({ kind: 'binary-expression-node', leftExpr, rightExpr, operator });
        }
        return leftExpr;
    };
    const peg$c420 = "+";
    const peg$c421 = peg$literalExpectation("+", false);
    const peg$c422 = "-";
    const peg$c423 = peg$literalExpectation("-", false);
    const peg$c424 = "/";
    const peg$c425 = peg$literalExpectation("/", false);
    const peg$c426 = function (arg, rest) {
        return [arg, ...rest.map(item => item[2])];
    };
    const peg$c427 = function (fnName, args) {
        // TODO: fieldName is too restrictive here (and will give misleading error messages).
        args = args || [];
        if (!isPaxelMode()) {
            if (args.length > 0) {
                error("Functions may have arguments only in paxel expressions.");
            }
            const allBuiltIns = Object.values(BuiltInFuncs);
            if (!allBuiltIns.includes(fnName)) {
                error(`Function '${fnName}' is only supported in paxel expressions.`);
            }
            return toAstNode({ kind: 'built-in-node', value: fnName });
        }
        return toAstNode({
            kind: 'paxel-function',
            function: fnName,
            arguments: args
        });
    };
    const peg$c428 = function (expr) {
        if (!isPaxelMode() && expr.kind.indexOf('paxel-') !== -1) {
            error('Paxel expressions are not allowed in refinements.');
        }
        return expr;
    };
    const peg$c429 = function (op, expr) {
        const operator = op[0];
        return toAstNode({ kind: 'unary-expression-node', expr, operator });
    };
    const peg$c430 = function (bool) {
        return toAstNode({ kind: 'boolean-node', value: bool.toLowerCase() === 'true' });
    };
    const peg$c431 = "null";
    const peg$c432 = peg$literalExpectation("null", false);
    const peg$c433 = function () {
        if (!isPaxelMode())
            error('Null literal is only allowed in paxel expressions');
        return toAstNode({ kind: 'null-node' });
    };
    const peg$c434 = "?.";
    const peg$c435 = peg$literalExpectation("?.", false);
    const peg$c436 = function (fn, nested) {
        const fieldNode = typeof (fn) === 'string' && toAstNode({ kind: 'field-name-node', value: fn }) || fn;
        // nested is ignored, used only to allow Paxel expressions to parse as text
        if (!isPaxelMode()) {
            if (nested && nested.length > 0) {
                // TODO(jopra): Support scope lookups in refinements.
                error('Scope lookups are not currently supported in refinements, only in paxel expressions.');
            }
            return fieldNode;
        }
        else {
            // TODO: placeholder, doesn't actually construct the correct/full AST node
            return toAstNode({ kind: 'paxel-field', scopeExpression: null, field: fieldNode });
        }
    };
    const peg$c437 = function (value) {
        // TODO(cypher1): Add support for named query arguments
        if (isPaxelMode())
            error('Query argument is only allowed in refinement expressions');
        return toAstNode({ kind: 'query-argument-node', value });
    };
    const peg$c438 = function (value) {
        return toAstNode({ kind: 'text-node', value });
    };
    const peg$c439 = function (name) {
        // TODO: Support complex units like metres per second.
        if (name) {
            return [name[1]];
        }
        return [];
    };
    const peg$c440 = "day";
    const peg$c441 = peg$literalExpectation("day", false);
    const peg$c442 = "hour";
    const peg$c443 = peg$literalExpectation("hour", false);
    const peg$c444 = "minute";
    const peg$c445 = peg$literalExpectation("minute", false);
    const peg$c446 = "second";
    const peg$c447 = peg$literalExpectation("second", false);
    const peg$c448 = "millisecond";
    const peg$c449 = peg$literalExpectation("millisecond", false);
    const peg$c450 = "milli";
    const peg$c451 = peg$literalExpectation("milli", false);
    const peg$c452 = "s";
    const peg$c453 = peg$literalExpectation("s", false);
    const peg$c454 = function (unit) {
        if (unit === 'milli') {
            unit = 'millisecond';
        }
        return unit + 's';
    };
    const peg$c455 = "n";
    const peg$c456 = peg$literalExpectation("n", false);
    const peg$c457 = "i";
    const peg$c458 = peg$literalExpectation("i", false);
    const peg$c459 = "l";
    const peg$c460 = peg$literalExpectation("l", false);
    const peg$c461 = "f";
    const peg$c462 = peg$literalExpectation("f", false);
    const peg$c463 = "d";
    const peg$c464 = peg$literalExpectation("d", false);
    const peg$c465 = /^[^a-zA-Z0-9_]/;
    const peg$c466 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], true, false);
    const peg$c467 = function (typeIdentifier) {
        return text();
    };
    const peg$c468 = /^[0-9_]/;
    const peg$c469 = peg$classExpectation([["0", "9"], "_"], false, false);
    const peg$c470 = function (neg, whole, decimal, typeIdentifier, units) {
        const type = (() => {
            switch (typeIdentifier) {
                case 'n': return 'BigInt';
                case 'i': return 'Int';
                case 'l': return 'Long';
                case 'f': return 'Float';
                case 'd': return 'Double';
                case null:
                    // Require a unit (that implies the appropriate type)
                    if (units.length === 1 && timeUnits.includes(units[0])) {
                        return 'Instant';
                    }
                    else {
                        // TODO: Infer the type from the number etc.
                        // For now, default to number for backwards compatibility.
                        return 'Number';
                    }
            }
            throw new Error(`Unexpected type identifier '${typeIdentifier}' (expected one of n, i, l, f, d)`);
        })();
        const getDigits = (chars) => chars.filter(x => x !== '_').join('');
        const decimalStr = decimal ? `.${getDigits(decimal[1])}` : '';
        const repr = `${neg || ''}${getDigits(whole)}${decimalStr}`;
        // The following is a work around, because TS can't infer subtyping based on membership.
        const discreteType = type;
        if (discreteTypes.includes(discreteType)) {
            const value = BigInt(repr);
            return toAstNode({ kind: 'discrete-node', value, units, type: discreteType });
        }
        const value = Number(repr);
        // TODO: Float + Double typing.
        return toAstNode({ kind: 'number-node', value, units });
    };
    const peg$c471 = peg$otherExpectation("a version number (e.g. @012)");
    const peg$c472 = /^[^ ]/;
    const peg$c473 = peg$classExpectation([" "], true, false);
    const peg$c474 = function (version) {
        return version.join('');
    };
    const peg$c475 = "policy";
    const peg$c476 = peg$literalExpectation("policy", false);
    const peg$c477 = function (name, items) {
        const targets = [];
        const configs = [];
        for (const item of extractCommaSeparated(items)) {
            switch (item.kind) {
                case 'policy-target':
                    targets.push(item);
                    break;
                case 'policy-config':
                    configs.push(item);
                    break;
                default:
                    error(`Unknown PolicyItem: ${item}`);
            }
        }
        return toAstNode({
            kind: 'policy',
            name,
            targets,
            configs,
            annotationRefs: [],
        });
    };
    const peg$c478 = "access";
    const peg$c479 = peg$literalExpectation("access", false);
    const peg$c480 = function (annotationRefs, schemaName, fields) {
        return toAstNode({
            kind: 'policy-target',
            schemaName,
            fields,
            annotationRefs: annotationRefs.map(item => item[0]),
        });
    };
    const peg$c481 = peg$otherExpectation("Set of policy fields enclosed in curly braces");
    const peg$c482 = function (fields) {
        return extractCommaSeparated(fields);
    };
    const peg$c483 = function (annotationRefs, name, subfields) {
        return toAstNode({
            kind: 'policy-field',
            name,
            subfields: subfields || [],
            annotationRefs: annotationRefs.map(item => item[0]),
        });
    };
    const peg$c484 = "config";
    const peg$c485 = peg$literalExpectation("config", false);
    const peg$c486 = function (name, items) {
        const metadata = new Map();
        for (const [key, value] of extractCommaSeparated(items)) {
            if (metadata.has(key)) {
                error(`Duplicate key in policy config: ${key}.`);
            }
            metadata.set(key, value);
        }
        return toAstNode({
            kind: 'policy-config',
            name,
            metadata,
        });
    };
    const peg$c487 = function (key, value) {
        return [key, value];
    };
    const peg$c488 = peg$otherExpectation("indentation");
    const peg$c489 = " ";
    const peg$c490 = peg$literalExpectation(" ", false);
    const peg$c491 = function (i) {
        i = i.join('');
        if (i.length > indent.length) {
            indents.push(indent);
            indent = i;
            return true;
        }
        return false;
    };
    const peg$c492 = peg$otherExpectation("same indentation");
    const peg$c493 = function (i) {
        i = i.join('');
        if (i.length === indent.length) {
            return true;
        }
        else if (i.length < indent.length) {
            indent = indents.pop();
            return false;
        }
        return false;
    };
    const peg$c494 = peg$otherExpectation("same or more indentation");
    const peg$c495 = function (i) {
        i = i.join('');
        if (i.length >= indent.length) {
            return true;
        }
        else if (i.length < indent.length) {
            indent = indents.pop();
            return false;
        }
        return undefined;
    };
    const peg$c496 = function (keyword) {
        expected(`an upper case identifier`);
    };
    const peg$c497 = function (keyword) {
        error(`Expected an identifier (but found reserved word '${keyword}')`);
    };
    const peg$c498 = peg$otherExpectation("a 'multiline quoted string'");
    const peg$c499 = "'";
    const peg$c500 = peg$literalExpectation("'", false);
    const peg$c501 = /^[^\\']/;
    const peg$c502 = peg$classExpectation(["\\", "'"], true, false);
    const peg$c503 = "\\";
    const peg$c504 = peg$literalExpectation("\\", false);
    const peg$c505 = /^[^']/;
    const peg$c506 = peg$classExpectation(["'"], true, false);
    const peg$c507 = function (parts, end) { expected('\' at the end of a quoted string'); };
    const peg$c508 = function (parts, end) { return descapeString(parts, end); };
    const peg$c509 = "\"";
    const peg$c510 = peg$literalExpectation("\"", false);
    const peg$c511 = /^[^\\"]/;
    const peg$c512 = peg$classExpectation(["\\", "\""], true, false);
    const peg$c513 = /^[^"]/;
    const peg$c514 = peg$classExpectation(["\""], true, false);
    const peg$c515 = function (parts, end) { expected('\" at the end of a quoted string'); };
    const peg$c516 = peg$otherExpectation("a `backquoted string`");
    const peg$c517 = "`";
    const peg$c518 = peg$literalExpectation("`", false);
    const peg$c519 = /^[^`]/;
    const peg$c520 = peg$classExpectation(["`"], true, false);
    const peg$c521 = function (pattern) { return pattern.join(''); };
    const peg$c522 = peg$otherExpectation("an identifier (e.g. 'id')");
    const peg$c523 = function (txt) {
        const newlineIndex = txt.indexOf('\n');
        if (newlineIndex !== -1) {
            error('Identifiers must be a single line (possibly missing a quote mark " or \')');
        }
        return txt;
    };
    const peg$c524 = peg$otherExpectation("an uppercase identifier (e.g. Foo)");
    const peg$c525 = /^[A-Z]/;
    const peg$c526 = peg$classExpectation([["A", "Z"]], false, false);
    const peg$c527 = /^[a-z0-9_]/i;
    const peg$c528 = peg$classExpectation([["a", "z"], ["0", "9"], "_"], false, true);
    const peg$c529 = peg$otherExpectation("a lowercase identifier (e.g. foo)");
    const peg$c530 = peg$otherExpectation("a lowercase identifier or keyword");
    const peg$c531 = /^[a-z]/;
    const peg$c532 = peg$classExpectation([["a", "z"]], false, false);
    const peg$c533 = peg$otherExpectation("a field name (e.g. foo9)");
    const peg$c534 = peg$otherExpectation("a sequence of field names, descending into subfields (e.g. someField.someRef.someOtherField).");
    const peg$c535 = peg$otherExpectation("a name conforming to the rules of an android app name, per https://developer.android.com/guide/topics/manifest/manifest-element.html#package");
    const peg$c536 = peg$otherExpectation("a name starting with a letter and containing letters, digits and underscores");
    const peg$c537 = /^[a-zA-Z]/;
    const peg$c538 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
    const peg$c539 = /^[a-zA-Z0-9_]/;
    const peg$c540 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], false, false);
    const peg$c541 = peg$otherExpectation("one or more whitespace characters");
    const peg$c542 = peg$otherExpectation("a 'plain' space (use whiteSpace instead)");
    const peg$c543 = "\xA0";
    const peg$c544 = peg$literalExpectation("\xA0", false);
    const peg$c545 = "\t";
    const peg$c546 = peg$literalExpectation("\t", false);
    const peg$c547 = "\f";
    const peg$c548 = peg$literalExpectation("\f", false);
    const peg$c549 = "\r";
    const peg$c550 = peg$literalExpectation("\r", false);
    const peg$c551 = "\x0B";
    const peg$c552 = peg$literalExpectation("\x0B", false);
    const peg$c553 = function () { expected('space'); };
    const peg$c554 = peg$otherExpectation("a block comment /* */");
    const peg$c555 = "/*";
    const peg$c556 = peg$literalExpectation("/*", false);
    const peg$c557 = "*/";
    const peg$c558 = peg$literalExpectation("*/", false);
    const peg$c559 = function () { error('Unfinished block comment'); };
    const peg$c560 = peg$otherExpectation("a group of new lines (and optionally comments)");
    const peg$c561 = "//";
    const peg$c562 = peg$literalExpectation("//", false);
    const peg$c563 = peg$otherExpectation("optional whitespace including newlines and comments");
    const peg$c564 = peg$otherExpectation("a new line");
    const peg$c565 = "\n";
    const peg$c566 = peg$literalExpectation("\n", false);
    let peg$currPos = 0;
    let peg$savedPos = 0;
    const peg$posDetailsCache = [{ line: 1, column: 1 }];
    let peg$maxFailPos = 0;
    let peg$maxFailExpected = [];
    let peg$silentFails = 0;
    let peg$result;
    if (options.startRule !== undefined) {
        if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }
    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location1) {
        location1 = location1 !== undefined
            ? location1
            : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location1);
    }
    function error(message, location1) {
        location1 = location1 !== undefined
            ? location1
            : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location1);
    }
    function peg$literalExpectation(text1, ignoreCase) {
        return { type: "literal", text: text1, ignoreCase: ignoreCase };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }
    function peg$anyExpectation() {
        return { type: "any" };
    }
    function peg$endExpectation() {
        return { type: "end" };
    }
    function peg$otherExpectation(description) {
        return { type: "other", description: description };
    }
    function peg$computePosDetails(pos) {
        let details = peg$posDetailsCache[pos];
        let p;
        if (details) {
            return details;
        }
        else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
                p--;
            }
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                }
                else {
                    details.column++;
                }
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos) {
        const startPosDetails = peg$computePosDetails(startPos);
        const endPosDetails = peg$computePosDetails(endPos);
        return {
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
    }
    function peg$fail(expected1) {
        if (peg$currPos < peg$maxFailPos) {
            return;
        }
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected1);
    }
    function peg$buildSimpleError(message, location1) {
        return new manifest_parser_SyntaxError(message, [], "", location1);
    }
    function peg$buildStructuredError(expected1, found, location1) {
        return new manifest_parser_SyntaxError(manifest_parser_SyntaxError.buildMessage(expected1, found), expected1, found, location1);
    }
    function peg$parseManifest() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseeolWhiteSpace();
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseIndent();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$currPos;
                s5 = peg$parseAnnotation();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parseSameIndent();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseManifestItem();
                        if (s7 !== peg$FAILED) {
                            s5 = [s5, s6, s7];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
                while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    s5 = peg$parseAnnotation();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parseSameIndent();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseManifestItem();
                            if (s7 !== peg$FAILED) {
                                s5 = [s5, s6, s7];
                                s4 = s5;
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c0(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestItem() {
        let s0;
        s0 = peg$parseRecipeNode();
        if (s0 === peg$FAILED) {
            s0 = peg$parseParticle();
            if (s0 === peg$FAILED) {
                s0 = peg$parseImport();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseSchema();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseSchemaAlias();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseManifestStorage();
                            if (s0 === peg$FAILED) {
                                s0 = peg$parseInterface();
                                if (s0 === peg$FAILED) {
                                    s0 = peg$parseMeta();
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$parseResource();
                                        if (s0 === peg$FAILED) {
                                            s0 = peg$parseAnnotationNode();
                                            if (s0 === peg$FAILED) {
                                                s0 = peg$parsePolicy();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseAnnotation() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parseSameIndent();
        if (s3 !== peg$FAILED) {
            s4 = peg$parseAnnotationRef();
            if (s4 !== peg$FAILED) {
                s5 = peg$parseeolWhiteSpace();
                if (s5 !== peg$FAILED) {
                    s3 = [s3, s4, s5];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parseSameIndent();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseAnnotationRef();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseeolWhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s3 = [s3, s4, s5];
                        s2 = s3;
                    }
                    else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c1(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseResource() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 8) === peg$c2) {
            s1 = peg$c2;
            peg$currPos += 8;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c3);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseupperIdent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseIndent();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseSameIndent();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseResourceStart();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parseResourceBody();
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$parseeolWhiteSpace();
                                        if (s9 === peg$FAILED) {
                                            s9 = null;
                                        }
                                        if (s9 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c4(s3, s8);
                                            s0 = s1;
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseResourceStart() {
        let s0, s1, s2;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c5) {
            s1 = peg$c5;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c6);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseeol();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c7();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseResourceBody() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parseSameOrMoreIndent();
        if (s3 !== peg$FAILED) {
            s4 = peg$parseResourceLine();
            if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$currPos;
                s3 = peg$parseSameOrMoreIndent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseResourceLine();
                    if (s4 !== peg$FAILED) {
                        s3 = [s3, s4];
                        s2 = s3;
                    }
                    else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
        }
        else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c8(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseResourceLine() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        if (peg$c9.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c10);
            }
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c9.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                }
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseeol();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorage() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19, s20;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c12) {
            s1 = peg$c12;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c13);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseupperIdent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c14) {
                            s5 = peg$c14;
                            peg$currPos += 2;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c15);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parsewhiteSpace();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseManifestStorageType();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$currPos;
                                    s9 = peg$parsewhiteSpace();
                                    if (s9 !== peg$FAILED) {
                                        s10 = peg$parseid();
                                        if (s10 !== peg$FAILED) {
                                            s9 = [s9, s10];
                                            s8 = s9;
                                        }
                                        else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                    if (s8 === peg$FAILED) {
                                        s8 = null;
                                    }
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$currPos;
                                        if (input.substr(peg$currPos, 2) === peg$c16) {
                                            s10 = peg$c16;
                                            peg$currPos += 2;
                                        }
                                        else {
                                            s10 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c17);
                                            }
                                        }
                                        if (s10 !== peg$FAILED) {
                                            s11 = peg$parseid();
                                            if (s11 !== peg$FAILED) {
                                                s10 = [s10, s11];
                                                s9 = s10;
                                            }
                                            else {
                                                peg$currPos = s9;
                                                s9 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s9;
                                            s9 = peg$FAILED;
                                        }
                                        if (s9 === peg$FAILED) {
                                            s9 = null;
                                        }
                                        if (s9 !== peg$FAILED) {
                                            s10 = peg$currPos;
                                            s11 = peg$parsewhiteSpace();
                                            if (s11 !== peg$FAILED) {
                                                s12 = peg$parseVersion();
                                                if (s12 !== peg$FAILED) {
                                                    s11 = [s11, s12];
                                                    s10 = s11;
                                                }
                                                else {
                                                    peg$currPos = s10;
                                                    s10 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s10;
                                                s10 = peg$FAILED;
                                            }
                                            if (s10 === peg$FAILED) {
                                                s10 = null;
                                            }
                                            if (s10 !== peg$FAILED) {
                                                s11 = peg$currPos;
                                                s12 = peg$parsewhiteSpace();
                                                if (s12 !== peg$FAILED) {
                                                    s13 = peg$parseTagList();
                                                    if (s13 !== peg$FAILED) {
                                                        s12 = [s12, s13];
                                                        s11 = s12;
                                                    }
                                                    else {
                                                        peg$currPos = s11;
                                                        s11 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s11;
                                                    s11 = peg$FAILED;
                                                }
                                                if (s11 === peg$FAILED) {
                                                    s11 = null;
                                                }
                                                if (s11 !== peg$FAILED) {
                                                    s12 = peg$parsewhiteSpace();
                                                    if (s12 !== peg$FAILED) {
                                                        s13 = peg$parseManifestStorageSource();
                                                        if (s13 !== peg$FAILED) {
                                                            s14 = peg$parseeolWhiteSpace();
                                                            if (s14 !== peg$FAILED) {
                                                                s15 = peg$currPos;
                                                                s16 = peg$parseIndent();
                                                                if (s16 !== peg$FAILED) {
                                                                    s17 = [];
                                                                    s18 = peg$currPos;
                                                                    s19 = peg$parseSameIndent();
                                                                    if (s19 !== peg$FAILED) {
                                                                        s20 = peg$parseManifestStorageItem();
                                                                        if (s20 !== peg$FAILED) {
                                                                            s19 = [s19, s20];
                                                                            s18 = s19;
                                                                        }
                                                                        else {
                                                                            peg$currPos = s18;
                                                                            s18 = peg$FAILED;
                                                                        }
                                                                    }
                                                                    else {
                                                                        peg$currPos = s18;
                                                                        s18 = peg$FAILED;
                                                                    }
                                                                    if (s18 !== peg$FAILED) {
                                                                        while (s18 !== peg$FAILED) {
                                                                            s17.push(s18);
                                                                            s18 = peg$currPos;
                                                                            s19 = peg$parseSameIndent();
                                                                            if (s19 !== peg$FAILED) {
                                                                                s20 = peg$parseManifestStorageItem();
                                                                                if (s20 !== peg$FAILED) {
                                                                                    s19 = [s19, s20];
                                                                                    s18 = s19;
                                                                                }
                                                                                else {
                                                                                    peg$currPos = s18;
                                                                                    s18 = peg$FAILED;
                                                                                }
                                                                            }
                                                                            else {
                                                                                peg$currPos = s18;
                                                                                s18 = peg$FAILED;
                                                                            }
                                                                        }
                                                                    }
                                                                    else {
                                                                        s17 = peg$FAILED;
                                                                    }
                                                                    if (s17 !== peg$FAILED) {
                                                                        s16 = [s16, s17];
                                                                        s15 = s16;
                                                                    }
                                                                    else {
                                                                        peg$currPos = s15;
                                                                        s15 = peg$FAILED;
                                                                    }
                                                                }
                                                                else {
                                                                    peg$currPos = s15;
                                                                    s15 = peg$FAILED;
                                                                }
                                                                if (s15 === peg$FAILED) {
                                                                    s15 = null;
                                                                }
                                                                if (s15 !== peg$FAILED) {
                                                                    peg$savedPos = s0;
                                                                    s1 = peg$c18(s3, s7, s8, s9, s10, s11, s13, s15);
                                                                    s0 = s1;
                                                                }
                                                                else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$FAILED;
                                                                }
                                                            }
                                                            else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        }
                                                        else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    }
                                                    else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageType() {
        let s0;
        s0 = peg$parseSchemaInline();
        if (s0 === peg$FAILED) {
            s0 = peg$parseSingletonType();
            if (s0 === peg$FAILED) {
                s0 = peg$parseCollectionType();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseBigCollectionType();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseTypeName();
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseManifestStorageSource() {
        let s0;
        s0 = peg$parseManifestStorageFileSource();
        if (s0 === peg$FAILED) {
            s0 = peg$parseManifestStorageResourceSource();
            if (s0 === peg$FAILED) {
                s0 = peg$parseManifestStorageStorageSource();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseManifestStorageInlineSource();
                }
            }
        }
        return s0;
    }
    function peg$parseManifestStorageFileSource() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c19) {
            s1 = peg$c19;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c20);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseid();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c21(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageResourceSource() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c19) {
            s1 = peg$c19;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c20);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseupperIdent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    s5 = peg$parsewhiteSpace();
                    if (s5 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c22) {
                            s6 = peg$c22;
                            peg$currPos += 2;
                        }
                        else {
                            s6 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c23);
                            }
                        }
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parsewhiteSpace();
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parseid();
                                if (s8 !== peg$FAILED) {
                                    s5 = [s5, s6, s7, s8];
                                    s4 = s5;
                                }
                                else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c24(s3, s4);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageStorageSource() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c22) {
            s1 = peg$c22;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c23);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseid();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c25(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageInlineSource() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c26) {
            s1 = peg$c26;
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c27);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsemultiLineSpace();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 123) {
                    s3 = peg$c28;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c29);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsemultiLineSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = [];
                        s6 = peg$currPos;
                        s7 = peg$parseManifestStorageInlineEntity();
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsewhiteSpace();
                            if (s8 === peg$FAILED) {
                                s8 = null;
                            }
                            if (s8 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 44) {
                                    s9 = peg$c30;
                                    peg$currPos++;
                                }
                                else {
                                    s9 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c31);
                                    }
                                }
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parsemultiLineSpace();
                                    if (s10 !== peg$FAILED) {
                                        s7 = [s7, s8, s9, s10];
                                        s6 = s7;
                                    }
                                    else {
                                        peg$currPos = s6;
                                        s6 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                        while (s6 !== peg$FAILED) {
                            s5.push(s6);
                            s6 = peg$currPos;
                            s7 = peg$parseManifestStorageInlineEntity();
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parsewhiteSpace();
                                if (s8 === peg$FAILED) {
                                    s8 = null;
                                }
                                if (s8 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 44) {
                                        s9 = peg$c30;
                                        peg$currPos++;
                                    }
                                    else {
                                        s9 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c31);
                                        }
                                    }
                                    if (s9 !== peg$FAILED) {
                                        s10 = peg$parsemultiLineSpace();
                                        if (s10 !== peg$FAILED) {
                                            s7 = [s7, s8, s9, s10];
                                            s6 = s7;
                                        }
                                        else {
                                            peg$currPos = s6;
                                            s6 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s6;
                                        s6 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseManifestStorageInlineEntity();
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parsemultiLineSpace();
                                if (s7 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 125) {
                                        s8 = peg$c32;
                                        peg$currPos++;
                                    }
                                    else {
                                        s8 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c33);
                                        }
                                    }
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c34(s5, s6);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageInlineEntity() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c28;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c29);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsemultiLineSpace();
            if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$currPos;
                s5 = peg$parseManifestStorageInlineEntityField();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsewhiteSpace();
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s7 = peg$c30;
                            peg$currPos++;
                        }
                        else {
                            s7 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c31);
                            }
                        }
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsemultiLineSpace();
                            if (s8 !== peg$FAILED) {
                                s5 = [s5, s6, s7, s8];
                                s4 = s5;
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
                while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    s5 = peg$parseManifestStorageInlineEntityField();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s7 = peg$c30;
                                peg$currPos++;
                            }
                            else {
                                s7 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c31);
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parsemultiLineSpace();
                                if (s8 !== peg$FAILED) {
                                    s5 = [s5, s6, s7, s8];
                                    s4 = s5;
                                }
                                else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseManifestStorageInlineEntityField();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsemultiLineSpace();
                        if (s5 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 125) {
                                s6 = peg$c32;
                                peg$currPos++;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c33);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c35(s3, s4);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageInlineEntityField() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsefieldName();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c36;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c37);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsemultiLineSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseManifestStorageInlineValue();
                        if (s5 === peg$FAILED) {
                            s5 = peg$parseManifestStorageInlineCollection();
                            if (s5 === peg$FAILED) {
                                s5 = peg$parseManifestStorageInlineTuple();
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c38(s1, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageInlineValue() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseManifestStorageInlineData();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c39(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseManifestStorageInlineCollection() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c40;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c41);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsemultiLineSpace();
            if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$currPos;
                s5 = peg$parseManifestStorageInlineData();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsewhiteSpace();
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s7 = peg$c30;
                            peg$currPos++;
                        }
                        else {
                            s7 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c31);
                            }
                        }
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsemultiLineSpace();
                            if (s8 !== peg$FAILED) {
                                s5 = [s5, s6, s7, s8];
                                s4 = s5;
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
                while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    s5 = peg$parseManifestStorageInlineData();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s7 = peg$c30;
                                peg$currPos++;
                            }
                            else {
                                s7 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c31);
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parsemultiLineSpace();
                                if (s8 !== peg$FAILED) {
                                    s5 = [s5, s6, s7, s8];
                                    s4 = s5;
                                }
                                else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseManifestStorageInlineData();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsemultiLineSpace();
                        if (s5 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 93) {
                                s6 = peg$c42;
                                peg$currPos++;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c43);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c44(s3, s4);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageInlineTuple() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c45;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c46);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsemultiLineSpace();
            if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$currPos;
                s5 = peg$parseManifestStorageInlineData();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsewhiteSpace();
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s7 = peg$c30;
                            peg$currPos++;
                        }
                        else {
                            s7 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c31);
                            }
                        }
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsemultiLineSpace();
                            if (s8 !== peg$FAILED) {
                                s5 = [s5, s6, s7, s8];
                                s4 = s5;
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
                while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    s5 = peg$parseManifestStorageInlineData();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s7 = peg$c30;
                                peg$currPos++;
                            }
                            else {
                                s7 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c31);
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parsemultiLineSpace();
                                if (s8 !== peg$FAILED) {
                                    s5 = [s5, s6, s7, s8];
                                    s4 = s5;
                                }
                                else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseManifestStorageInlineData();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsemultiLineSpace();
                        if (s5 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s6 = peg$c47;
                                peg$currPos++;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c48);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c49(s3, s4);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageInlineData() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$parseQuotedString();
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseNumericValue();
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c50(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c51) {
                    s1 = input.substr(peg$currPos, 4);
                    peg$currPos += 4;
                }
                else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c52);
                    }
                }
                if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c53) {
                        s1 = input.substr(peg$currPos, 5);
                        peg$currPos += 5;
                    }
                    else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c54);
                        }
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c55(s1);
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 124) {
                        s1 = peg$c56;
                        peg$currPos++;
                    }
                    else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c57);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parsemultiLineSpace();
                        if (s2 !== peg$FAILED) {
                            s3 = [];
                            s4 = peg$currPos;
                            s5 = peg$parseHexByte();
                            if (s5 !== peg$FAILED) {
                                s6 = peg$parsewhiteSpace();
                                if (s6 === peg$FAILED) {
                                    s6 = null;
                                }
                                if (s6 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 44) {
                                        s7 = peg$c30;
                                        peg$currPos++;
                                    }
                                    else {
                                        s7 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c31);
                                        }
                                    }
                                    if (s7 !== peg$FAILED) {
                                        s8 = peg$parsemultiLineSpace();
                                        if (s8 !== peg$FAILED) {
                                            s5 = [s5, s6, s7, s8];
                                            s4 = s5;
                                        }
                                        else {
                                            peg$currPos = s4;
                                            s4 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s4;
                                        s4 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                            while (s4 !== peg$FAILED) {
                                s3.push(s4);
                                s4 = peg$currPos;
                                s5 = peg$parseHexByte();
                                if (s5 !== peg$FAILED) {
                                    s6 = peg$parsewhiteSpace();
                                    if (s6 === peg$FAILED) {
                                        s6 = null;
                                    }
                                    if (s6 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 44) {
                                            s7 = peg$c30;
                                            peg$currPos++;
                                        }
                                        else {
                                            s7 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c31);
                                            }
                                        }
                                        if (s7 !== peg$FAILED) {
                                            s8 = peg$parsemultiLineSpace();
                                            if (s8 !== peg$FAILED) {
                                                s5 = [s5, s6, s7, s8];
                                                s4 = s5;
                                            }
                                            else {
                                                peg$currPos = s4;
                                                s4 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s4;
                                            s4 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s4;
                                        s4 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parseHexByte();
                                if (s4 === peg$FAILED) {
                                    s4 = null;
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parsemultiLineSpace();
                                    if (s5 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 124) {
                                            s6 = peg$c56;
                                            peg$currPos++;
                                        }
                                        else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c57);
                                            }
                                        }
                                        if (s6 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c58(s3, s4);
                                            s0 = s1;
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 60) {
                            s1 = peg$c59;
                            peg$currPos++;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c60);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parsemultiLineSpace();
                            if (s2 !== peg$FAILED) {
                                s3 = peg$parseQuotedString();
                                if (s3 !== peg$FAILED) {
                                    s4 = peg$parsewhiteSpace();
                                    if (s4 === peg$FAILED) {
                                        s4 = null;
                                    }
                                    if (s4 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 44) {
                                            s5 = peg$c30;
                                            peg$currPos++;
                                        }
                                        else {
                                            s5 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c31);
                                            }
                                        }
                                        if (s5 !== peg$FAILED) {
                                            s6 = peg$parsemultiLineSpace();
                                            if (s6 !== peg$FAILED) {
                                                s7 = peg$parseQuotedString();
                                                if (s7 !== peg$FAILED) {
                                                    s8 = peg$parsemultiLineSpace();
                                                    if (s8 !== peg$FAILED) {
                                                        if (input.charCodeAt(peg$currPos) === 62) {
                                                            s9 = peg$c61;
                                                            peg$currPos++;
                                                        }
                                                        else {
                                                            s9 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                                peg$fail(peg$c62);
                                                            }
                                                        }
                                                        if (s9 !== peg$FAILED) {
                                                            peg$savedPos = s0;
                                                            s1 = peg$c63(s3, s7);
                                                            s0 = s1;
                                                        }
                                                        else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    }
                                                    else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseHexByte() {
        let s0, s1, s2;
        s0 = peg$currPos;
        if (peg$c64.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c65);
            }
        }
        if (s1 !== peg$FAILED) {
            if (peg$c64.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c65);
                }
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c66();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageItem() {
        let s0;
        s0 = peg$parseManifestStorageDescription();
        if (s0 === peg$FAILED) {
            s0 = peg$parseManifestStorageClaim();
        }
        return s0;
    }
    function peg$parseManifestStorageDescription() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 11) === peg$c67) {
            s1 = peg$c67;
            peg$currPos += 11;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c68);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsebackquotedString();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s1 = [s1, s2, s3, s4];
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseManifestStorageClaim() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c69) {
            s1 = peg$c69;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c70);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                if (input.substr(peg$currPos, 5) === peg$c71) {
                    s4 = peg$c71;
                    peg$currPos += 5;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c72);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsewhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsedottedFields();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parsewhiteSpace();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c73) {
                        s4 = peg$c73;
                        peg$currPos += 2;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c74);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parselowerIdent();
                            if (s6 !== peg$FAILED) {
                                s7 = [];
                                s8 = peg$currPos;
                                s9 = peg$parsewhiteSpace();
                                if (s9 !== peg$FAILED) {
                                    if (input.substr(peg$currPos, 3) === peg$c75) {
                                        s10 = peg$c75;
                                        peg$currPos += 3;
                                    }
                                    else {
                                        s10 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c76);
                                        }
                                    }
                                    if (s10 !== peg$FAILED) {
                                        s11 = peg$parsewhiteSpace();
                                        if (s11 !== peg$FAILED) {
                                            if (input.substr(peg$currPos, 2) === peg$c73) {
                                                s12 = peg$c73;
                                                peg$currPos += 2;
                                            }
                                            else {
                                                s12 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c74);
                                                }
                                            }
                                            if (s12 !== peg$FAILED) {
                                                s13 = peg$parsewhiteSpace();
                                                if (s13 !== peg$FAILED) {
                                                    s14 = peg$parselowerIdent();
                                                    if (s14 !== peg$FAILED) {
                                                        s9 = [s9, s10, s11, s12, s13, s14];
                                                        s8 = s9;
                                                    }
                                                    else {
                                                        peg$currPos = s8;
                                                        s8 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s8;
                                                    s8 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s8;
                                                s8 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                                while (s8 !== peg$FAILED) {
                                    s7.push(s8);
                                    s8 = peg$currPos;
                                    s9 = peg$parsewhiteSpace();
                                    if (s9 !== peg$FAILED) {
                                        if (input.substr(peg$currPos, 3) === peg$c75) {
                                            s10 = peg$c75;
                                            peg$currPos += 3;
                                        }
                                        else {
                                            s10 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c76);
                                            }
                                        }
                                        if (s10 !== peg$FAILED) {
                                            s11 = peg$parsewhiteSpace();
                                            if (s11 !== peg$FAILED) {
                                                if (input.substr(peg$currPos, 2) === peg$c73) {
                                                    s12 = peg$c73;
                                                    peg$currPos += 2;
                                                }
                                                else {
                                                    s12 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c74);
                                                    }
                                                }
                                                if (s12 !== peg$FAILED) {
                                                    s13 = peg$parsewhiteSpace();
                                                    if (s13 !== peg$FAILED) {
                                                        s14 = peg$parselowerIdent();
                                                        if (s14 !== peg$FAILED) {
                                                            s9 = [s9, s10, s11, s12, s13, s14];
                                                            s8 = s9;
                                                        }
                                                        else {
                                                            peg$currPos = s8;
                                                            s8 = peg$FAILED;
                                                        }
                                                    }
                                                    else {
                                                        peg$currPos = s8;
                                                        s8 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s8;
                                                    s8 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s8;
                                                s8 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parseeolWhiteSpace();
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c77(s3, s6, s7);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseImport() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c78) {
            s1 = peg$c78;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c79);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseid();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c80(s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseInterface() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c82) {
            s1 = peg$c82;
            peg$currPos += 9;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c83);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseupperIdent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    s5 = peg$parsewhiteSpace();
                    if (s5 === peg$FAILED) {
                        s5 = null;
                    }
                    if (s5 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 60) {
                            s6 = peg$c59;
                            peg$currPos++;
                        }
                        else {
                            s6 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c60);
                            }
                        }
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parsewhiteSpace();
                            if (s7 === peg$FAILED) {
                                s7 = null;
                            }
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parseTypeVariableList();
                                if (s8 !== peg$FAILED) {
                                    s9 = peg$parsewhiteSpace();
                                    if (s9 === peg$FAILED) {
                                        s9 = null;
                                    }
                                    if (s9 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 62) {
                                            s10 = peg$c61;
                                            peg$currPos++;
                                        }
                                        else {
                                            s10 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c62);
                                            }
                                        }
                                        if (s10 !== peg$FAILED) {
                                            s5 = [s5, s6, s7, s8, s9, s10];
                                            s4 = s5;
                                        }
                                        else {
                                            peg$currPos = s4;
                                            s4 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s4;
                                        s4 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseeolWhiteSpace();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$currPos;
                            s7 = peg$parseIndent();
                            if (s7 !== peg$FAILED) {
                                s8 = [];
                                s9 = peg$currPos;
                                s10 = peg$parseSameIndent();
                                if (s10 !== peg$FAILED) {
                                    s11 = peg$parseInterfaceArgument();
                                    if (s11 !== peg$FAILED) {
                                        s10 = [s10, s11];
                                        s9 = s10;
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                }
                                while (s9 !== peg$FAILED) {
                                    s8.push(s9);
                                    s9 = peg$currPos;
                                    s10 = peg$parseSameIndent();
                                    if (s10 !== peg$FAILED) {
                                        s11 = peg$parseInterfaceArgument();
                                        if (s11 !== peg$FAILED) {
                                            s10 = [s10, s11];
                                            s9 = s10;
                                        }
                                        else {
                                            peg$currPos = s9;
                                            s9 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                if (s8 !== peg$FAILED) {
                                    s7 = [s7, s8];
                                    s6 = s7;
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseeolWhiteSpace();
                                if (s7 === peg$FAILED) {
                                    s7 = null;
                                }
                                if (s7 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c84(s3, s4, s6);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c81);
            }
        }
        return s0;
    }
    function peg$parseInterfaceArgument() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseNameWithColon();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseDirection();
            if (s2 === peg$FAILED) {
                s2 = peg$parseSlotDirection();
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 63) {
                    s3 = peg$c85;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c86);
                    }
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    s5 = peg$parsewhiteSpace();
                    if (s5 === peg$FAILED) {
                        s5 = null;
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parseParticleHandleConnectionType();
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseeolWhiteSpace();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c87(s1, s2, s3, s4);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseDirection();
            if (s1 === peg$FAILED) {
                s1 = peg$parseSlotDirection();
            }
            if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 63) {
                    s2 = peg$c85;
                    peg$currPos++;
                }
                else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c86);
                    }
                }
                if (s2 === peg$FAILED) {
                    s2 = null;
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseParticleHandleConnectionType();
                        if (s5 !== peg$FAILED) {
                            s4 = [s4, s5];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                        s3 = null;
                    }
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parseeolWhiteSpace();
                        if (s4 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c88(s1, s2, s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 63) {
                    s1 = peg$c85;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c86);
                    }
                }
                if (s1 === peg$FAILED) {
                    s1 = null;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = peg$parsewhiteSpace();
                    if (s3 === peg$FAILED) {
                        s3 = null;
                    }
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parseParticleHandleConnectionType();
                        if (s4 !== peg$FAILED) {
                            s3 = [s3, s4];
                            s2 = s3;
                        }
                        else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseeolWhiteSpace();
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c89(s1, s2);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
        }
        return s0;
    }
    function peg$parseMeta() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c90) {
            s1 = peg$c90;
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c91);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseeolWhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseIndent();
                if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$currPos;
                    s7 = peg$parseSameIndent();
                    if (s7 !== peg$FAILED) {
                        s8 = peg$parseMetaItem();
                        if (s8 !== peg$FAILED) {
                            s7 = [s7, s8];
                            s6 = s7;
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                    }
                    while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$currPos;
                        s7 = peg$parseSameIndent();
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parseMetaItem();
                            if (s8 !== peg$FAILED) {
                                s7 = [s7, s8];
                                s6 = s7;
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c92(s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMetaItem() {
        let s0;
        s0 = peg$parseMetaStorageKey();
        if (s0 === peg$FAILED) {
            s0 = peg$parseMetaName();
            if (s0 === peg$FAILED) {
                s0 = peg$parseMetaNamespace();
            }
        }
        return s0;
    }
    function peg$parseMetaName() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c93) {
            s1 = peg$c93;
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c94);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c36;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c37);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseid();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c95(s5);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMetaStorageKey() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 10) === peg$c96) {
            s1 = peg$c96;
            peg$currPos += 10;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c97);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c36;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c37);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseid();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c98(s5);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMetaNamespace() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c99) {
            s1 = peg$c99;
            peg$currPos += 9;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c100);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c36;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c37);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsedottedName();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c101(s5);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticle() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 8) === peg$c102) {
            s2 = peg$c102;
            peg$currPos += 8;
        }
        else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c103);
            }
        }
        if (s2 !== peg$FAILED) {
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 8) === peg$c104) {
                s2 = peg$c104;
                peg$currPos += 8;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c105);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseupperIdent();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$currPos;
                        s6 = peg$parsewhiteSpace();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseVerbList();
                            if (s7 !== peg$FAILED) {
                                s6 = [s6, s7];
                                s5 = s6;
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$currPos;
                            s7 = peg$parsewhiteSpace();
                            if (s7 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c19) {
                                    s8 = peg$c19;
                                    peg$currPos += 2;
                                }
                                else {
                                    s8 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c20);
                                    }
                                }
                                if (s8 !== peg$FAILED) {
                                    s9 = peg$parsewhiteSpace();
                                    if (s9 !== peg$FAILED) {
                                        s10 = peg$parseid();
                                        if (s10 !== peg$FAILED) {
                                            s7 = [s7, s8, s9, s10];
                                            s6 = s7;
                                        }
                                        else {
                                            peg$currPos = s6;
                                            s6 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s6;
                                        s6 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseeolWhiteSpace();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$currPos;
                                    s9 = peg$parseIndent();
                                    if (s9 !== peg$FAILED) {
                                        s10 = [];
                                        s11 = peg$currPos;
                                        s12 = peg$parseSameIndent();
                                        if (s12 !== peg$FAILED) {
                                            s13 = peg$parseParticleItem();
                                            if (s13 !== peg$FAILED) {
                                                s12 = [s12, s13];
                                                s11 = s12;
                                            }
                                            else {
                                                peg$currPos = s11;
                                                s11 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s11;
                                            s11 = peg$FAILED;
                                        }
                                        while (s11 !== peg$FAILED) {
                                            s10.push(s11);
                                            s11 = peg$currPos;
                                            s12 = peg$parseSameIndent();
                                            if (s12 !== peg$FAILED) {
                                                s13 = peg$parseParticleItem();
                                                if (s13 !== peg$FAILED) {
                                                    s12 = [s12, s13];
                                                    s11 = s12;
                                                }
                                                else {
                                                    peg$currPos = s11;
                                                    s11 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s11;
                                                s11 = peg$FAILED;
                                            }
                                        }
                                        if (s10 !== peg$FAILED) {
                                            s9 = [s9, s10];
                                            s8 = s9;
                                        }
                                        else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                    if (s8 === peg$FAILED) {
                                        s8 = null;
                                    }
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$parseeolWhiteSpace();
                                        if (s9 === peg$FAILED) {
                                            s9 = null;
                                        }
                                        if (s9 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c106(s1, s4, s5, s6, s8);
                                            s0 = s1;
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleItem() {
        let s0, s1;
        peg$silentFails++;
        s0 = peg$parseParticleModality();
        if (s0 === peg$FAILED) {
            s0 = peg$parseParticleSlotConnection();
            if (s0 === peg$FAILED) {
                s0 = peg$parseDescription();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseParticleHandleConnection();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseClaimStatement();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseCheckStatement();
                        }
                    }
                }
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c107);
            }
        }
        return s0;
    }
    function peg$parseClaimStatement() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c69) {
            s1 = peg$c69;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c70);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsedottedFields();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseClaimExpression();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c108(s3, s5);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseClaimExpression() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseClaim();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsewhiteSpace();
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c75) {
                    s5 = peg$c75;
                    peg$currPos += 3;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c76);
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsewhiteSpace();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseClaim();
                        if (s7 !== peg$FAILED) {
                            s4 = [s4, s5, s6, s7];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c75) {
                        s5 = peg$c75;
                        peg$currPos += 3;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c76);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseClaim();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c109(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseClaim() {
        let s0;
        s0 = peg$parseClaimIsTag();
        if (s0 === peg$FAILED) {
            s0 = peg$parseClaimDerivesFrom();
        }
        return s0;
    }
    function peg$parseClaimIsTag() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c73) {
            s1 = peg$c73;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c74);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                if (input.substr(peg$currPos, 3) === peg$c110) {
                    s4 = peg$c110;
                    peg$currPos += 3;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c111);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsewhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parselowerIdent();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c112(s3, s4);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseClaimDerivesFrom() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 7) === peg$c113) {
            s1 = peg$c113;
            peg$currPos += 7;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c114);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c115) {
                    s3 = peg$c115;
                    peg$currPos += 4;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c116);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsedottedFields();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c117(s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseCheckStatement() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c118) {
            s1 = peg$c118;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c119);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseCheckTarget();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseCheckExpressionBody();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c120(s3, s5);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseCheckTarget() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parsedottedFields();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c121) {
                    s4 = peg$c121;
                    peg$currPos += 4;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c122);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c123(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseCheckExpressionBody() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseCheckExpression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsewhiteSpace();
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c124) {
                    s5 = peg$c124;
                    peg$currPos += 2;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c125);
                    }
                }
                if (s5 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c75) {
                        s5 = peg$c75;
                        peg$currPos += 3;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c76);
                        }
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsewhiteSpace();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseCheckExpression();
                        if (s7 !== peg$FAILED) {
                            s4 = [s4, s5, s6, s7];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c124) {
                        s5 = peg$c124;
                        peg$currPos += 2;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c125);
                        }
                    }
                    if (s5 === peg$FAILED) {
                        if (input.substr(peg$currPos, 3) === peg$c75) {
                            s5 = peg$c75;
                            peg$currPos += 3;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c76);
                            }
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseCheckExpression();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c126(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseCheckExpression() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseCheckCondition();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c127(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
                s1 = peg$c45;
                peg$currPos++;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c46);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parsewhiteSpace();
                if (s2 === peg$FAILED) {
                    s2 = null;
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$parseCheckExpressionBody();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parsewhiteSpace();
                        if (s4 === peg$FAILED) {
                            s4 = null;
                        }
                        if (s4 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s5 = peg$c47;
                                peg$currPos++;
                            }
                            else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c48);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c127(s3);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parseCheckCondition() {
        let s0;
        s0 = peg$parseCheckImplication();
        if (s0 === peg$FAILED) {
            s0 = peg$parseCheckIsFromHandle();
            if (s0 === peg$FAILED) {
                s0 = peg$parseCheckIsFromStore();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseCheckIsFromOutput();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseCheckHasTag();
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseCheckImplication() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c45;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c46);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseCheckExpression();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c128) {
                            s5 = peg$c128;
                            peg$currPos += 2;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c129);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parsewhiteSpace();
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseCheckExpression();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parsewhiteSpace();
                                    if (s8 === peg$FAILED) {
                                        s8 = null;
                                    }
                                    if (s8 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 41) {
                                            s9 = peg$c47;
                                            peg$currPos++;
                                        }
                                        else {
                                            s9 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c48);
                                            }
                                        }
                                        if (s9 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c130(s3, s7);
                                            s0 = s1;
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseCheckHasTag() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c73) {
            s1 = peg$c73;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c74);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                if (input.substr(peg$currPos, 3) === peg$c110) {
                    s4 = peg$c110;
                    peg$currPos += 3;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c111);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsewhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parselowerIdent();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c131(s3, s4);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseCheckIsFromHandle() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c73) {
            s1 = peg$c73;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c74);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c110) {
                    s4 = peg$c110;
                    peg$currPos += 3;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c111);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c115) {
                        s4 = peg$c115;
                        peg$currPos += 4;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c116);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 6) === peg$c132) {
                                s6 = peg$c132;
                                peg$currPos += 6;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c133);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parsewhiteSpace();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parselowerIdent();
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c134(s2, s8);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseCheckIsFromOutput() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c73) {
            s1 = peg$c73;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c74);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c110) {
                    s4 = peg$c110;
                    peg$currPos += 3;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c111);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c115) {
                        s4 = peg$c115;
                        peg$currPos += 4;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c116);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 6) === peg$c135) {
                                s6 = peg$c135;
                                peg$currPos += 6;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c136);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parsewhiteSpace();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parselowerIdent();
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c137(s2, s8);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseCheckIsFromStore() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c73) {
            s1 = peg$c73;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c74);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c110) {
                    s4 = peg$c110;
                    peg$currPos += 3;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c111);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c115) {
                        s4 = peg$c115;
                        peg$currPos += 4;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c116);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 5) === peg$c12) {
                                s6 = peg$c12;
                                peg$currPos += 5;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c13);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parsewhiteSpace();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parseStoreReference();
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c138(s2, s8);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseStoreReference() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseupperIdent();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c139(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseid();
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c140(s1);
            }
            s0 = s1;
        }
        return s0;
    }
    function peg$parseParticleHandleConnection() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parseParticleHandleConnectionBody();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseeolWhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseIndent();
                if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$currPos;
                    s7 = peg$parseSameIndent();
                    if (s7 !== peg$FAILED) {
                        s8 = peg$parseParticleHandleConnection();
                        if (s8 !== peg$FAILED) {
                            s7 = [s7, s8];
                            s6 = s7;
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                    }
                    while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$currPos;
                        s7 = peg$parseSameIndent();
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parseParticleHandleConnection();
                            if (s8 !== peg$FAILED) {
                                s7 = [s7, s8];
                                s6 = s7;
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c141(s1, s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseNameWithColon() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$currPos;
        s3 = peg$parseunsafeLowerIdent();
        if (s3 !== peg$FAILED) {
            s4 = peg$parsewhiteSpace();
            if (s4 === peg$FAILED) {
                s4 = null;
            }
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s5 = peg$c36;
                    peg$currPos++;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c37);
                    }
                }
                if (s5 !== peg$FAILED) {
                    s3 = [s3, s4, s5];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
            peg$currPos = s1;
            s1 = undefined;
        }
        else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parselowerIdent();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                        s4 = peg$c36;
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c37);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c142(s2);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsePaxelMode() {
        let s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 61) {
            s1 = peg$c143;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c144);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c145();
        }
        s0 = s1;
        return s0;
    }
    function peg$parseParticleHandleConnectionBody() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        s0 = peg$currPos;
        s1 = peg$parseNameWithColon();
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseDirection();
            if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 63) {
                    s4 = peg$c85;
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c86);
                    }
                }
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseParticleHandleConnectionType();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseSpaceAnnotationRefList();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseSpaceTagList();
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$currPos;
                                s8 = peg$parsewhiteSpace();
                                if (s8 === peg$FAILED) {
                                    s8 = null;
                                }
                                if (s8 !== peg$FAILED) {
                                    s9 = peg$parsePaxelMode();
                                    if (s9 !== peg$FAILED) {
                                        s10 = peg$parsemultiLineSpace();
                                        if (s10 !== peg$FAILED) {
                                            s11 = peg$parsePaxelExpression();
                                            if (s11 !== peg$FAILED) {
                                                s8 = [s8, s9, s10, s11];
                                                s7 = s8;
                                            }
                                            else {
                                                peg$currPos = s7;
                                                s7 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s7;
                                            s7 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s7;
                                        s7 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s7;
                                    s7 = peg$FAILED;
                                }
                                if (s7 === peg$FAILED) {
                                    s7 = null;
                                }
                                if (s7 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c146(s1, s2, s4, s5, s6, s7);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseDirection() {
        let s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c148) {
            s2 = peg$c148;
            peg$currPos += 5;
        }
        else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c149);
            }
        }
        if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 63) {
                s3 = peg$c85;
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c86);
                }
            }
            if (s3 === peg$FAILED) {
                s3 = null;
            }
            if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c150) {
                    s4 = peg$c150;
                    peg$currPos += 7;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c151);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s2 = [s2, s3, s4];
                    s1 = s2;
                }
                else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c148) {
                s1 = peg$c148;
                peg$currPos += 5;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c149);
                }
            }
            if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c152) {
                    s1 = peg$c152;
                    peg$currPos += 6;
                }
                else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c153);
                    }
                }
                if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5) === peg$c154) {
                        s1 = peg$c154;
                        peg$currPos += 5;
                    }
                    else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c155);
                        }
                    }
                    if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 9) === peg$c156) {
                            s1 = peg$c156;
                            peg$currPos += 9;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c157);
                            }
                        }
                        if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 9) === peg$c158) {
                                s1 = peg$c158;
                                peg$currPos += 9;
                            }
                            else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c159);
                                }
                            }
                        }
                    }
                }
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c160.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c161);
                }
            }
            if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                peg$silentFails++;
                if (input.length > peg$currPos) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c162);
                    }
                }
                peg$silentFails--;
                if (s4 === peg$FAILED) {
                    s3 = undefined;
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            peg$silentFails--;
            if (s3 !== peg$FAILED) {
                peg$currPos = s2;
                s2 = undefined;
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c163();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c147);
            }
        }
        return s0;
    }
    function peg$parseParticleHandleConnectionType() {
        let s0, s1, s2, s3;
        s0 = peg$parseTypeVariable();
        if (s0 === peg$FAILED) {
            s0 = peg$parseSingletonType();
            if (s0 === peg$FAILED) {
                s0 = peg$parseCollectionType();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseBigCollectionType();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseReferenceType();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseMuxType();
                            if (s0 === peg$FAILED) {
                                s0 = peg$parseSlotType();
                                if (s0 === peg$FAILED) {
                                    s0 = peg$parseTupleType();
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        s1 = peg$parseSchemaInline();
                                        if (s1 !== peg$FAILED) {
                                            s2 = peg$parsewhiteSpace();
                                            if (s2 === peg$FAILED) {
                                                s2 = null;
                                            }
                                            if (s2 !== peg$FAILED) {
                                                s3 = peg$parseRefinement();
                                                if (s3 === peg$FAILED) {
                                                    s3 = null;
                                                }
                                                if (s3 !== peg$FAILED) {
                                                    peg$savedPos = s0;
                                                    s1 = peg$c164(s1, s3);
                                                    s0 = s1;
                                                }
                                                else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                        if (s0 === peg$FAILED) {
                                            s0 = peg$parseTypeName();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseSingletonType() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c165) {
            s1 = peg$c165;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c166);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseParticleHandleConnectionType();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c42;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c43);
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c167(s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseCollectionType() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c40;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c41);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseParticleHandleConnectionType();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c42;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c43);
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c168(s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseBigCollectionType() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 14) === peg$c169) {
            s1 = peg$c169;
            peg$currPos += 14;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c170);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseParticleHandleConnectionType();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 62) {
                    s3 = peg$c61;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c62);
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c171(s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseReferenceType() {
        let s0, s1, s2;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
            s1 = peg$c172;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c173);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseParticleHandleConnectionType();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c174(s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMuxType() {
        let s0, s1, s2;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c175;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c176);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseParticleHandleConnectionType();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c177(s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTupleType() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c45;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c46);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsemultiLineSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseParticleHandleConnectionType();
                if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$currPos;
                    s6 = peg$parsemultiLineSpace();
                    if (s6 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s7 = peg$c30;
                            peg$currPos++;
                        }
                        else {
                            s7 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c31);
                            }
                        }
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsemultiLineSpace();
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parseParticleHandleConnectionType();
                                if (s9 !== peg$FAILED) {
                                    s6 = [s6, s7, s8, s9];
                                    s5 = s6;
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                    }
                    while (s5 !== peg$FAILED) {
                        s4.push(s5);
                        s5 = peg$currPos;
                        s6 = peg$parsemultiLineSpace();
                        if (s6 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s7 = peg$c30;
                                peg$currPos++;
                            }
                            else {
                                s7 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c31);
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parsemultiLineSpace();
                                if (s8 !== peg$FAILED) {
                                    s9 = peg$parseParticleHandleConnectionType();
                                    if (s9 !== peg$FAILED) {
                                        s6 = [s6, s7, s8, s9];
                                        s5 = s6;
                                    }
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsemultiLineSpace();
                        if (s5 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s6 = peg$c30;
                                peg$currPos++;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c31);
                                }
                            }
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parsemultiLineSpace();
                                if (s7 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 41) {
                                        s8 = peg$c47;
                                        peg$currPos++;
                                    }
                                    else {
                                        s8 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c48);
                                        }
                                    }
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c179(s3, s4);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c178);
            }
        }
        return s0;
    }
    function peg$parseTypeVariable() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 126) {
            s1 = peg$c181;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c182);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parselowerIdent();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c26) {
                        s5 = peg$c26;
                        peg$currPos += 4;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c27);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseParticleHandleConnectionType();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c183(s2, s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c180);
            }
        }
        return s0;
    }
    function peg$parseSlotType() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c184) {
            s1 = peg$c184;
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c185);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c162);
                }
            }
            peg$silentFails--;
            if (s4 === peg$FAILED) {
                s3 = undefined;
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
                if (peg$c186.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c187);
                    }
                }
            }
            peg$silentFails--;
            if (s3 !== peg$FAILED) {
                peg$currPos = s2;
                s2 = undefined;
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s5 = peg$c28;
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c29);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$currPos;
                        s7 = peg$parseSlotField();
                        if (s7 !== peg$FAILED) {
                            s8 = [];
                            s9 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s10 = peg$c30;
                                peg$currPos++;
                            }
                            else {
                                s10 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c31);
                                }
                            }
                            if (s10 !== peg$FAILED) {
                                s11 = peg$parsewhiteSpace();
                                if (s11 !== peg$FAILED) {
                                    s12 = peg$parseSlotField();
                                    if (s12 !== peg$FAILED) {
                                        s10 = [s10, s11, s12];
                                        s9 = s10;
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s9;
                                s9 = peg$FAILED;
                            }
                            while (s9 !== peg$FAILED) {
                                s8.push(s9);
                                s9 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 44) {
                                    s10 = peg$c30;
                                    peg$currPos++;
                                }
                                else {
                                    s10 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c31);
                                    }
                                }
                                if (s10 !== peg$FAILED) {
                                    s11 = peg$parsewhiteSpace();
                                    if (s11 !== peg$FAILED) {
                                        s12 = peg$parseSlotField();
                                        if (s12 !== peg$FAILED) {
                                            s10 = [s10, s11, s12];
                                            s9 = s10;
                                        }
                                        else {
                                            peg$currPos = s9;
                                            s9 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                }
                            }
                            if (s8 !== peg$FAILED) {
                                s7 = [s7, s8];
                                s6 = s7;
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 125) {
                                s7 = peg$c32;
                                peg$currPos++;
                            }
                            else {
                                s7 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c33);
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c188(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSlotField() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsefieldName();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c36;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c37);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parselowerIdent();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c189(s1, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTypeName() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseupperIdent();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c190(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseTypeVariableList() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseTypeVariable();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c30;
                peg$currPos++;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c31);
                }
            }
            if (s4 !== peg$FAILED) {
                s5 = peg$parsemultiLineSpace();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parseTypeVariable();
                    if (s6 !== peg$FAILED) {
                        s4 = [s4, s5, s6];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                    s4 = peg$c30;
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c31);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsemultiLineSpace();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parseTypeVariable();
                        if (s6 !== peg$FAILED) {
                            s4 = [s4, s5, s6];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c191(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleModality() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 8) === peg$c192) {
            s1 = peg$c192;
            peg$currPos += 8;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c193);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsefieldName();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c194(s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSlandleType() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parsewhiteSpace();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseParticleHandleConnectionType();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c195(s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleSlotConnection() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
        s0 = peg$currPos;
        s1 = peg$parseNameWithColon();
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 8) === peg$c196) {
                s2 = peg$c196;
                peg$currPos += 8;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c197);
                }
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 63) {
                    s3 = peg$c85;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c86);
                    }
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseSlandleType();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseSpaceTagList();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$currPos;
                                s8 = peg$parseIndent();
                                if (s8 !== peg$FAILED) {
                                    s9 = [];
                                    s10 = peg$currPos;
                                    s11 = peg$parseSameIndent();
                                    if (s11 !== peg$FAILED) {
                                        s12 = peg$parseParticleProvidedSlot();
                                        if (s12 !== peg$FAILED) {
                                            s11 = [s11, s12];
                                            s10 = s11;
                                        }
                                        else {
                                            peg$currPos = s10;
                                            s10 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s10;
                                        s10 = peg$FAILED;
                                    }
                                    while (s10 !== peg$FAILED) {
                                        s9.push(s10);
                                        s10 = peg$currPos;
                                        s11 = peg$parseSameIndent();
                                        if (s11 !== peg$FAILED) {
                                            s12 = peg$parseParticleProvidedSlot();
                                            if (s12 !== peg$FAILED) {
                                                s11 = [s11, s12];
                                                s10 = s11;
                                            }
                                            else {
                                                peg$currPos = s10;
                                                s10 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s10;
                                            s10 = peg$FAILED;
                                        }
                                    }
                                    if (s9 !== peg$FAILED) {
                                        s8 = [s8, s9];
                                        s7 = s8;
                                    }
                                    else {
                                        peg$currPos = s7;
                                        s7 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s7;
                                    s7 = peg$FAILED;
                                }
                                if (s7 === peg$FAILED) {
                                    s7 = null;
                                }
                                if (s7 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c198(s1, s3, s4, s5, s7);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleProvidedSlot() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseNameWithColon();
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 8) === peg$c199) {
                s2 = peg$c199;
                peg$currPos += 8;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c200);
                }
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 63) {
                    s3 = peg$c85;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c86);
                    }
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseSlandleType();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseSpaceTagList();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c201(s1, s3, s4, s5);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseDescription() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 11) === peg$c67) {
            s1 = peg$c67;
            peg$currPos += 11;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c68);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsebackquotedString();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$currPos;
                        s6 = peg$parseIndent();
                        if (s6 !== peg$FAILED) {
                            s7 = [];
                            s8 = peg$currPos;
                            s9 = peg$parseSameIndent();
                            if (s9 !== peg$FAILED) {
                                s10 = peg$parseParticleHandleDescription();
                                if (s10 !== peg$FAILED) {
                                    s9 = [s9, s10];
                                    s8 = s9;
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s8;
                                s8 = peg$FAILED;
                            }
                            if (s8 !== peg$FAILED) {
                                while (s8 !== peg$FAILED) {
                                    s7.push(s8);
                                    s8 = peg$currPos;
                                    s9 = peg$parseSameIndent();
                                    if (s9 !== peg$FAILED) {
                                        s10 = peg$parseParticleHandleDescription();
                                        if (s10 !== peg$FAILED) {
                                            s9 = [s9, s10];
                                            s8 = s9;
                                        }
                                        else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                            }
                            else {
                                s7 = peg$FAILED;
                            }
                            if (s7 !== peg$FAILED) {
                                s6 = [s6, s7];
                                s5 = s6;
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c202(s3, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleHandleDescription() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parselowerIdent();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsebackquotedString();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c203(s1, s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseAnnotationNode() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 10) === peg$c204) {
            s1 = peg$c204;
            peg$currPos += 10;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c205);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parselowerIdent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 40) {
                        s5 = peg$c45;
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c46);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseAnnotationParam();
                            if (s7 !== peg$FAILED) {
                                s8 = [];
                                s9 = peg$currPos;
                                s10 = peg$parsewhiteSpace();
                                if (s10 === peg$FAILED) {
                                    s10 = null;
                                }
                                if (s10 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 44) {
                                        s11 = peg$c30;
                                        peg$currPos++;
                                    }
                                    else {
                                        s11 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c31);
                                        }
                                    }
                                    if (s11 !== peg$FAILED) {
                                        s12 = peg$parsewhiteSpace();
                                        if (s12 === peg$FAILED) {
                                            s12 = null;
                                        }
                                        if (s12 !== peg$FAILED) {
                                            s13 = peg$parseAnnotationParam();
                                            if (s13 !== peg$FAILED) {
                                                s10 = [s10, s11, s12, s13];
                                                s9 = s10;
                                            }
                                            else {
                                                peg$currPos = s9;
                                                s9 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s9;
                                            s9 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                }
                                while (s9 !== peg$FAILED) {
                                    s8.push(s9);
                                    s9 = peg$currPos;
                                    s10 = peg$parsewhiteSpace();
                                    if (s10 === peg$FAILED) {
                                        s10 = null;
                                    }
                                    if (s10 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 44) {
                                            s11 = peg$c30;
                                            peg$currPos++;
                                        }
                                        else {
                                            s11 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c31);
                                            }
                                        }
                                        if (s11 !== peg$FAILED) {
                                            s12 = peg$parsewhiteSpace();
                                            if (s12 === peg$FAILED) {
                                                s12 = null;
                                            }
                                            if (s12 !== peg$FAILED) {
                                                s13 = peg$parseAnnotationParam();
                                                if (s13 !== peg$FAILED) {
                                                    s10 = [s10, s11, s12, s13];
                                                    s9 = s10;
                                                }
                                                else {
                                                    peg$currPos = s9;
                                                    s9 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s9;
                                                s9 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s9;
                                            s9 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                if (s8 !== peg$FAILED) {
                                    s9 = peg$parsewhiteSpace();
                                    if (s9 === peg$FAILED) {
                                        s9 = null;
                                    }
                                    if (s9 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 41) {
                                            s10 = peg$c47;
                                            peg$currPos++;
                                        }
                                        else {
                                            s10 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c48);
                                            }
                                        }
                                        if (s10 !== peg$FAILED) {
                                            s5 = [s5, s6, s7, s8, s9, s10];
                                            s4 = s5;
                                        }
                                        else {
                                            peg$currPos = s4;
                                            s4 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s4;
                                        s4 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s4;
                                    s4 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseeolWhiteSpace();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$currPos;
                            s7 = peg$parseIndent();
                            if (s7 !== peg$FAILED) {
                                s8 = [];
                                s9 = peg$currPos;
                                s10 = peg$parseSameIndent();
                                if (s10 !== peg$FAILED) {
                                    s11 = peg$parseAnnotationNodeItem();
                                    if (s11 !== peg$FAILED) {
                                        s10 = [s10, s11];
                                        s9 = s10;
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                }
                                while (s9 !== peg$FAILED) {
                                    s8.push(s9);
                                    s9 = peg$currPos;
                                    s10 = peg$parseSameIndent();
                                    if (s10 !== peg$FAILED) {
                                        s11 = peg$parseAnnotationNodeItem();
                                        if (s11 !== peg$FAILED) {
                                            s10 = [s10, s11];
                                            s9 = s10;
                                        }
                                        else {
                                            peg$currPos = s9;
                                            s9 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                if (s8 !== peg$FAILED) {
                                    s7 = [s7, s8];
                                    s6 = s7;
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c206(s3, s4, s6);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseAnnotationParam() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parsefieldName();
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
                s2 = peg$c36;
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c37);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseSchemaPrimitiveType();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c207(s1, s4);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseAnnotationNodeItem() {
        let s0;
        s0 = peg$parseAnnotationTargets();
        if (s0 === peg$FAILED) {
            s0 = peg$parseAnnotationRetention();
            if (s0 === peg$FAILED) {
                s0 = peg$parseAnnotationMultiple();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseAnnotationDoc();
                }
            }
        }
        return s0;
    }
    function peg$parseAnnotationTargetValue() {
        let s0;
        if (input.substr(peg$currPos, 6) === peg$c208) {
            s0 = peg$c208;
            peg$currPos += 6;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c209);
            }
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 8) === peg$c210) {
                s0 = peg$c210;
                peg$currPos += 8;
            }
            else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c211);
                }
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 16) === peg$c212) {
                    s0 = peg$c212;
                    peg$currPos += 16;
                }
                else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c213);
                    }
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5) === peg$c214) {
                        s0 = peg$c214;
                        peg$currPos += 5;
                    }
                    else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c215);
                        }
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6) === peg$c216) {
                            s0 = peg$c216;
                            peg$currPos += 6;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c217);
                            }
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 11) === peg$c218) {
                                s0 = peg$c218;
                                peg$currPos += 11;
                            }
                            else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c219);
                                }
                            }
                            if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 6) === peg$c220) {
                                    s0 = peg$c220;
                                    peg$currPos += 6;
                                }
                                else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c221);
                                    }
                                }
                                if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 11) === peg$c222) {
                                        s0 = peg$c222;
                                        peg$currPos += 11;
                                    }
                                    else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c223);
                                        }
                                    }
                                    if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 12) === peg$c224) {
                                            s0 = peg$c224;
                                            peg$currPos += 12;
                                        }
                                        else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c225);
                                            }
                                        }
                                        if (s0 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 6) === peg$c226) {
                                                s0 = peg$c226;
                                                peg$currPos += 6;
                                            }
                                            else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c227);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseAnnotationTargets() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 8) === peg$c228) {
            s1 = peg$c228;
            peg$currPos += 8;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c229);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 91) {
                    s3 = peg$c40;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c41);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$currPos;
                        s6 = peg$parseAnnotationTargetValue();
                        if (s6 !== peg$FAILED) {
                            s7 = [];
                            s8 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s9 = peg$c30;
                                peg$currPos++;
                            }
                            else {
                                s9 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c31);
                                }
                            }
                            if (s9 !== peg$FAILED) {
                                s10 = peg$parsewhiteSpace();
                                if (s10 === peg$FAILED) {
                                    s10 = null;
                                }
                                if (s10 !== peg$FAILED) {
                                    s11 = peg$parseAnnotationTargetValue();
                                    if (s11 !== peg$FAILED) {
                                        s9 = [s9, s10, s11];
                                        s8 = s9;
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s8;
                                s8 = peg$FAILED;
                            }
                            while (s8 !== peg$FAILED) {
                                s7.push(s8);
                                s8 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 44) {
                                    s9 = peg$c30;
                                    peg$currPos++;
                                }
                                else {
                                    s9 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c31);
                                    }
                                }
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parsewhiteSpace();
                                    if (s10 === peg$FAILED) {
                                        s10 = null;
                                    }
                                    if (s10 !== peg$FAILED) {
                                        s11 = peg$parseAnnotationTargetValue();
                                        if (s11 !== peg$FAILED) {
                                            s9 = [s9, s10, s11];
                                            s8 = s9;
                                        }
                                        else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s6 = [s6, s7];
                                s5 = s6;
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parsewhiteSpace();
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 93) {
                                    s7 = peg$c42;
                                    peg$currPos++;
                                }
                                else {
                                    s7 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c43);
                                    }
                                }
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parseeolWhiteSpace();
                                    if (s8 === peg$FAILED) {
                                        s8 = null;
                                    }
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c230(s5);
                                        s0 = s1;
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseAnnotationRetentionValue() {
        let s0;
        if (input.substr(peg$currPos, 6) === peg$c231) {
            s0 = peg$c231;
            peg$currPos += 6;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c232);
            }
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 7) === peg$c233) {
                s0 = peg$c233;
                peg$currPos += 7;
            }
            else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c234);
                }
            }
        }
        return s0;
    }
    function peg$parseAnnotationRetention() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 10) === peg$c235) {
            s1 = peg$c235;
            peg$currPos += 10;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c236);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseAnnotationRetentionValue();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c237(s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseAnnotationMultiple() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 14) === peg$c238) {
            s1 = peg$c238;
            peg$currPos += 14;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c239);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                if (input.substr(peg$currPos, 4).toLowerCase() === peg$c51) {
                    s3 = input.substr(peg$currPos, 4);
                    peg$currPos += 4;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c52);
                    }
                }
                if (s3 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c53) {
                        s3 = input.substr(peg$currPos, 5);
                        peg$currPos += 5;
                    }
                    else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c54);
                        }
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c240(s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseAnnotationDoc() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c241) {
            s1 = peg$c241;
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c242);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseQuotedString();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c243(s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseAnnotationRef() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 64) {
            s1 = peg$c244;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c245);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parselowerIdent();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 40) {
                        s5 = peg$c45;
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c46);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseAnnotationRefParam();
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parsewhiteSpace();
                                if (s8 === peg$FAILED) {
                                    s8 = null;
                                }
                                if (s8 !== peg$FAILED) {
                                    s9 = [];
                                    s10 = peg$currPos;
                                    s11 = peg$parsewhiteSpace();
                                    if (s11 === peg$FAILED) {
                                        s11 = null;
                                    }
                                    if (s11 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 44) {
                                            s12 = peg$c30;
                                            peg$currPos++;
                                        }
                                        else {
                                            s12 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c31);
                                            }
                                        }
                                        if (s12 !== peg$FAILED) {
                                            s13 = peg$parsewhiteSpace();
                                            if (s13 === peg$FAILED) {
                                                s13 = null;
                                            }
                                            if (s13 !== peg$FAILED) {
                                                s14 = peg$parseAnnotationRefParam();
                                                if (s14 !== peg$FAILED) {
                                                    s11 = [s11, s12, s13, s14];
                                                    s10 = s11;
                                                }
                                                else {
                                                    peg$currPos = s10;
                                                    s10 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s10;
                                                s10 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s10;
                                            s10 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s10;
                                        s10 = peg$FAILED;
                                    }
                                    while (s10 !== peg$FAILED) {
                                        s9.push(s10);
                                        s10 = peg$currPos;
                                        s11 = peg$parsewhiteSpace();
                                        if (s11 === peg$FAILED) {
                                            s11 = null;
                                        }
                                        if (s11 !== peg$FAILED) {
                                            if (input.charCodeAt(peg$currPos) === 44) {
                                                s12 = peg$c30;
                                                peg$currPos++;
                                            }
                                            else {
                                                s12 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c31);
                                                }
                                            }
                                            if (s12 !== peg$FAILED) {
                                                s13 = peg$parsewhiteSpace();
                                                if (s13 === peg$FAILED) {
                                                    s13 = null;
                                                }
                                                if (s13 !== peg$FAILED) {
                                                    s14 = peg$parseAnnotationRefParam();
                                                    if (s14 !== peg$FAILED) {
                                                        s11 = [s11, s12, s13, s14];
                                                        s10 = s11;
                                                    }
                                                    else {
                                                        peg$currPos = s10;
                                                        s10 = peg$FAILED;
                                                    }
                                                }
                                                else {
                                                    peg$currPos = s10;
                                                    s10 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s10;
                                                s10 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s10;
                                            s10 = peg$FAILED;
                                        }
                                    }
                                    if (s9 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 41) {
                                            s10 = peg$c47;
                                            peg$currPos++;
                                        }
                                        else {
                                            s10 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c48);
                                            }
                                        }
                                        if (s10 !== peg$FAILED) {
                                            s4 = [s4, s5, s6, s7, s8, s9, s10];
                                            s3 = s4;
                                        }
                                        else {
                                            peg$currPos = s3;
                                            s3 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s3;
                                        s3 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s3;
                                    s3 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c246(s2, s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseAnnotationRefParam() {
        let s0;
        s0 = peg$parseAnnotationRefNamedParam();
        if (s0 === peg$FAILED) {
            s0 = peg$parseAnnotationRefSimpleParam();
        }
        return s0;
    }
    function peg$parseAnnotationRefNamedParam() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parselowerIdent();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c36;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c37);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseAnnotationRefSimpleParam();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c247(s1, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseAnnotationRefSimpleParam() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseManifestStorageInlineData();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c248(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseAnnotationRefList() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseAnnotationRef();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseSpaceAnnotationRefList();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c249(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSpaceAnnotationRefList() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parsewhiteSpace();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseAnnotationRefList();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c250(s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeNode() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c251) {
            s1 = peg$c251;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c252);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseupperIdent();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseVerbList();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$currPos;
                        s6 = peg$parseIndent();
                        if (s6 !== peg$FAILED) {
                            s7 = [];
                            s8 = peg$currPos;
                            s9 = peg$parseSameIndent();
                            if (s9 !== peg$FAILED) {
                                s10 = peg$parseRecipeItem();
                                if (s10 !== peg$FAILED) {
                                    s9 = [s9, s10];
                                    s8 = s9;
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s8;
                                s8 = peg$FAILED;
                            }
                            while (s8 !== peg$FAILED) {
                                s7.push(s8);
                                s8 = peg$currPos;
                                s9 = peg$parseSameIndent();
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parseRecipeItem();
                                    if (s10 !== peg$FAILED) {
                                        s9 = [s9, s10];
                                        s8 = s9;
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s6 = [s6, s7];
                                s5 = s6;
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c253(s2, s3, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeItem() {
        let s0;
        s0 = peg$parseRecipeParticle();
        if (s0 === peg$FAILED) {
            s0 = peg$parseRecipeHandle();
            if (s0 === peg$FAILED) {
                s0 = peg$parseRecipeSyntheticHandle();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseRequireHandleSection();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseRecipeRequire();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseRecipeSlot();
                            if (s0 === peg$FAILED) {
                                s0 = peg$parseRecipeSearch();
                                if (s0 === peg$FAILED) {
                                    s0 = peg$parseRecipeConnection();
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$parseDescription();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseLocalName() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c254) {
            s1 = peg$c254;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c255);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parselowerIdent();
                if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = [];
                    if (peg$c256.test(input.charAt(peg$currPos))) {
                        s5 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c257);
                        }
                    }
                    while (s5 !== peg$FAILED) {
                        s4.push(s5);
                        if (peg$c256.test(input.charAt(peg$currPos))) {
                            s5 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c257);
                            }
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c258();
                    }
                    s3 = s4;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c142(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTopLevelAlias() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c254) {
            s1 = peg$c254;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c255);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseupperIdent();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c142(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeParticle() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$parseParticleRef();
        if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 42) {
                s1 = peg$c259;
                peg$currPos++;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c260);
                }
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseLocalName();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseeolWhiteSpace();
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    s5 = peg$parseIndent();
                    if (s5 !== peg$FAILED) {
                        s6 = [];
                        s7 = peg$currPos;
                        s8 = peg$parseSameIndent();
                        if (s8 !== peg$FAILED) {
                            s9 = peg$parseRecipeParticleConnection();
                            if (s9 !== peg$FAILED) {
                                s8 = [s8, s9];
                                s7 = s8;
                            }
                            else {
                                peg$currPos = s7;
                                s7 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s7;
                            s7 = peg$FAILED;
                        }
                        while (s7 !== peg$FAILED) {
                            s6.push(s7);
                            s7 = peg$currPos;
                            s8 = peg$parseSameIndent();
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parseRecipeParticleConnection();
                                if (s9 !== peg$FAILED) {
                                    s8 = [s8, s9];
                                    s7 = s8;
                                }
                                else {
                                    peg$currPos = s7;
                                    s7 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s7;
                                s7 = peg$FAILED;
                            }
                        }
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c261(s1, s2, s4);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeParticleConnection() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        s0 = peg$currPos;
        s1 = peg$parseNameWithColon();
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseSlotDirection();
            if (s3 === peg$FAILED) {
                s3 = peg$parseDirection();
            }
            if (s3 !== peg$FAILED) {
                s4 = peg$parsewhiteSpace();
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                if (input.substr(peg$currPos, 6) === peg$c262) {
                    s4 = peg$c262;
                    peg$currPos += 6;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c263);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsewhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseParticleConnectionTargetComponents();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseeolWhiteSpace();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$currPos;
                            s7 = peg$parseIndent();
                            if (s7 !== peg$FAILED) {
                                s8 = [];
                                s9 = peg$currPos;
                                s10 = peg$parseSameIndent();
                                if (s10 !== peg$FAILED) {
                                    s11 = peg$parseRecipeParticleConnection();
                                    if (s11 !== peg$FAILED) {
                                        s10 = [s10, s11];
                                        s9 = s10;
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s9;
                                    s9 = peg$FAILED;
                                }
                                while (s9 !== peg$FAILED) {
                                    s8.push(s9);
                                    s9 = peg$currPos;
                                    s10 = peg$parseSameIndent();
                                    if (s10 !== peg$FAILED) {
                                        s11 = peg$parseRecipeParticleConnection();
                                        if (s11 !== peg$FAILED) {
                                            s10 = [s10, s11];
                                            s9 = s10;
                                        }
                                        else {
                                            peg$currPos = s9;
                                            s9 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s9;
                                        s9 = peg$FAILED;
                                    }
                                }
                                if (s8 !== peg$FAILED) {
                                    s7 = [s7, s8];
                                    s6 = s7;
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c264(s1, s2, s3, s4, s6);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseNameWithColon();
            if (s1 === peg$FAILED) {
                s1 = null;
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                if (input.substr(peg$currPos, 6) === peg$c262) {
                    s3 = peg$c262;
                    peg$currPos += 6;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c263);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s3 = [s3, s4];
                        s2 = s3;
                    }
                    else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
                if (s2 === peg$FAILED) {
                    s2 = null;
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$parseParticleConnectionTargetComponents();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parseeolWhiteSpace();
                        if (s4 !== peg$FAILED) {
                            s5 = peg$currPos;
                            s6 = peg$parseIndent();
                            if (s6 !== peg$FAILED) {
                                s7 = [];
                                s8 = peg$currPos;
                                s9 = peg$parseSameIndent();
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parseRecipeParticleConnection();
                                    if (s10 !== peg$FAILED) {
                                        s9 = [s9, s10];
                                        s8 = s9;
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                                while (s8 !== peg$FAILED) {
                                    s7.push(s8);
                                    s8 = peg$currPos;
                                    s9 = peg$parseSameIndent();
                                    if (s9 !== peg$FAILED) {
                                        s10 = peg$parseRecipeParticleConnection();
                                        if (s10 !== peg$FAILED) {
                                            s9 = [s9, s10];
                                            s8 = s9;
                                        }
                                        else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                                if (s7 !== peg$FAILED) {
                                    s6 = [s6, s7];
                                    s5 = s6;
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                            if (s5 === peg$FAILED) {
                                s5 = null;
                            }
                            if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c265(s1, s2, s3, s5);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parseParticleConnectionTargetComponents() {
        let s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseupperIdent();
        if (s1 === peg$FAILED) {
            s1 = peg$parselowerIdent();
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseTagList();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c267(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseTagList();
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c268(s1);
            }
            s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c266);
            }
        }
        return s0;
    }
    function peg$parseSlotDirection() {
        let s0;
        if (input.substr(peg$currPos, 8) === peg$c199) {
            s0 = peg$c199;
            peg$currPos += 8;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c200);
            }
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 8) === peg$c196) {
                s0 = peg$c196;
                peg$currPos += 8;
            }
            else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c197);
                }
            }
        }
        return s0;
    }
    function peg$parseRecipeConnection() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseConnectionTargetWithColon();
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseDirection();
            if (s3 !== peg$FAILED) {
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                if (input.substr(peg$currPos, 6) === peg$c262) {
                    s4 = peg$c262;
                    peg$currPos += 6;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c263);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsewhiteSpace();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseConnectionTarget();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseeolWhiteSpace();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c269(s1, s2, s3, s4);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseConnectionTargetWithColon() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseConnectionTarget();
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
                s2 = peg$c36;
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c37);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c270(s1);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeSearch() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c271) {
            s1 = peg$c271;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c272);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsebackquotedString();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$currPos;
                        s6 = peg$parseIndent();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$currPos;
                            s8 = peg$parseSameIndent();
                            if (s8 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 6) === peg$c273) {
                                    s9 = peg$c273;
                                    peg$currPos += 6;
                                }
                                else {
                                    s9 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c274);
                                    }
                                }
                                if (s9 !== peg$FAILED) {
                                    s10 = [];
                                    s11 = peg$currPos;
                                    s12 = peg$parsewhiteSpace();
                                    if (s12 !== peg$FAILED) {
                                        s13 = peg$parsebackquotedString();
                                        if (s13 !== peg$FAILED) {
                                            s12 = [s12, s13];
                                            s11 = s12;
                                        }
                                        else {
                                            peg$currPos = s11;
                                            s11 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s11;
                                        s11 = peg$FAILED;
                                    }
                                    if (s11 !== peg$FAILED) {
                                        while (s11 !== peg$FAILED) {
                                            s10.push(s11);
                                            s11 = peg$currPos;
                                            s12 = peg$parsewhiteSpace();
                                            if (s12 !== peg$FAILED) {
                                                s13 = peg$parsebackquotedString();
                                                if (s13 !== peg$FAILED) {
                                                    s12 = [s12, s13];
                                                    s11 = s12;
                                                }
                                                else {
                                                    peg$currPos = s11;
                                                    s11 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s11;
                                                s11 = peg$FAILED;
                                            }
                                        }
                                    }
                                    else {
                                        s10 = peg$FAILED;
                                    }
                                    if (s10 !== peg$FAILED) {
                                        s11 = peg$parseeolWhiteSpace();
                                        if (s11 !== peg$FAILED) {
                                            s8 = [s8, s9, s10, s11];
                                            s7 = s8;
                                        }
                                        else {
                                            peg$currPos = s7;
                                            s7 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s7;
                                        s7 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s7;
                                    s7 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s7;
                                s7 = peg$FAILED;
                            }
                            if (s7 !== peg$FAILED) {
                                s6 = [s6, s7];
                                s5 = s6;
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c275(s3, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseConnectionTarget() {
        let s0;
        s0 = peg$parseVerbConnectionTarget();
        if (s0 === peg$FAILED) {
            s0 = peg$parseTagConnectionTarget();
            if (s0 === peg$FAILED) {
                s0 = peg$parseParticleConnectionTarget();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseNameConnectionTarget();
                }
            }
        }
        return s0;
    }
    function peg$parseVerbConnectionTarget() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseVerbList();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseConnectionTargetHandleComponents();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c276(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTagConnectionTarget() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseTagList();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c277(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseNameConnectionTarget() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parselowerIdent();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseConnectionTargetHandleComponents();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c278(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseParticleConnectionTarget() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseupperIdent();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseConnectionTargetHandleComponents();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c279(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseConnectionTargetHandleComponents() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c280;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c281);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parselowerIdent();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseTagList();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c282(s2, s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeHandleFate() {
        let s0;
        if (input.charCodeAt(peg$currPos) === 63) {
            s0 = peg$c85;
            peg$currPos++;
        }
        else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c86);
            }
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c283) {
                s0 = peg$c283;
                peg$currPos += 3;
            }
            else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c284);
                }
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c285) {
                    s0 = peg$c285;
                    peg$currPos += 3;
                }
                else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c286);
                    }
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 6) === peg$c287) {
                        s0 = peg$c287;
                        peg$currPos += 6;
                    }
                    else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c288);
                        }
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 4) === peg$c289) {
                            s0 = peg$c289;
                            peg$currPos += 4;
                        }
                        else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c290);
                            }
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 5) === peg$c291) {
                                s0 = peg$c291;
                                peg$currPos += 5;
                            }
                            else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c292);
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseRecipeHandle() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseNameWithColon();
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseRecipeHandleFate();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseHandleRef();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseSpaceAnnotationRefList();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseeolWhiteSpace();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c293(s1, s2, s3, s4);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeSyntheticHandle() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
        s0 = peg$currPos;
        s1 = peg$parseNameWithColon();
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c294) {
                s2 = peg$c294;
                peg$currPos += 4;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c295);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 40) {
                        s4 = peg$c45;
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c46);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parselowerIdent();
                            if (s6 !== peg$FAILED) {
                                s7 = [];
                                s8 = peg$currPos;
                                s9 = peg$parsewhiteSpace();
                                if (s9 === peg$FAILED) {
                                    s9 = null;
                                }
                                if (s9 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 44) {
                                        s10 = peg$c30;
                                        peg$currPos++;
                                    }
                                    else {
                                        s10 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c31);
                                        }
                                    }
                                    if (s10 !== peg$FAILED) {
                                        s11 = peg$parsewhiteSpace();
                                        if (s11 === peg$FAILED) {
                                            s11 = null;
                                        }
                                        if (s11 !== peg$FAILED) {
                                            s12 = peg$parselowerIdent();
                                            if (s12 !== peg$FAILED) {
                                                s9 = [s9, s10, s11, s12];
                                                s8 = s9;
                                            }
                                            else {
                                                peg$currPos = s8;
                                                s8 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                                while (s8 !== peg$FAILED) {
                                    s7.push(s8);
                                    s8 = peg$currPos;
                                    s9 = peg$parsewhiteSpace();
                                    if (s9 === peg$FAILED) {
                                        s9 = null;
                                    }
                                    if (s9 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 44) {
                                            s10 = peg$c30;
                                            peg$currPos++;
                                        }
                                        else {
                                            s10 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c31);
                                            }
                                        }
                                        if (s10 !== peg$FAILED) {
                                            s11 = peg$parsewhiteSpace();
                                            if (s11 === peg$FAILED) {
                                                s11 = null;
                                            }
                                            if (s11 !== peg$FAILED) {
                                                s12 = peg$parselowerIdent();
                                                if (s12 !== peg$FAILED) {
                                                    s9 = [s9, s10, s11, s12];
                                                    s8 = s9;
                                                }
                                                else {
                                                    peg$currPos = s8;
                                                    s8 = peg$FAILED;
                                                }
                                            }
                                            else {
                                                peg$currPos = s8;
                                                s8 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                                if (s7 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 41) {
                                        s8 = peg$c47;
                                        peg$currPos++;
                                    }
                                    else {
                                        s8 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c48);
                                        }
                                    }
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$parsewhiteSpace();
                                        if (s9 === peg$FAILED) {
                                            s9 = null;
                                        }
                                        if (s9 !== peg$FAILED) {
                                            s10 = peg$parseeolWhiteSpace();
                                            if (s10 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s1 = peg$c296(s1, s6, s7);
                                                s0 = s1;
                                            }
                                            else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRecipeRequire() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 7) === peg$c297) {
            s1 = peg$c297;
            peg$currPos += 7;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c298);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseeolWhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseIndent();
                if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$currPos;
                    s7 = peg$parseSameIndent();
                    if (s7 !== peg$FAILED) {
                        s8 = peg$parseRecipeParticle();
                        if (s8 === peg$FAILED) {
                            s8 = peg$parseRequireHandleSection();
                            if (s8 === peg$FAILED) {
                                s8 = peg$parseRecipeSlot();
                            }
                        }
                        if (s8 !== peg$FAILED) {
                            s7 = [s7, s8];
                            s6 = s7;
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                    }
                    while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$currPos;
                        s7 = peg$parseSameIndent();
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parseRecipeParticle();
                            if (s8 === peg$FAILED) {
                                s8 = peg$parseRequireHandleSection();
                                if (s8 === peg$FAILED) {
                                    s8 = peg$parseRecipeSlot();
                                }
                            }
                            if (s8 !== peg$FAILED) {
                                s7 = [s7, s8];
                                s6 = s7;
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c299(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRequireHandleSection() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c132) {
            s1 = peg$c132;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c133);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseLocalName();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseHandleRef();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c300(s2, s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTag() {
        let s0, s1, s2;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c175;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c176);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsesimpleName();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c301(s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTagList() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseTag();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseTagList();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c302(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseVerb() {
        let s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
            s1 = peg$c172;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c173);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsesimpleName();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c304(s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c303);
            }
        }
        return s0;
    }
    function peg$parseVerbList() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseVerb();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseVerbList();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c302(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSpaceTagList() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parsewhiteSpace();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseTagList();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c250(s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseNameAndTagList() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parselowerIdent();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsewhiteSpace();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseTagList();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c305(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsewhiteSpace();
            if (s1 !== peg$FAILED) {
                s2 = peg$parselowerIdent();
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c306(s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsewhiteSpace();
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseTagList();
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c307(s2);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
        }
        return s0;
    }
    function peg$parseParticleRef() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseupperIdent();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c308(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseVerb();
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c309(s1);
            }
            s0 = s1;
        }
        return s0;
    }
    function peg$parseHandleRef() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseid();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseSpaceTagList();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c310(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseupperIdent();
            if (s1 !== peg$FAILED) {
                s2 = peg$parseSpaceTagList();
                if (s2 === peg$FAILED) {
                    s2 = null;
                }
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c311(s1, s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 42) {
                    s1 = peg$c259;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c260);
                    }
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseSpaceTagList();
                    if (s2 === peg$FAILED) {
                        s2 = null;
                    }
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c312(s2);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parseTagList();
                    if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c313(s1);
                    }
                    s0 = s1;
                }
            }
        }
        return s0;
    }
    function peg$parseRecipeSlot() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseNameWithColon();
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c314) {
                s2 = peg$c314;
                peg$currPos += 4;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c315);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parsewhiteSpace();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseHandleRef();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseeolWhiteSpace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c316(s1, s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaInline() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parseupperIdent();
        if (s3 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 42) {
                s3 = peg$c259;
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c260);
                }
            }
        }
        if (s3 !== peg$FAILED) {
            s4 = peg$parsewhiteSpace();
            if (s4 === peg$FAILED) {
                s4 = null;
            }
            if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parseupperIdent();
            if (s3 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 42) {
                    s3 = peg$c259;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c260);
                    }
                }
            }
            if (s3 !== peg$FAILED) {
                s4 = peg$parsewhiteSpace();
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseopenBrace();
            if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$currPos;
                s5 = peg$parseSchemaInlineField();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsecommaOrNewline();
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                        s5 = [s5, s6];
                        s4 = s5;
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
                while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    s5 = peg$parseSchemaInlineField();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsecommaOrNewline();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsecloseBrace();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c317(s1, s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaInlineField() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsefieldName();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 58) {
                s3 = peg$c36;
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c37);
                }
            }
            if (s3 !== peg$FAILED) {
                s4 = peg$parsewhiteSpace();
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseSchemaType();
                    if (s5 !== peg$FAILED) {
                        s3 = [s3, s4, s5];
                        s2 = s3;
                    }
                    else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c318(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 42) {
                s1 = peg$c259;
                peg$currPos++;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c260);
                }
            }
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c319();
            }
            s0 = s1;
        }
        return s0;
    }
    function peg$parseSchemaSpec() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c320) {
            s1 = peg$c320;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c321);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsewhiteSpace();
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 42) {
                    s5 = peg$c259;
                    peg$currPos++;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c260);
                    }
                }
                if (s5 === peg$FAILED) {
                    s5 = peg$parseupperIdent();
                }
                if (s5 !== peg$FAILED) {
                    s4 = [s4, s5];
                    s3 = s4;
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$currPos;
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 42) {
                            s5 = peg$c259;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c260);
                            }
                        }
                        if (s5 === peg$FAILED) {
                            s5 = peg$parseupperIdent();
                        }
                        if (s5 !== peg$FAILED) {
                            s4 = [s4, s5];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaExtends();
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c322(s2, s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaBody() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parseopenBrace();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseSchemaItem();
            if (s4 !== peg$FAILED) {
                s5 = peg$parsecommaOrNewline();
                if (s5 === peg$FAILED) {
                    s5 = null;
                }
                if (s5 !== peg$FAILED) {
                    s4 = [s4, s5];
                    s3 = s4;
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parseSchemaItem();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsecommaOrNewline();
                    if (s5 === peg$FAILED) {
                        s5 = null;
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsecloseBrace();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsemultiLineSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c323(s2);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseeolWhiteSpace();
            if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parseIndent();
                if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$currPos;
                    s6 = peg$parseSameIndent();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseSchemaItem();
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parseeolWhiteSpace();
                            if (s8 === peg$FAILED) {
                                s8 = null;
                            }
                            if (s8 !== peg$FAILED) {
                                s6 = [s6, s7, s8];
                                s5 = s6;
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                    }
                    while (s5 !== peg$FAILED) {
                        s4.push(s5);
                        s5 = peg$currPos;
                        s6 = peg$parseSameIndent();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseSchemaItem();
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parseeolWhiteSpace();
                                if (s8 === peg$FAILED) {
                                    s8 = null;
                                }
                                if (s8 !== peg$FAILED) {
                                    s6 = [s6, s7, s8];
                                    s5 = s6;
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s3 = [s3, s4];
                        s2 = s3;
                    }
                    else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
                if (s2 === peg$FAILED) {
                    s2 = null;
                }
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c324(s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parseSchemaAlias() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c325) {
            s1 = peg$c325;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c326);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaSpec();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseTopLevelAlias();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseSchemaBody();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c327(s3, s5, s6);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchema() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseSchemaSpec();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseSchemaBody();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c328(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaExtends() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$parsewhiteSpace();
        if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 7) === peg$c329) {
                s2 = peg$c329;
                peg$currPos += 7;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c330);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseupperIdent();
                    if (s4 !== peg$FAILED) {
                        s5 = [];
                        s6 = peg$currPos;
                        s7 = peg$parsewhiteSpace();
                        if (s7 === peg$FAILED) {
                            s7 = null;
                        }
                        if (s7 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s8 = peg$c30;
                                peg$currPos++;
                            }
                            else {
                                s8 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c31);
                                }
                            }
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parsewhiteSpace();
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parseupperIdent();
                                    if (s10 !== peg$FAILED) {
                                        s7 = [s7, s8, s9, s10];
                                        s6 = s7;
                                    }
                                    else {
                                        peg$currPos = s6;
                                        s6 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                        while (s6 !== peg$FAILED) {
                            s5.push(s6);
                            s6 = peg$currPos;
                            s7 = peg$parsewhiteSpace();
                            if (s7 === peg$FAILED) {
                                s7 = null;
                            }
                            if (s7 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 44) {
                                    s8 = peg$c30;
                                    peg$currPos++;
                                }
                                else {
                                    s8 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c31);
                                    }
                                }
                                if (s8 !== peg$FAILED) {
                                    s9 = peg$parsewhiteSpace();
                                    if (s9 !== peg$FAILED) {
                                        s10 = peg$parseupperIdent();
                                        if (s10 !== peg$FAILED) {
                                            s7 = [s7, s8, s9, s10];
                                            s6 = s7;
                                        }
                                        else {
                                            peg$currPos = s6;
                                            s6 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s6;
                                        s6 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c331(s4, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaItem() {
        let s0;
        s0 = peg$parseDescription();
        if (s0 === peg$FAILED) {
            s0 = peg$parseSchemaField();
        }
        return s0;
    }
    function peg$parseSchemaField() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseSchemaInlineField();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c332(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseSchemaType() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseSchemaReferenceType();
        if (s1 === peg$FAILED) {
            s1 = peg$parseSchemaCollectionType();
            if (s1 === peg$FAILED) {
                s1 = peg$parseSchemaOrderedListType();
                if (s1 === peg$FAILED) {
                    s1 = peg$parseSchemaPrimitiveType();
                    if (s1 === peg$FAILED) {
                        s1 = peg$parseKotlinPrimitiveType();
                        if (s1 === peg$FAILED) {
                            s1 = peg$parseSchemaUnionType();
                            if (s1 === peg$FAILED) {
                                s1 = peg$parseSchemaTupleType();
                                if (s1 === peg$FAILED) {
                                    s1 = peg$parseNestedSchemaType();
                                    if (s1 === peg$FAILED) {
                                        s1 = peg$currPos;
                                        s2 = [];
                                        if (peg$c333.test(input.charAt(peg$currPos))) {
                                            s3 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        }
                                        else {
                                            s3 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c334);
                                            }
                                        }
                                        while (s3 !== peg$FAILED) {
                                            s2.push(s3);
                                            if (peg$c333.test(input.charAt(peg$currPos))) {
                                                s3 = input.charAt(peg$currPos);
                                                peg$currPos++;
                                            }
                                            else {
                                                s3 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c334);
                                                }
                                            }
                                        }
                                        if (s2 !== peg$FAILED) {
                                            peg$savedPos = s1;
                                            s2 = peg$c335();
                                        }
                                        s1 = s2;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseRefinement();
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseAnnotationRefList();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c336(s1, s3, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaCollectionType() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c40;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c41);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaType();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                            s5 = peg$c42;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c43);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c337(s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaOrderedListType() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c338) {
            s1 = peg$c338;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c339);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaType();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 62) {
                            s5 = peg$c61;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c62);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c340(s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaReferenceType() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
            s1 = peg$c172;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c173);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaInline();
                if (s3 === peg$FAILED) {
                    s3 = peg$parseTypeName();
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c341(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaPrimitiveType() {
        let s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c342) {
            s1 = peg$c342;
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c343);
            }
        }
        if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c344) {
                s1 = peg$c344;
                peg$currPos += 3;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c345);
                }
            }
            if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c346) {
                    s1 = peg$c346;
                    peg$currPos += 6;
                }
                else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c347);
                    }
                }
                if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 6) === peg$c348) {
                        s1 = peg$c348;
                        peg$currPos += 6;
                    }
                    else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c349);
                        }
                    }
                    if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 7) === peg$c350) {
                            s1 = peg$c350;
                            peg$currPos += 7;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c351);
                            }
                        }
                        if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 5) === peg$c352) {
                                s1 = peg$c352;
                                peg$currPos += 5;
                            }
                            else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c353);
                                }
                            }
                            if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 7) === peg$c354) {
                                    s1 = peg$c354;
                                    peg$currPos += 7;
                                }
                                else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c355);
                                    }
                                }
                                if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 8) === peg$c356) {
                                        s1 = peg$c356;
                                        peg$currPos += 8;
                                    }
                                    else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c357);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c358(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseNestedSchemaType() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c359) {
            s1 = peg$c359;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c360);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaInline();
                if (s3 === peg$FAILED) {
                    s3 = peg$parseTypeName();
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c361(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseQualifiedExpression() {
        let s0;
        s0 = peg$parseFromExpression();
        if (s0 === peg$FAILED) {
            s0 = peg$parseWhereExpression();
            if (s0 === peg$FAILED) {
                s0 = peg$parseLetExpression();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseSelectExpression();
                }
            }
        }
        return s0;
    }
    function peg$parseExpressionWithQualifier() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseQualifiedExpression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsemultiLineSpace();
            if (s4 !== peg$FAILED) {
                s5 = peg$parseQualifiedExpression();
                if (s5 !== peg$FAILED) {
                    s4 = [s4, s5];
                    s3 = s4;
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parsemultiLineSpace();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parseQualifiedExpression();
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c362(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsePaxelExpression() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseNewExpression();
        if (s1 === peg$FAILED) {
            s1 = peg$parseExpressionWithQualifier();
            if (s1 === peg$FAILED) {
                s1 = peg$parseOrExpression();
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c363(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseSourceExpression() {
        let s0, s1, s2, s3, s4, s5;
        peg$silentFails++;
        s0 = peg$parseExpressionScopeLookup();
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
                s1 = peg$c45;
                peg$currPos++;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c46);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parsewhiteSpace();
                if (s2 === peg$FAILED) {
                    s2 = null;
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$parsePaxelExpression();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parsewhiteSpace();
                        if (s4 === peg$FAILED) {
                            s4 = null;
                        }
                        if (s4 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s5 = peg$c47;
                                peg$currPos++;
                            }
                            else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c48);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c365(s3);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c364);
            }
        }
        return s0;
    }
    function peg$parseFromExpression() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c115) {
            s1 = peg$c115;
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c116);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsefieldName();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c19) {
                            s5 = peg$c19;
                            peg$currPos += 2;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c20);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parsewhiteSpace();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseSourceExpression();
                                if (s7 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c367(s3, s7);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c366);
            }
        }
        return s0;
    }
    function peg$parseWhereExpression() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c369) {
            s1 = peg$c369;
            peg$currPos += 5;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c370);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseOrExpression();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c371(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c368);
            }
        }
        return s0;
    }
    function peg$parseLetExpression() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c373) {
            s1 = peg$c373;
            peg$currPos += 3;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c374);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsefieldName();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 61) {
                            s5 = peg$c143;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c144);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parsewhiteSpace();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parsePaxelExpression();
                                if (s7 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c375(s3, s7);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c372);
            }
        }
        return s0;
    }
    function peg$parseSelectExpression() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c377) {
            s1 = peg$c377;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c378);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsePaxelExpression();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c379(s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c376);
            }
        }
        return s0;
    }
    function peg$parseNewExpression() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c381) {
            s1 = peg$c381;
            peg$currPos += 3;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c382);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$currPos;
                s5 = peg$parseupperIdent();
                if (s5 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 42) {
                        s5 = peg$c259;
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c260);
                        }
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsewhiteSpace();
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                        s5 = [s5, s6];
                        s4 = s5;
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
                while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    s5 = peg$parseupperIdent();
                    if (s5 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 42) {
                            s5 = peg$c259;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c260);
                            }
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsewhiteSpace();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            s5 = [s5, s6];
                            s4 = s5;
                        }
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s4 = peg$c28;
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c29);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsemultiLineSpace();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseExpressionEntityFields();
                            if (s6 === peg$FAILED) {
                                s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 44) {
                                    s7 = peg$c30;
                                    peg$currPos++;
                                }
                                else {
                                    s7 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c31);
                                    }
                                }
                                if (s7 === peg$FAILED) {
                                    s7 = null;
                                }
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parsemultiLineSpace();
                                    if (s8 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 125) {
                                            s9 = peg$c32;
                                            peg$currPos++;
                                        }
                                        else {
                                            s9 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c33);
                                            }
                                        }
                                        if (s9 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c383(s3, s6);
                                            s0 = s1;
                                        }
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c380);
            }
        }
        return s0;
    }
    function peg$parseExpressionEntityFields() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseExpressionEntityField();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c30;
                peg$currPos++;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c31);
                }
            }
            if (s4 !== peg$FAILED) {
                s5 = peg$parsemultiLineSpace();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parseExpressionEntityField();
                    if (s6 !== peg$FAILED) {
                        s4 = [s4, s5, s6];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                    s4 = peg$c30;
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c31);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsemultiLineSpace();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parseExpressionEntityField();
                        if (s6 !== peg$FAILED) {
                            s4 = [s4, s5, s6];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c384(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseExpressionEntityField() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsefieldName();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c36;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c37);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsePaxelExpression();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c385(s1, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseExpressionScopeLookup() {
        let s0, s1;
        peg$silentFails++;
        s0 = peg$parseOrExpression();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c386);
            }
        }
        return s0;
    }
    function peg$parseKotlinPrimitiveType() {
        let s0, s1;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c387) {
            s1 = peg$c387;
            peg$currPos += 4;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c388);
            }
        }
        if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c389) {
                s1 = peg$c389;
                peg$currPos += 5;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c390);
                }
            }
            if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c391) {
                    s1 = peg$c391;
                    peg$currPos += 3;
                }
                else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c392);
                    }
                }
                if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c393) {
                        s1 = peg$c393;
                        peg$currPos += 4;
                    }
                    else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c394);
                        }
                    }
                    if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 4) === peg$c395) {
                            s1 = peg$c395;
                            peg$currPos += 4;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c396);
                            }
                        }
                        if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 5) === peg$c397) {
                                s1 = peg$c397;
                                peg$currPos += 5;
                            }
                            else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c398);
                                }
                            }
                            if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 6) === peg$c399) {
                                    s1 = peg$c399;
                                    peg$currPos += 6;
                                }
                                else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c400);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c401(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseSchemaUnionType() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c45;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c46);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaPrimitiveType();
                if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$currPos;
                    s6 = peg$parsewhiteSpace();
                    if (s6 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c124) {
                            s7 = peg$c124;
                            peg$currPos += 2;
                        }
                        else {
                            s7 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c125);
                            }
                        }
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsewhiteSpace();
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parseSchemaPrimitiveType();
                                if (s9 !== peg$FAILED) {
                                    s6 = [s6, s7, s8, s9];
                                    s5 = s6;
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                        while (s5 !== peg$FAILED) {
                            s4.push(s5);
                            s5 = peg$currPos;
                            s6 = peg$parsewhiteSpace();
                            if (s6 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c124) {
                                    s7 = peg$c124;
                                    peg$currPos += 2;
                                }
                                else {
                                    s7 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c125);
                                    }
                                }
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parsewhiteSpace();
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$parseSchemaPrimitiveType();
                                        if (s9 !== peg$FAILED) {
                                            s6 = [s6, s7, s8, s9];
                                            s5 = s6;
                                        }
                                        else {
                                            peg$currPos = s5;
                                            s5 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                    }
                    else {
                        s4 = peg$FAILED;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s6 = peg$c47;
                                peg$currPos++;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c48);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c402(s3, s4);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseSchemaTupleType() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c45;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c46);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseSchemaPrimitiveType();
                if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$currPos;
                    s6 = peg$parsewhiteSpace();
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s7 = peg$c30;
                            peg$currPos++;
                        }
                        else {
                            s7 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c31);
                            }
                        }
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsewhiteSpace();
                            if (s8 === peg$FAILED) {
                                s8 = null;
                            }
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parseSchemaPrimitiveType();
                                if (s9 !== peg$FAILED) {
                                    s6 = [s6, s7, s8, s9];
                                    s5 = s6;
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                    }
                    while (s5 !== peg$FAILED) {
                        s4.push(s5);
                        s5 = peg$currPos;
                        s6 = peg$parsewhiteSpace();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s7 = peg$c30;
                                peg$currPos++;
                            }
                            else {
                                s7 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c31);
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parsewhiteSpace();
                                if (s8 === peg$FAILED) {
                                    s8 = null;
                                }
                                if (s8 !== peg$FAILED) {
                                    s9 = peg$parseSchemaPrimitiveType();
                                    if (s9 !== peg$FAILED) {
                                        s6 = [s6, s7, s8, s9];
                                        s5 = s6;
                                    }
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s6 = peg$c47;
                                peg$currPos++;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c48);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c403(s3, s4);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRefinement() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c40;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c41);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsemultiLineSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseOrExpression();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsemultiLineSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                            s5 = peg$c42;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c43);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c404(s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c40;
                peg$currPos++;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c41);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = [];
                if (peg$c405.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c406);
                    }
                }
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    if (peg$c405.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c406);
                        }
                    }
                }
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c407();
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parseOrExpression() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseAndExpression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsemultiLineSpace();
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c124) {
                    s5 = peg$c124;
                    peg$currPos += 2;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c125);
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsemultiLineSpace();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseAndExpression();
                        if (s7 !== peg$FAILED) {
                            s4 = [s4, s5, s6, s7];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parsemultiLineSpace();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c124) {
                        s5 = peg$c124;
                        peg$currPos += 2;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c125);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsemultiLineSpace();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseAndExpression();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c408(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseAndExpression() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseEqualityExpression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsemultiLineSpace();
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c75) {
                    s5 = peg$c75;
                    peg$currPos += 3;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c76);
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsemultiLineSpace();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseEqualityExpression();
                        if (s7 !== peg$FAILED) {
                            s4 = [s4, s5, s6, s7];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parsemultiLineSpace();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c75) {
                        s5 = peg$c75;
                        peg$currPos += 3;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c76);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsemultiLineSpace();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseEqualityExpression();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c408(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseEqualityExpression() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseComparisonExpression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsemultiLineSpace();
            if (s4 === peg$FAILED) {
                s4 = null;
            }
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c409) {
                    s5 = peg$c409;
                    peg$currPos += 2;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c410);
                    }
                }
                if (s5 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c411) {
                        s5 = peg$c411;
                        peg$currPos += 2;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c412);
                        }
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsemultiLineSpace();
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseComparisonExpression();
                        if (s7 !== peg$FAILED) {
                            s4 = [s4, s5, s6, s7];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parsemultiLineSpace();
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c409) {
                        s5 = peg$c409;
                        peg$currPos += 2;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c410);
                        }
                    }
                    if (s5 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c411) {
                            s5 = peg$c411;
                            peg$currPos += 2;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c412);
                            }
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsemultiLineSpace();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseComparisonExpression();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c408(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseComparisonExpression() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseIfNullExpression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsemultiLineSpace();
            if (s4 === peg$FAILED) {
                s4 = null;
            }
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c413) {
                    s5 = peg$c413;
                    peg$currPos += 2;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c414);
                    }
                }
                if (s5 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 60) {
                        s5 = peg$c59;
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c60);
                        }
                    }
                    if (s5 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c415) {
                            s5 = peg$c415;
                            peg$currPos += 2;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c416);
                            }
                        }
                        if (s5 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 62) {
                                s5 = peg$c61;
                                peg$currPos++;
                            }
                            else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c62);
                                }
                            }
                        }
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsemultiLineSpace();
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseIfNullExpression();
                        if (s7 !== peg$FAILED) {
                            s4 = [s4, s5, s6, s7];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parsemultiLineSpace();
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c413) {
                        s5 = peg$c413;
                        peg$currPos += 2;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c414);
                        }
                    }
                    if (s5 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 60) {
                            s5 = peg$c59;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c60);
                            }
                        }
                        if (s5 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c415) {
                                s5 = peg$c415;
                                peg$currPos += 2;
                            }
                            else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c416);
                                }
                            }
                            if (s5 === peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 62) {
                                    s5 = peg$c61;
                                    peg$currPos++;
                                }
                                else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c62);
                                    }
                                }
                            }
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsemultiLineSpace();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseIfNullExpression();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c408(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseIfNullExpression() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseAdditiveExpression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsemultiLineSpace();
            if (s4 === peg$FAILED) {
                s4 = null;
            }
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c417) {
                    s5 = peg$c417;
                    peg$currPos += 2;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c418);
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsemultiLineSpace();
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseAdditiveExpression();
                        if (s7 !== peg$FAILED) {
                            s4 = [s4, s5, s6, s7];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parsemultiLineSpace();
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c417) {
                        s5 = peg$c417;
                        peg$currPos += 2;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c418);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsemultiLineSpace();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseAdditiveExpression();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c419(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseAdditiveExpression() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseMultiplicativeExpression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsemultiLineSpace();
            if (s4 === peg$FAILED) {
                s4 = null;
            }
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 43) {
                    s5 = peg$c420;
                    peg$currPos++;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c421);
                    }
                }
                if (s5 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 45) {
                        s5 = peg$c422;
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c423);
                        }
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsemultiLineSpace();
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseMultiplicativeExpression();
                        if (s7 !== peg$FAILED) {
                            s4 = [s4, s5, s6, s7];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parsemultiLineSpace();
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 43) {
                        s5 = peg$c420;
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c421);
                        }
                    }
                    if (s5 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 45) {
                            s5 = peg$c422;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c423);
                            }
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsemultiLineSpace();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseMultiplicativeExpression();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c408(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMultiplicativeExpression() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parsePrimaryExpression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsemultiLineSpace();
            if (s4 === peg$FAILED) {
                s4 = null;
            }
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 42) {
                    s5 = peg$c259;
                    peg$currPos++;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c260);
                    }
                }
                if (s5 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 47) {
                        s5 = peg$c424;
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c425);
                        }
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsemultiLineSpace();
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parsePrimaryExpression();
                        if (s7 !== peg$FAILED) {
                            s4 = [s4, s5, s6, s7];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parsemultiLineSpace();
                if (s4 === peg$FAILED) {
                    s4 = null;
                }
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 42) {
                        s5 = peg$c259;
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c260);
                        }
                    }
                    if (s5 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 47) {
                            s5 = peg$c424;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c425);
                            }
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsemultiLineSpace();
                        if (s6 === peg$FAILED) {
                            s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parsePrimaryExpression();
                            if (s7 !== peg$FAILED) {
                                s4 = [s4, s5, s6, s7];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c408(s1, s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseFunctionArguments() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$parsemultiLineSpace();
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsePaxelExpression();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsemultiLineSpace();
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                        s6 = peg$c30;
                        peg$currPos++;
                    }
                    else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c31);
                        }
                    }
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parsemultiLineSpace();
                        if (s7 === peg$FAILED) {
                            s7 = null;
                        }
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsePaxelExpression();
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parsemultiLineSpace();
                                if (s9 === peg$FAILED) {
                                    s9 = null;
                                }
                                if (s9 !== peg$FAILED) {
                                    s6 = [s6, s7, s8, s9];
                                    s5 = s6;
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                    }
                    while (s5 !== peg$FAILED) {
                        s4.push(s5);
                        s5 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s6 = peg$c30;
                            peg$currPos++;
                        }
                        else {
                            s6 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c31);
                            }
                        }
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parsemultiLineSpace();
                            if (s7 === peg$FAILED) {
                                s7 = null;
                            }
                            if (s7 !== peg$FAILED) {
                                s8 = peg$parsePaxelExpression();
                                if (s8 !== peg$FAILED) {
                                    s9 = peg$parsemultiLineSpace();
                                    if (s9 === peg$FAILED) {
                                        s9 = null;
                                    }
                                    if (s9 !== peg$FAILED) {
                                        s6 = [s6, s7, s8, s9];
                                        s5 = s6;
                                    }
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c426(s2, s4);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseFunctionCall() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parsefieldName();
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
                s2 = peg$c45;
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c46);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseFunctionArguments();
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s4 = peg$c47;
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c48);
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c427(s1, s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsePrimaryExpression() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c45;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c46);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsemultiLineSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsePaxelExpression();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsemultiLineSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 41) {
                            s5 = peg$c47;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c48);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c428(s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            if (input.substr(peg$currPos, 3) === peg$c110) {
                s2 = peg$c110;
                peg$currPos += 3;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c111);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    s2 = [s2, s3];
                    s1 = s2;
                }
                else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 45) {
                    s2 = peg$c422;
                    peg$currPos++;
                }
                else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c423);
                    }
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$parsewhiteSpace();
                    if (s3 === peg$FAILED) {
                        s3 = null;
                    }
                    if (s3 !== peg$FAILED) {
                        s2 = [s2, s3];
                        s1 = s2;
                    }
                    else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parsePrimaryExpression();
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c429(s1, s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$parseNumericValue();
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c51) {
                        s1 = input.substr(peg$currPos, 4);
                        peg$currPos += 4;
                    }
                    else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c52);
                        }
                    }
                    if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c53) {
                            s1 = input.substr(peg$currPos, 5);
                            peg$currPos += 5;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c54);
                            }
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c430(s1);
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 4) === peg$c431) {
                            s1 = peg$c431;
                            peg$currPos += 4;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c432);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c433();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parseFunctionCall();
                            if (s1 === peg$FAILED) {
                                s1 = peg$parsefieldName();
                            }
                            if (s1 !== peg$FAILED) {
                                s2 = [];
                                s3 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 46) {
                                    s4 = peg$c280;
                                    peg$currPos++;
                                }
                                else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c281);
                                    }
                                }
                                if (s4 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 2) === peg$c434) {
                                        s4 = peg$c434;
                                        peg$currPos += 2;
                                    }
                                    else {
                                        s4 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c435);
                                        }
                                    }
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parsefieldName();
                                    if (s5 !== peg$FAILED) {
                                        s4 = [s4, s5];
                                        s3 = s4;
                                    }
                                    else {
                                        peg$currPos = s3;
                                        s3 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s3;
                                    s3 = peg$FAILED;
                                }
                                while (s3 !== peg$FAILED) {
                                    s2.push(s3);
                                    s3 = peg$currPos;
                                    if (input.charCodeAt(peg$currPos) === 46) {
                                        s4 = peg$c280;
                                        peg$currPos++;
                                    }
                                    else {
                                        s4 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c281);
                                        }
                                    }
                                    if (s4 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c434) {
                                            s4 = peg$c434;
                                            peg$currPos += 2;
                                        }
                                        else {
                                            s4 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c435);
                                            }
                                        }
                                    }
                                    if (s4 !== peg$FAILED) {
                                        s5 = peg$parsefieldName();
                                        if (s5 !== peg$FAILED) {
                                            s4 = [s4, s5];
                                            s3 = s4;
                                        }
                                        else {
                                            peg$currPos = s3;
                                            s3 = peg$FAILED;
                                        }
                                    }
                                    else {
                                        peg$currPos = s3;
                                        s3 = peg$FAILED;
                                    }
                                }
                                if (s2 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c436(s1, s2);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 63) {
                                    s1 = peg$c85;
                                    peg$currPos++;
                                }
                                else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c86);
                                    }
                                }
                                if (s1 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c437(s1);
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    s1 = peg$parseQuotedString();
                                    if (s1 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c438(s1);
                                    }
                                    s0 = s1;
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseUnits() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsewhiteSpace();
        if (s2 === peg$FAILED) {
            s2 = null;
        }
        if (s2 !== peg$FAILED) {
            s3 = peg$parseUnitName();
            if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c439(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseUnitName() {
        let s0, s1, s2;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c440) {
            s1 = peg$c440;
            peg$currPos += 3;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c441);
            }
        }
        if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c442) {
                s1 = peg$c442;
                peg$currPos += 4;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c443);
                }
            }
            if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c444) {
                    s1 = peg$c444;
                    peg$currPos += 6;
                }
                else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c445);
                    }
                }
                if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 6) === peg$c446) {
                        s1 = peg$c446;
                        peg$currPos += 6;
                    }
                    else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c447);
                        }
                    }
                    if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 11) === peg$c448) {
                            s1 = peg$c448;
                            peg$currPos += 11;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c449);
                            }
                        }
                        if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 5) === peg$c450) {
                                s1 = peg$c450;
                                peg$currPos += 5;
                            }
                            else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c451);
                                }
                            }
                        }
                    }
                }
            }
        }
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 115) {
                s2 = peg$c452;
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c453);
                }
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c454(s1);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseLiteralTypeAnnotation() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 110) {
            s1 = peg$c455;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c456);
            }
        }
        if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 105) {
                s1 = peg$c457;
                peg$currPos++;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c458);
                }
            }
            if (s1 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 108) {
                    s1 = peg$c459;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c460);
                    }
                }
                if (s1 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 102) {
                        s1 = peg$c461;
                        peg$currPos++;
                    }
                    else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c462);
                        }
                    }
                    if (s1 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 100) {
                            s1 = peg$c463;
                            peg$currPos++;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c464);
                            }
                        }
                    }
                }
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c465.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c466);
                }
            }
            peg$silentFails--;
            if (s3 !== peg$FAILED) {
                peg$currPos = s2;
                s2 = undefined;
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c467(s1);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseNumericValue() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c422;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c423);
            }
        }
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c468.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c469);
                }
            }
            if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    if (peg$c468.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c469);
                        }
                    }
                }
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 46) {
                    s4 = peg$c280;
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c281);
                    }
                }
                if (s4 !== peg$FAILED) {
                    s5 = [];
                    if (peg$c468.test(input.charAt(peg$currPos))) {
                        s6 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c469);
                        }
                    }
                    while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        if (peg$c468.test(input.charAt(peg$currPos))) {
                            s6 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s6 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c469);
                            }
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [s4, s5];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseLiteralTypeAnnotation();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseUnits();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c470(s1, s2, s3, s4, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseVersion() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 64) {
            s1 = peg$c244;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c245);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c472.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c473);
                }
            }
            if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    if (peg$c472.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c473);
                        }
                    }
                }
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c474(s2);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c471);
            }
        }
        return s0;
    }
    function peg$parsePolicy() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c475) {
            s1 = peg$c475;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c476);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseupperIdent();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseopenBrace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$currPos;
                        s6 = peg$parsePolicyItem();
                        if (s6 !== peg$FAILED) {
                            s7 = [];
                            s8 = peg$currPos;
                            s9 = peg$parsecommaOrNewline();
                            if (s9 !== peg$FAILED) {
                                s10 = peg$parsePolicyItem();
                                if (s10 !== peg$FAILED) {
                                    s9 = [s9, s10];
                                    s8 = s9;
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s8;
                                s8 = peg$FAILED;
                            }
                            while (s8 !== peg$FAILED) {
                                s7.push(s8);
                                s8 = peg$currPos;
                                s9 = peg$parsecommaOrNewline();
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parsePolicyItem();
                                    if (s10 !== peg$FAILED) {
                                        s9 = [s9, s10];
                                        s8 = s9;
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s6 = [s6, s7];
                                s5 = s6;
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parsecloseBrace();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseeolWhiteSpace();
                                if (s7 === peg$FAILED) {
                                    s7 = null;
                                }
                                if (s7 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c477(s3, s5);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsePolicyItem() {
        let s0;
        s0 = peg$parsePolicyTarget();
        if (s0 === peg$FAILED) {
            s0 = peg$parsePolicyConfig();
        }
        return s0;
    }
    function peg$parsePolicyTarget() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parseAnnotationRef();
        if (s3 !== peg$FAILED) {
            s4 = peg$parsemultiLineSpace();
            if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parseAnnotationRef();
            if (s3 !== peg$FAILED) {
                s4 = peg$parsemultiLineSpace();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c115) {
                s2 = peg$c115;
                peg$currPos += 4;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c116);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsewhiteSpace();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseupperIdent();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsewhiteSpace();
                        if (s5 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 6) === peg$c478) {
                                s6 = peg$c478;
                                peg$currPos += 6;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c479);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parsePolicyFieldSet();
                                if (s7 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c480(s1, s4, s7);
                                    s0 = s1;
                                }
                                else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsePolicyFieldSet() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseopenBrace();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsePolicyField();
            if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$currPos;
                s6 = peg$parsecommaOrNewline();
                if (s6 !== peg$FAILED) {
                    s7 = peg$parsePolicyField();
                    if (s7 !== peg$FAILED) {
                        s6 = [s6, s7];
                        s5 = s6;
                    }
                    else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                }
                while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$currPos;
                    s6 = peg$parsecommaOrNewline();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parsePolicyField();
                        if (s7 !== peg$FAILED) {
                            s6 = [s6, s7];
                            s5 = s6;
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                    }
                }
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsecloseBrace();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c482(s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c481);
            }
        }
        return s0;
    }
    function peg$parsePolicyField() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parseAnnotationRef();
        if (s3 !== peg$FAILED) {
            s4 = peg$parsemultiLineSpace();
            if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parseAnnotationRef();
            if (s3 !== peg$FAILED) {
                s4 = peg$parsemultiLineSpace();
                if (s4 !== peg$FAILED) {
                    s3 = [s3, s4];
                    s2 = s3;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsefieldName();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsePolicyFieldSet();
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c483(s1, s2, s3);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsePolicyConfig() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c484) {
            s1 = peg$c484;
            peg$currPos += 6;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c485);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsesimpleName();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseopenBrace();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$currPos;
                        s6 = peg$parsePolicyConfigKeyValuePair();
                        if (s6 !== peg$FAILED) {
                            s7 = [];
                            s8 = peg$currPos;
                            s9 = peg$parsecommaOrNewline();
                            if (s9 !== peg$FAILED) {
                                s10 = peg$parsePolicyConfigKeyValuePair();
                                if (s10 !== peg$FAILED) {
                                    s9 = [s9, s10];
                                    s8 = s9;
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                            }
                            else {
                                peg$currPos = s8;
                                s8 = peg$FAILED;
                            }
                            while (s8 !== peg$FAILED) {
                                s7.push(s8);
                                s8 = peg$currPos;
                                s9 = peg$parsecommaOrNewline();
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parsePolicyConfigKeyValuePair();
                                    if (s10 !== peg$FAILED) {
                                        s9 = [s9, s10];
                                        s8 = s9;
                                    }
                                    else {
                                        peg$currPos = s8;
                                        s8 = peg$FAILED;
                                    }
                                }
                                else {
                                    peg$currPos = s8;
                                    s8 = peg$FAILED;
                                }
                            }
                            if (s7 !== peg$FAILED) {
                                s6 = [s6, s7];
                                s5 = s6;
                            }
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        }
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parsecloseBrace();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c486(s3, s5);
                                s0 = s1;
                            }
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsePolicyConfigKeyValuePair() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parsesimpleName();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c36;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c37);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsewhiteSpace();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseQuotedString();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c487(s1, s5);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseIndent() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        peg$silentFails++;
        s1 = peg$currPos;
        s2 = [];
        if (input.charCodeAt(peg$currPos) === 32) {
            s3 = peg$c489;
            peg$currPos++;
        }
        else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c490);
            }
        }
        if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (input.charCodeAt(peg$currPos) === 32) {
                    s3 = peg$c489;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c490);
                    }
                }
            }
        }
        else {
            s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s3 = peg$c491(s2);
            if (s3) {
                s3 = undefined;
            }
            else {
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        peg$silentFails--;
        if (s1 !== peg$FAILED) {
            peg$currPos = s0;
            s0 = undefined;
        }
        else {
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c488);
            }
        }
        return s0;
    }
    function peg$parseSameIndent() {
        let s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$currPos;
        s3 = [];
        if (input.charCodeAt(peg$currPos) === 32) {
            s4 = peg$c489;
            peg$currPos++;
        }
        else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c490);
            }
        }
        while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (input.charCodeAt(peg$currPos) === 32) {
                s4 = peg$c489;
                peg$currPos++;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c490);
                }
            }
        }
        if (s3 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s4 = peg$c493(s3);
            if (s4) {
                s4 = undefined;
            }
            else {
                s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
            peg$currPos = s1;
            s1 = undefined;
        }
        else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (input.charCodeAt(peg$currPos) === 32) {
                s3 = peg$c489;
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c490);
                }
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (input.charCodeAt(peg$currPos) === 32) {
                    s3 = peg$c489;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c490);
                    }
                }
            }
            if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c492);
            }
        }
        return s0;
    }
    function peg$parseSameOrMoreIndent() {
        let s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$currPos;
        s3 = [];
        if (input.charCodeAt(peg$currPos) === 32) {
            s4 = peg$c489;
            peg$currPos++;
        }
        else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c490);
            }
        }
        while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (input.charCodeAt(peg$currPos) === 32) {
                s4 = peg$c489;
                peg$currPos++;
            }
            else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c490);
                }
            }
        }
        if (s3 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s4 = peg$c495(s3);
            if (s4) {
                s4 = undefined;
            }
            else {
                s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
            peg$currPos = s1;
            s1 = undefined;
        }
        else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (input.charCodeAt(peg$currPos) === 32) {
                s3 = peg$c489;
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c490);
                }
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (input.charCodeAt(peg$currPos) === 32) {
                    s3 = peg$c489;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c490);
                    }
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c494);
            }
        }
        return s0;
    }
    function peg$parseUpperReservedWord() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseSchemaPrimitiveType();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c465.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c466);
                }
            }
            if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                peg$silentFails++;
                if (input.length > peg$currPos) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c162);
                    }
                }
                peg$silentFails--;
                if (s4 === peg$FAILED) {
                    s3 = undefined;
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            peg$silentFails--;
            if (s3 !== peg$FAILED) {
                peg$currPos = s2;
                s2 = undefined;
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c496(s1);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseReservedWord() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseDirection();
        if (s1 === peg$FAILED) {
            s1 = peg$parseSlotDirection();
            if (s1 === peg$FAILED) {
                s1 = peg$parseSchemaPrimitiveType();
                if (s1 === peg$FAILED) {
                    s1 = peg$parseKotlinPrimitiveType();
                    if (s1 === peg$FAILED) {
                        s1 = peg$parseRecipeHandleFate();
                        if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c104) {
                                s1 = peg$c104;
                                peg$currPos += 8;
                            }
                            else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c105);
                                }
                            }
                            if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 6) === peg$c251) {
                                    s1 = peg$c251;
                                    peg$currPos += 6;
                                }
                                else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c252);
                                    }
                                }
                                if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 6) === peg$c78) {
                                        s1 = peg$c78;
                                        peg$currPos += 6;
                                    }
                                    else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c79);
                                        }
                                    }
                                    if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c19) {
                                            s1 = peg$c19;
                                            peg$currPos += 2;
                                        }
                                        else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c20);
                                            }
                                        }
                                        if (s1 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 9) === peg$c82) {
                                                s1 = peg$c82;
                                                peg$currPos += 9;
                                            }
                                            else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c83);
                                                }
                                            }
                                            if (s1 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 6) === peg$c320) {
                                                    s1 = peg$c320;
                                                    peg$currPos += 6;
                                                }
                                                else {
                                                    s1 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c321);
                                                    }
                                                }
                                                if (s1 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 7) === peg$c297) {
                                                        s1 = peg$c297;
                                                        peg$currPos += 7;
                                                    }
                                                    else {
                                                        s1 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                            peg$fail(peg$c298);
                                                        }
                                                    }
                                                    if (s1 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 6) === peg$c132) {
                                                            s1 = peg$c132;
                                                            peg$currPos += 6;
                                                        }
                                                        else {
                                                            s1 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                                peg$fail(peg$c133);
                                                            }
                                                        }
                                                        if (s1 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 8) === peg$c102) {
                                                                s1 = peg$c102;
                                                                peg$currPos += 8;
                                                            }
                                                            else {
                                                                s1 = peg$FAILED;
                                                                if (peg$silentFails === 0) {
                                                                    peg$fail(peg$c103);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (s1 !== peg$FAILED) {
            if (peg$c465.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c466);
                }
            }
            if (s2 === peg$FAILED) {
                s2 = peg$currPos;
                peg$silentFails++;
                if (input.length > peg$currPos) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c162);
                    }
                }
                peg$silentFails--;
                if (s3 === peg$FAILED) {
                    s2 = undefined;
                }
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c497(s1);
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseQuotedString() {
        let s0, s1, s2, s3, s4, s5, s6;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c499;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c500);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = [];
            if (peg$c501.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c502);
                }
            }
            while (s5 !== peg$FAILED) {
                s4.push(s5);
                if (peg$c501.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c502);
                    }
                }
            }
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 92) {
                    s5 = peg$c503;
                    peg$currPos++;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c504);
                    }
                }
                if (s5 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                        s6 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c162);
                        }
                    }
                    if (s6 !== peg$FAILED) {
                        s4 = [s4, s5, s6];
                        s3 = s4;
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = [];
                if (peg$c501.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c502);
                    }
                }
                while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    if (peg$c501.test(input.charAt(peg$currPos))) {
                        s5 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c502);
                        }
                    }
                }
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 92) {
                        s5 = peg$c503;
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c504);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        if (input.length > peg$currPos) {
                            s6 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s6 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c162);
                            }
                        }
                        if (s6 !== peg$FAILED) {
                            s4 = [s4, s5, s6];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = [];
                if (peg$c505.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c506);
                    }
                }
                while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    if (peg$c505.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c506);
                        }
                    }
                }
                if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 39) {
                        s4 = peg$c499;
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c500);
                        }
                    }
                    if (s4 === peg$FAILED) {
                        s4 = peg$currPos;
                        if (input.length > peg$currPos) {
                            s5 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c162);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s4;
                            s5 = peg$c507(s2, s3);
                        }
                        s4 = s5;
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c508(s2, s3);
                        s0 = s1;
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 34) {
                s1 = peg$c509;
                peg$currPos++;
            }
            else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c510);
                }
            }
            if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = [];
                if (peg$c511.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c512);
                    }
                }
                while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    if (peg$c511.test(input.charAt(peg$currPos))) {
                        s5 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c512);
                        }
                    }
                }
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 92) {
                        s5 = peg$c503;
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c504);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        if (input.length > peg$currPos) {
                            s6 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s6 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c162);
                            }
                        }
                        if (s6 !== peg$FAILED) {
                            s4 = [s4, s5, s6];
                            s3 = s4;
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$currPos;
                    s4 = [];
                    if (peg$c511.test(input.charAt(peg$currPos))) {
                        s5 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c512);
                        }
                    }
                    while (s5 !== peg$FAILED) {
                        s4.push(s5);
                        if (peg$c511.test(input.charAt(peg$currPos))) {
                            s5 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c512);
                            }
                        }
                    }
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 92) {
                            s5 = peg$c503;
                            peg$currPos++;
                        }
                        else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c504);
                            }
                        }
                        if (s5 !== peg$FAILED) {
                            if (input.length > peg$currPos) {
                                s6 = input.charAt(peg$currPos);
                                peg$currPos++;
                            }
                            else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c162);
                                }
                            }
                            if (s6 !== peg$FAILED) {
                                s4 = [s4, s5, s6];
                                s3 = s4;
                            }
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        }
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                }
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    if (peg$c513.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c514);
                        }
                    }
                    while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        if (peg$c513.test(input.charAt(peg$currPos))) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c514);
                            }
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 34) {
                            s4 = peg$c509;
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c510);
                            }
                        }
                        if (s4 === peg$FAILED) {
                            s4 = peg$currPos;
                            if (input.length > peg$currPos) {
                                s5 = input.charAt(peg$currPos);
                                peg$currPos++;
                            }
                            else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c162);
                                }
                            }
                            if (s5 !== peg$FAILED) {
                                peg$savedPos = s4;
                                s5 = peg$c515(s2, s3);
                            }
                            s4 = s5;
                        }
                        if (s4 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c508(s2, s3);
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c498);
            }
        }
        return s0;
    }
    function peg$parsecommaOrNewline() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parsemultiLineSpace();
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
                s2 = peg$c30;
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c31);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsemultiLineSpace();
                if (s3 !== peg$FAILED) {
                    s1 = [s1, s2, s3];
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseeolWhiteSpace();
            if (s1 !== peg$FAILED) {
                s2 = peg$parsemultiLineSpace();
                if (s2 !== peg$FAILED) {
                    s1 = [s1, s2];
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parseopenBrace() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parsemultiLineSpace();
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
                s2 = peg$c28;
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c29);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parsemultiLineSpace();
                if (s3 !== peg$FAILED) {
                    s1 = [s1, s2, s3];
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsecloseBrace() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parsecommaOrNewline();
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsemultiLineSpace();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                    s3 = peg$c32;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c33);
                    }
                }
                if (s3 !== peg$FAILED) {
                    s1 = [s1, s2, s3];
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsebackquotedString() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 96) {
            s1 = peg$c517;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c518);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c519.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c520);
                }
            }
            if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    if (peg$c519.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c520);
                        }
                    }
                }
            }
            else {
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 96) {
                    s3 = peg$c517;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c518);
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c521(s2);
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c516);
            }
        }
        return s0;
    }
    function peg$parseid() {
        let s0, s1;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseQuotedString();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c523(s1);
        }
        s0 = s1;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c522);
            }
        }
        return s0;
    }
    function peg$parseupperIdent() {
        let s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parseUpperReservedWord();
        peg$silentFails--;
        if (s2 === peg$FAILED) {
            s1 = undefined;
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            if (peg$c525.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c526);
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = [];
                if (peg$c527.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c528);
                    }
                }
                while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    if (peg$c527.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c528);
                        }
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11();
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c524);
            }
        }
        return s0;
    }
    function peg$parselowerIdent() {
        let s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parseReservedWord();
        peg$silentFails--;
        if (s2 === peg$FAILED) {
            s1 = undefined;
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseunsafeLowerIdent();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c529);
            }
        }
        return s0;
    }
    function peg$parseunsafeLowerIdent() {
        let s0, s1, s2, s3, s4, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$c531.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c532);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c527.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c528);
                }
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c527.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c528);
                    }
                }
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                peg$silentFails++;
                if (peg$c465.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c466);
                    }
                }
                if (s4 === peg$FAILED) {
                    s4 = peg$currPos;
                    peg$silentFails++;
                    if (input.length > peg$currPos) {
                        s5 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c162);
                        }
                    }
                    peg$silentFails--;
                    if (s5 === peg$FAILED) {
                        s4 = undefined;
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                peg$silentFails--;
                if (s4 !== peg$FAILED) {
                    peg$currPos = s3;
                    s3 = undefined;
                }
                else {
                    s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11();
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c530);
            }
        }
        return s0;
    }
    function peg$parsefieldName() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$c531.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c532);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c527.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c528);
                }
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c527.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c528);
                    }
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c533);
            }
        }
        return s0;
    }
    function peg$parsedottedFields() {
        let s0, s1, s2, s3, s4, s5, s6;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsefieldName();
        if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
                s5 = peg$c280;
                peg$currPos++;
            }
            else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c281);
                }
            }
            if (s5 !== peg$FAILED) {
                s6 = peg$parsefieldName();
                if (s6 !== peg$FAILED) {
                    s5 = [s5, s6];
                    s4 = s5;
                }
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s4;
                s4 = peg$FAILED;
            }
            while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 46) {
                    s5 = peg$c280;
                    peg$currPos++;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c281);
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsefieldName();
                    if (s6 !== peg$FAILED) {
                        s5 = [s5, s6];
                        s4 = s5;
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
            }
            if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        }
        else {
            s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c534);
            }
        }
        return s0;
    }
    function peg$parsedottedName() {
        let s0, s1, s2, s3, s4, s5, s6;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsesimpleName();
        if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
                s5 = peg$c280;
                peg$currPos++;
            }
            else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c281);
                }
            }
            if (s5 !== peg$FAILED) {
                s6 = peg$parsesimpleName();
                if (s6 !== peg$FAILED) {
                    s5 = [s5, s6];
                    s4 = s5;
                }
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s4;
                s4 = peg$FAILED;
            }
            while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 46) {
                    s5 = peg$c280;
                    peg$currPos++;
                }
                else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c281);
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsesimpleName();
                    if (s6 !== peg$FAILED) {
                        s5 = [s5, s6];
                        s4 = s5;
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
            }
            if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
        }
        else {
            s0 = s1;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c535);
            }
        }
        return s0;
    }
    function peg$parsesimpleName() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$c537.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c538);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c539.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c540);
                }
            }
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c539.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c540);
                    }
                }
            }
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11();
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c536);
            }
        }
        return s0;
    }
    function peg$parsewhiteSpace() {
        let s0, s1;
        peg$silentFails++;
        s0 = [];
        s1 = peg$parsespaceChar();
        if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
                s0.push(s1);
                s1 = peg$parsespaceChar();
            }
        }
        else {
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c541);
            }
        }
        return s0;
    }
    function peg$parsespaceChar() {
        let s0, s1;
        peg$silentFails++;
        s0 = peg$parseblockComment();
        if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 32) {
                s0 = peg$c489;
                peg$currPos++;
            }
            else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c490);
                }
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 160) {
                    s1 = peg$c543;
                    peg$currPos++;
                }
                else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c544);
                    }
                }
                if (s1 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 9) {
                        s1 = peg$c545;
                        peg$currPos++;
                    }
                    else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c546);
                        }
                    }
                    if (s1 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 12) {
                            s1 = peg$c547;
                            peg$currPos++;
                        }
                        else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c548);
                            }
                        }
                        if (s1 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 13) {
                                s1 = peg$c549;
                                peg$currPos++;
                            }
                            else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c550);
                                }
                            }
                            if (s1 === peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 11) {
                                    s1 = peg$c551;
                                    peg$currPos++;
                                }
                                else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c552);
                                    }
                                }
                            }
                        }
                    }
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c553();
                }
                s0 = s1;
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c542);
            }
        }
        return s0;
    }
    function peg$parseblockComment() {
        let s0, s1, s2, s3, s4, s5;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c555) {
            s1 = peg$c555;
            peg$currPos += 2;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c556);
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseblockCommentBody();
            while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseblockCommentBody();
            }
            if (s2 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c557) {
                    s3 = peg$c557;
                    peg$currPos += 2;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c558);
                    }
                }
                if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$currPos;
                    peg$silentFails++;
                    if (input.length > peg$currPos) {
                        s5 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c162);
                        }
                    }
                    peg$silentFails--;
                    if (s5 === peg$FAILED) {
                        s4 = undefined;
                    }
                    else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c559();
                    }
                    s3 = s4;
                }
                if (s3 !== peg$FAILED) {
                    s1 = [s1, s2, s3];
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c554);
            }
        }
        return s0;
    }
    function peg$parseblockCommentBody() {
        let s0, s1, s2;
        s0 = peg$parseblockComment();
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 2) === peg$c557) {
                s2 = peg$c557;
                peg$currPos += 2;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c558);
                }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
                s1 = undefined;
            }
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                }
                else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c162);
                    }
                }
                if (s2 !== peg$FAILED) {
                    s1 = [s1, s2];
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parseeolWhiteSpace() {
        let s0, s1, s2, s3, s4;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsespaceChar();
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parsespaceChar();
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            }
            else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c162);
                }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
                s2 = undefined;
            }
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsespaceChar();
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsespaceChar();
            }
            if (s1 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c561) {
                    s2 = peg$c561;
                    peg$currPos += 2;
                }
                else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c562);
                    }
                }
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    if (peg$c9.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    }
                    else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c10);
                        }
                    }
                    while (s4 !== peg$FAILED) {
                        s3.push(s4);
                        if (peg$c9.test(input.charAt(peg$currPos))) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        }
                        else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c10);
                            }
                        }
                    }
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parseeolWhiteSpace();
                        if (s4 !== peg$FAILED) {
                            s1 = [s1, s2, s3, s4];
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$parsespaceChar();
                while (s2 !== peg$FAILED) {
                    s1.push(s2);
                    s2 = peg$parsespaceChar();
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseeol();
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseeolWhiteSpace();
                        if (s3 === peg$FAILED) {
                            s3 = null;
                        }
                        if (s3 !== peg$FAILED) {
                            s1 = [s1, s2, s3];
                            s0 = s1;
                        }
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                    else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c560);
            }
        }
        return s0;
    }
    function peg$parsemultiLineSpace() {
        let s0, s1, s2;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parseeolWhiteSpace();
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsewhiteSpace();
            if (s2 === peg$FAILED) {
                s2 = null;
            }
            if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c563);
            }
        }
        return s0;
    }
    function peg$parseeol() {
        let s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 13) {
            s1 = peg$c549;
            peg$currPos++;
        }
        else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c550);
            }
        }
        if (s1 === peg$FAILED) {
            s1 = null;
        }
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 10) {
                s2 = peg$c565;
                peg$currPos++;
            }
            else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                    peg$fail(peg$c566);
                }
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 13) {
                    s3 = peg$c549;
                    peg$currPos++;
                }
                else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                        peg$fail(peg$c550);
                    }
                }
                if (s3 === peg$FAILED) {
                    s3 = null;
                }
                if (s3 !== peg$FAILED) {
                    s1 = [s1, s2, s3];
                    s0 = s1;
                }
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
                peg$fail(peg$c564);
            }
        }
        return s0;
    }
    let indent = '';
    let startIndent = '';
    const indents = [];
    const emptyRef = () => ({ kind: 'handle-ref', id: null, name: null, tags: [], location: location() });
    const paxelModes = [false];
    function resetPaxelModes() {
        while (paxelModes.length) {
            paxelModes.pop();
        }
        pushPaxelMode(false);
    }
    function isPaxelMode() {
        return paxelModes[paxelModes.length - 1];
    }
    function pushPaxelMode(mode) {
        paxelModes.push(mode);
    }
    function popPaxelMode() {
        paxelModes.pop();
    }
    function extractIndented(items) {
        return items[1].map(item => item[1]);
    }
    /**
     * Utility for extracting values out of comma-separated lists, of the form:
     * `items:(X (commaOrNewline X)*)?`.
     */
    function extractCommaSeparated(items) {
        if (items == null || items.length === 0) {
            return [];
        }
        const [first, rest] = items;
        return [first, ...rest.map(item => item[1])];
    }
    function optional(result, extract, defaultValue) {
        if (result !== null) {
            const value = extract(result);
            if (value !== null) {
                return value;
            }
        }
        return defaultValue === null ? null : defaultValue;
    }
    function checkNormal(result, path = '') {
        if (['string', 'number', 'bigint', 'boolean'].includes(typeof result) || result === null) {
            return;
        }
        if (result === undefined) {
            internalError(`Result was undefined at ${path}`);
        }
        if (Array.isArray(result)) {
            let i = 0;
            for (const item of result) {
                checkNormal(item, `${path}/${i}`);
                i++;
            }
            return;
        }
        if (result instanceof Map) {
            for (const [key, value] of result) {
                checkNormal(value, `${path}/${key}`);
            }
            return;
        }
        if (result.model) {
            internalError(`Unexpected 'model' in ${JSON.stringify(result)} at ${path}`);
        }
        if (!result.location) {
            internalError(`No 'location' in ${JSON.stringify(result)} at ${path}`);
        }
        if (!result.kind) {
            internalError(`No 'kind' in ${JSON.stringify(result)} at ${path}`);
        }
        if (result.kind === 'entity-inline') {
            return;
        }
        for (const key of Object.keys(result)) {
            if (['location', 'kind'].includes(key)) {
                continue;
            }
            checkNormal(result[key], `${path}/${key}`);
        }
    }
    function toAstNode(data) {
        const loc = location();
        loc['text'] = text();
        return { ...data, location: loc };
    }
    function buildInterfaceArgument(name, direction, isOptional, type) {
        if (direction === 'hosts') {
            error(`Interface cannot have arguments with a 'hosts' direction.`);
        }
        if (direction === 'consumes' || direction === 'provides') {
            let isSet = false;
            if (type && type.kind === 'collection-type') {
                isSet = true;
                type = type.type; // unwrap the inner type of the collection type;
            }
            if (type && type.kind === 'slot-type') {
                const slotType = type;
                slotType.fields.forEach(({ name, value }) => {
                    error(`interface slots do not currently support fields`);
                });
            }
            else if (type !== null) {
                error('cannot consume or provide non slot types');
            }
            return toAstNode({
                kind: 'interface-slot',
                name,
                isRequired: !isOptional,
                direction,
                isSet,
            });
        }
        if (isOptional) {
            // TODO: Support interface optionality
            error('interface handles do not support optionality');
        }
        return toAstNode({
            kind: 'interface-argument',
            direction,
            type,
            name: name || '*',
        });
    }
    function descapeString(parts, tail) {
        const converted = parts.map(([text, _slash, char]) => {
            switch (char) {
                case 't':
                    char = '\t';
                    break;
                case 'n':
                    char = '\n';
                    break;
                case 'b':
                    char = '\b';
                    break;
                case 'r':
                    char = '\r';
                    break;
                case '\\':
                    char = '\\';
                    break;
                case '"':
                    char = '"';
                    break;
                case "'":
                    char = "'";
                    break;
            }
            return text.join('') + char;
        });
        return converted.join('') + tail.join('');
    }
    // Expected usage to parse a list of bracket-enclosed Things:
    // '[' multiLineSpace parts:(Thing whiteSpace? ',' multiLineSpace)* end:Thing? multiLineSpace ']'
    function combineMultiLine(parts, end) {
        const res = parts.map(p => p[0]);
        if (end != null) {
            res.push(end);
        }
        return res;
    }
    function internalError(message) {
        error(`Internal Parser Error: ${message}`);
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
    }
    else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length
            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
}
const manifest_parser_parse = peg$parse;
//# sourceMappingURL=manifest-parser.js.map
// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__(1);

// EXTERNAL MODULE: external "http"
var external_http_ = __webpack_require__(21);

// EXTERNAL MODULE: external "url"
var external_url_ = __webpack_require__(11);

// EXTERNAL MODULE: external "https"
var external_https_ = __webpack_require__(37);

// EXTERNAL MODULE: external "zlib"
var external_zlib_ = __webpack_require__(4);

// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/node_modules/node-fetch/lib/index.mjs






// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

// fix for "Readable" isn't a named export issue
const Readable = external_stream_.Readable;

const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');

class Blob {
	constructor() {
		this[TYPE] = '';

		const blobParts = arguments[0];
		const options = arguments[1];

		const buffers = [];
		let size = 0;

		if (blobParts) {
			const a = blobParts;
			const length = Number(a.length);
			for (let i = 0; i < length; i++) {
				const element = a[i];
				let buffer;
				if (element instanceof Buffer) {
					buffer = element;
				} else if (ArrayBuffer.isView(element)) {
					buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
				} else if (element instanceof ArrayBuffer) {
					buffer = Buffer.from(element);
				} else if (element instanceof Blob) {
					buffer = element[BUFFER];
				} else {
					buffer = Buffer.from(typeof element === 'string' ? element : String(element));
				}
				size += buffer.length;
				buffers.push(buffer);
			}
		}

		this[BUFFER] = Buffer.concat(buffers);

		let type = options && options.type !== undefined && String(options.type).toLowerCase();
		if (type && !/[^\u0020-\u007E]/.test(type)) {
			this[TYPE] = type;
		}
	}
	get size() {
		return this[BUFFER].length;
	}
	get type() {
		return this[TYPE];
	}
	text() {
		return Promise.resolve(this[BUFFER].toString());
	}
	arrayBuffer() {
		const buf = this[BUFFER];
		const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		return Promise.resolve(ab);
	}
	stream() {
		const readable = new Readable();
		readable._read = function () {};
		readable.push(this[BUFFER]);
		readable.push(null);
		return readable;
	}
	toString() {
		return '[object Blob]';
	}
	slice() {
		const size = this.size;

		const start = arguments[0];
		const end = arguments[1];
		let relativeStart, relativeEnd;
		if (start === undefined) {
			relativeStart = 0;
		} else if (start < 0) {
			relativeStart = Math.max(size + start, 0);
		} else {
			relativeStart = Math.min(start, size);
		}
		if (end === undefined) {
			relativeEnd = size;
		} else if (end < 0) {
			relativeEnd = Math.max(size + end, 0);
		} else {
			relativeEnd = Math.min(end, size);
		}
		const span = Math.max(relativeEnd - relativeStart, 0);

		const buffer = this[BUFFER];
		const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
		const blob = new Blob([], { type: arguments[2] });
		blob[BUFFER] = slicedBuffer;
		return blob;
	}
}

Object.defineProperties(Blob.prototype, {
	size: { enumerable: true },
	type: { enumerable: true },
	slice: { enumerable: true }
});

Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
	value: 'Blob',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */

/**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */
function FetchError(message, type, systemError) {
  Error.call(this, message);

  this.message = message;
  this.type = type;

  // when err.type is `system`, err.code contains system error code
  if (systemError) {
    this.code = this.errno = systemError.code;
  }

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';

let convert;
try {
	convert = require('encoding').convert;
} catch (e) {}

const INTERNALS = Symbol('Body internals');

// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = external_stream_.PassThrough;

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
function Body(body) {
	var _this = this;

	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$size = _ref.size;

	let size = _ref$size === undefined ? 0 : _ref$size;
	var _ref$timeout = _ref.timeout;
	let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

	if (body == null) {
		// body is undefined or null
		body = null;
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		body = Buffer.from(body.toString());
	} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		body = Buffer.from(body);
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
	} else if (body instanceof external_stream_) ; else {
		// none of the above
		// coerce to string then buffer
		body = Buffer.from(String(body));
	}
	this[INTERNALS] = {
		body,
		disturbed: false,
		error: null
	};
	this.size = size;
	this.timeout = timeout;

	if (body instanceof external_stream_) {
		body.on('error', function (err) {
			const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
			_this[INTERNALS].error = error;
		});
	}
}

Body.prototype = {
	get body() {
		return this[INTERNALS].body;
	},

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	},

	/**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */
	arrayBuffer() {
		return consumeBody.call(this).then(function (buf) {
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		});
	},

	/**
  * Return raw response as Blob
  *
  * @return Promise
  */
	blob() {
		let ct = this.headers && this.headers.get('content-type') || '';
		return consumeBody.call(this).then(function (buf) {
			return Object.assign(
			// Prevent copying
			new Blob([], {
				type: ct.toLowerCase()
			}), {
				[BUFFER]: buf
			});
		});
	},

	/**
  * Decode response as json
  *
  * @return  Promise
  */
	json() {
		var _this2 = this;

		return consumeBody.call(this).then(function (buffer) {
			try {
				return JSON.parse(buffer.toString());
			} catch (err) {
				return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
			}
		});
	},

	/**
  * Decode response as text
  *
  * @return  Promise
  */
	text() {
		return consumeBody.call(this).then(function (buffer) {
			return buffer.toString();
		});
	},

	/**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */
	buffer() {
		return consumeBody.call(this);
	},

	/**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */
	textConverted() {
		var _this3 = this;

		return consumeBody.call(this).then(function (buffer) {
			return convertBody(buffer, _this3.headers);
		});
	}
};

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: { enumerable: true },
	bodyUsed: { enumerable: true },
	arrayBuffer: { enumerable: true },
	blob: { enumerable: true },
	json: { enumerable: true },
	text: { enumerable: true }
});

Body.mixIn = function (proto) {
	for (const name of Object.getOwnPropertyNames(Body.prototype)) {
		// istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	}
};

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */
function consumeBody() {
	var _this4 = this;

	if (this[INTERNALS].disturbed) {
		return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
	}

	this[INTERNALS].disturbed = true;

	if (this[INTERNALS].error) {
		return Body.Promise.reject(this[INTERNALS].error);
	}

	let body = this.body;

	// body is null
	if (body === null) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is blob
	if (isBlob(body)) {
		body = body.stream();
	}

	// body is buffer
	if (Buffer.isBuffer(body)) {
		return Body.Promise.resolve(body);
	}

	// istanbul ignore if: should never happen
	if (!(body instanceof external_stream_)) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is stream
	// get ready to actually consume the body
	let accum = [];
	let accumBytes = 0;
	let abort = false;

	return new Body.Promise(function (resolve, reject) {
		let resTimeout;

		// allow timeout on slow response body
		if (_this4.timeout) {
			resTimeout = setTimeout(function () {
				abort = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
			}, _this4.timeout);
		}

		// handle stream errors
		body.on('error', function (err) {
			if (err.name === 'AbortError') {
				// if the request was aborted, reject with this Error
				abort = true;
				reject(err);
			} else {
				// other errors, such as incorrect content-encoding
				reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
			}
		});

		body.on('data', function (chunk) {
			if (abort || chunk === null) {
				return;
			}

			if (_this4.size && accumBytes + chunk.length > _this4.size) {
				abort = true;
				reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
				return;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		});

		body.on('end', function () {
			if (abort) {
				return;
			}

			clearTimeout(resTimeout);

			try {
				resolve(Buffer.concat(accum, accumBytes));
			} catch (err) {
				// handle streams that have accumulated too much data (issue #414)
				reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
			}
		});
	});
}

/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */
function convertBody(buffer, headers) {
	if (typeof convert !== 'function') {
		throw new Error('The package `encoding` must be installed to use the textConverted() function');
	}

	const ct = headers.get('content-type');
	let charset = 'utf-8';
	let res, str;

	// header
	if (ct) {
		res = /charset=([^;]*)/i.exec(ct);
	}

	// no charset in content type, peek at response body for at most 1024 bytes
	str = buffer.slice(0, 1024).toString();

	// html5
	if (!res && str) {
		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
	}

	// html4
	if (!res && str) {
		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);

		if (res) {
			res = /charset=(.*)/i.exec(res.pop());
		}
	}

	// xml
	if (!res && str) {
		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
	}

	// found charset
	if (res) {
		charset = res.pop();

		// prevent decode issues when sites use incorrect encoding
		// ref: https://hsivonen.fi/encoding-menu/
		if (charset === 'gb2312' || charset === 'gbk') {
			charset = 'gb18030';
		}
	}

	// turn raw buffers into a single utf-8 buffer
	return convert(buffer, 'UTF-8', charset).toString();
}

/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */
function isURLSearchParams(obj) {
	// Duck-typing as a necessary condition.
	if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
		return false;
	}

	// Brand-checking and more duck-typing as optional condition.
	return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob(obj) {
	return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */
function clone(instance) {
	let p1, p2;
	let body = instance.body;

	// don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if (body instanceof external_stream_ && typeof body.getBoundary !== 'function') {
		// tee instance body
		p1 = new PassThrough();
		p2 = new PassThrough();
		body.pipe(p1);
		body.pipe(p2);
		// set instance body to teed body and return the other teed body
		instance[INTERNALS].body = p1;
		body = p2;
	}

	return body;
}

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */
function extractContentType(body) {
	if (body === null) {
		// body is null
		return null;
	} else if (typeof body === 'string') {
		// body is string
		return 'text/plain;charset=UTF-8';
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	} else if (isBlob(body)) {
		// body is blob
		return body.type || null;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return null;
	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		return null;
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		return null;
	} else if (typeof body.getBoundary === 'function') {
		// detect form data input from form-data module
		return `multipart/form-data;boundary=${body.getBoundary()}`;
	} else if (body instanceof external_stream_) {
		// body is stream
		// can't really do much about this
		return null;
	} else {
		// Body constructor defaults other things to string
		return 'text/plain;charset=UTF-8';
	}
}

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */
function getTotalBytes(instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		return 0;
	} else if (isBlob(body)) {
		return body.size;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return body.length;
	} else if (body && typeof body.getLengthSync === 'function') {
		// detect form data input from form-data module
		if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
		body.hasKnownLength && body.hasKnownLength()) {
			// 2.x
			return body.getLengthSync();
		}
		return null;
	} else {
		// body is stream
		return null;
	}
}

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */
function writeToStream(dest, instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		dest.end();
	} else if (isBlob(body)) {
		body.stream().pipe(dest);
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		dest.write(body);
		dest.end();
	} else {
		// body is stream
		body.pipe(dest);
	}
}

// expose Promise
Body.Promise = global.Promise;

/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */

const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

function validateName(name) {
	name = `${name}`;
	if (invalidTokenRegex.test(name) || name === '') {
		throw new TypeError(`${name} is not a legal HTTP header name`);
	}
}

function validateValue(value) {
	value = `${value}`;
	if (invalidHeaderCharRegex.test(value)) {
		throw new TypeError(`${value} is not a legal HTTP header value`);
	}
}

/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */
function find(map, name) {
	name = name.toLowerCase();
	for (const key in map) {
		if (key.toLowerCase() === name) {
			return key;
		}
	}
	return undefined;
}

const MAP = Symbol('map');
class Headers {
	/**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */
	constructor() {
		let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

		this[MAP] = Object.create(null);

		if (init instanceof Headers) {
			const rawHeaders = init.raw();
			const headerNames = Object.keys(rawHeaders);

			for (const headerName of headerNames) {
				for (const value of rawHeaders[headerName]) {
					this.append(headerName, value);
				}
			}

			return;
		}

		// We don't worry about converting prop to ByteString here as append()
		// will handle it.
		if (init == null) ; else if (typeof init === 'object') {
			const method = init[Symbol.iterator];
			if (method != null) {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				const pairs = [];
				for (const pair of init) {
					if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
						throw new TypeError('Each header pair must be iterable');
					}
					pairs.push(Array.from(pair));
				}

				for (const pair of pairs) {
					if (pair.length !== 2) {
						throw new TypeError('Each header pair must be a name/value tuple');
					}
					this.append(pair[0], pair[1]);
				}
			} else {
				// record<ByteString, ByteString>
				for (const key of Object.keys(init)) {
					const value = init[key];
					this.append(key, value);
				}
			}
		} else {
			throw new TypeError('Provided initializer must be an object');
		}
	}

	/**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */
	get(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key === undefined) {
			return null;
		}

		return this[MAP][key].join(', ');
	}

	/**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */
	forEach(callback) {
		let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

		let pairs = getHeaders(this);
		let i = 0;
		while (i < pairs.length) {
			var _pairs$i = pairs[i];
			const name = _pairs$i[0],
			      value = _pairs$i[1];

			callback.call(thisArg, value, name, this);
			pairs = getHeaders(this);
			i++;
		}
	}

	/**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	set(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		this[MAP][key !== undefined ? key : name] = [value];
	}

	/**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	append(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			this[MAP][key].push(value);
		} else {
			this[MAP][name] = [value];
		}
	}

	/**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */
	has(name) {
		name = `${name}`;
		validateName(name);
		return find(this[MAP], name) !== undefined;
	}

	/**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */
	delete(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			delete this[MAP][key];
		}
	}

	/**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */
	raw() {
		return this[MAP];
	}

	/**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */
	keys() {
		return createHeadersIterator(this, 'key');
	}

	/**
  * Get an iterator on values.
  *
  * @return  Iterator
  */
	values() {
		return createHeadersIterator(this, 'value');
	}

	/**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */
	[Symbol.iterator]() {
		return createHeadersIterator(this, 'key+value');
	}
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];

Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
	value: 'Headers',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Headers.prototype, {
	get: { enumerable: true },
	forEach: { enumerable: true },
	set: { enumerable: true },
	append: { enumerable: true },
	has: { enumerable: true },
	delete: { enumerable: true },
	keys: { enumerable: true },
	values: { enumerable: true },
	entries: { enumerable: true }
});

function getHeaders(headers) {
	let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

	const keys = Object.keys(headers[MAP]).sort();
	return keys.map(kind === 'key' ? function (k) {
		return k.toLowerCase();
	} : kind === 'value' ? function (k) {
		return headers[MAP][k].join(', ');
	} : function (k) {
		return [k.toLowerCase(), headers[MAP][k].join(', ')];
	});
}

const INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
	const iterator = Object.create(HeadersIteratorPrototype);
	iterator[INTERNAL] = {
		target,
		kind,
		index: 0
	};
	return iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
	next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
			throw new TypeError('Value of `this` is not a HeadersIterator');
		}

		var _INTERNAL = this[INTERNAL];
		const target = _INTERNAL.target,
		      kind = _INTERNAL.kind,
		      index = _INTERNAL.index;

		const values = getHeaders(target, kind);
		const len = values.length;
		if (index >= len) {
			return {
				value: undefined,
				done: true
			};
		}

		this[INTERNAL].index = index + 1;

		return {
			value: values[index],
			done: false
		};
	}
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
	value: 'HeadersIterator',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */
function exportNodeCompatibleHeaders(headers) {
	const obj = Object.assign({ __proto__: null }, headers[MAP]);

	// http.request() only supports string as Host header. This hack makes
	// specifying custom Host header possible.
	const hostHeaderKey = find(headers[MAP], 'Host');
	if (hostHeaderKey !== undefined) {
		obj[hostHeaderKey] = obj[hostHeaderKey][0];
	}

	return obj;
}

/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */
function createHeadersLenient(obj) {
	const headers = new Headers();
	for (const name of Object.keys(obj)) {
		if (invalidTokenRegex.test(name)) {
			continue;
		}
		if (Array.isArray(obj[name])) {
			for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) {
					continue;
				}
				if (headers[MAP][name] === undefined) {
					headers[MAP][name] = [val];
				} else {
					headers[MAP][name].push(val);
				}
			}
		} else if (!invalidHeaderCharRegex.test(obj[name])) {
			headers[MAP][name] = [obj[name]];
		}
	}
	return headers;
}

const INTERNALS$1 = Symbol('Response internals');

// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = external_http_.STATUS_CODES;

/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response {
	constructor() {
		let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		Body.call(this, body, opts);

		const status = opts.status || 200;
		const headers = new Headers(opts.headers);

		if (body != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(body);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS$1] = {
			url: opts.url,
			status,
			statusText: opts.statusText || STATUS_CODES[status],
			headers,
			counter: opts.counter
		};
	}

	get url() {
		return this[INTERNALS$1].url || '';
	}

	get status() {
		return this[INTERNALS$1].status;
	}

	/**
  * Convenience property representing if the request ended normally
  */
	get ok() {
		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
	}

	get redirected() {
		return this[INTERNALS$1].counter > 0;
	}

	get statusText() {
		return this[INTERNALS$1].statusText;
	}

	get headers() {
		return this[INTERNALS$1].headers;
	}

	/**
  * Clone this response
  *
  * @return  Response
  */
	clone() {
		return new Response(clone(this), {
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected
		});
	}
}

Body.mixIn(Response.prototype);

Object.defineProperties(Response.prototype, {
	url: { enumerable: true },
	status: { enumerable: true },
	ok: { enumerable: true },
	redirected: { enumerable: true },
	statusText: { enumerable: true },
	headers: { enumerable: true },
	clone: { enumerable: true }
});

Object.defineProperty(Response.prototype, Symbol.toStringTag, {
	value: 'Response',
	writable: false,
	enumerable: false,
	configurable: true
});

const INTERNALS$2 = Symbol('Request internals');

// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = external_url_.parse;
const format_url = external_url_.format;

const streamDestructionSupported = 'destroy' in external_stream_.Readable.prototype;

/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */
function isRequest(input) {
	return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}

function isAbortSignal(signal) {
	const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
	return !!(proto && proto.constructor.name === 'AbortSignal');
}

/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request {
	constructor(input) {
		let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		let parsedURL;

		// normalize input
		if (!isRequest(input)) {
			if (input && input.href) {
				// in order to support Node.js' Url objects; though WHATWG's URL objects
				// will fall into this branch also (since their `toString()` will return
				// `href` property anyway)
				parsedURL = parse_url(input.href);
			} else {
				// coerce input to a string before attempting to parse
				parsedURL = parse_url(`${input}`);
			}
			input = {};
		} else {
			parsedURL = parse_url(input.url);
		}

		let method = init.method || input.method || 'GET';
		method = method.toUpperCase();

		if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

		Body.call(this, inputBody, {
			timeout: init.timeout || input.timeout || 0,
			size: init.size || input.size || 0
		});

		const headers = new Headers(init.headers || input.headers || {});

		if (inputBody != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(inputBody);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ? input.signal : null;
		if ('signal' in init) signal = init.signal;

		if (signal != null && !isAbortSignal(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal');
		}

		this[INTERNALS$2] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal
		};

		// node-fetch-only options
		this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
		this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
	}

	get method() {
		return this[INTERNALS$2].method;
	}

	get url() {
		return format_url(this[INTERNALS$2].parsedURL);
	}

	get headers() {
		return this[INTERNALS$2].headers;
	}

	get redirect() {
		return this[INTERNALS$2].redirect;
	}

	get signal() {
		return this[INTERNALS$2].signal;
	}

	/**
  * Clone this request
  *
  * @return  Request
  */
	clone() {
		return new Request(this);
	}
}

Body.mixIn(Request.prototype);

Object.defineProperty(Request.prototype, Symbol.toStringTag, {
	value: 'Request',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Request.prototype, {
	method: { enumerable: true },
	url: { enumerable: true },
	headers: { enumerable: true },
	redirect: { enumerable: true },
	clone: { enumerable: true },
	signal: { enumerable: true }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */
function getNodeRequestOptions(request) {
	const parsedURL = request[INTERNALS$2].parsedURL;
	const headers = new Headers(request[INTERNALS$2].headers);

	// fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// Basic fetch
	if (!parsedURL.protocol || !parsedURL.hostname) {
		throw new TypeError('Only absolute URLs are supported');
	}

	if (!/^https?:$/.test(parsedURL.protocol)) {
		throw new TypeError('Only HTTP(S) protocols are supported');
	}

	if (request.signal && request.body instanceof external_stream_.Readable && !streamDestructionSupported) {
		throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
		contentLengthValue = '0';
	}
	if (request.body != null) {
		const totalBytes = getTotalBytes(request);
		if (typeof totalBytes === 'number') {
			contentLengthValue = String(totalBytes);
		}
	}
	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip,deflate');
	}

	let agent = request.agent;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	if (!headers.has('Connection') && !agent) {
		headers.set('Connection', 'close');
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	return Object.assign({}, parsedURL, {
		method: request.method,
		headers: exportNodeCompatibleHeaders(headers),
		agent
	});
}

/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */

/**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */
function AbortError(message) {
  Error.call(this, message);

  this.type = 'aborted';
  this.message = message;

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';

// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = external_stream_.PassThrough;
const resolve_url = external_url_.resolve;

/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */
function fetch(url, opts) {

	// allow custom promise
	if (!fetch.Promise) {
		throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
	}

	Body.Promise = fetch.Promise;

	// wrap http.request into fetch
	return new fetch.Promise(function (resolve, reject) {
		// build request object
		const request = new Request(url, opts);
		const options = getNodeRequestOptions(request);

		const send = (options.protocol === 'https:' ? external_https_ : external_http_).request;
		const signal = request.signal;

		let response = null;

		const abort = function abort() {
			let error = new AbortError('The user aborted a request.');
			reject(error);
			if (request.body && request.body instanceof external_stream_.Readable) {
				request.body.destroy(error);
			}
			if (!response || !response.body) return;
			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = function abortAndFinalize() {
			abort();
			finalize();
		};

		// send request
		const req = send(options);
		let reqTimeout;

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		function finalize() {
			req.abort();
			if (signal) signal.removeEventListener('abort', abortAndFinalize);
			clearTimeout(reqTimeout);
		}

		if (request.timeout) {
			req.once('socket', function (socket) {
				reqTimeout = setTimeout(function () {
					reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
					finalize();
				}, request.timeout);
			});
		}

		req.on('error', function (err) {
			reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
			finalize();
		});

		req.on('response', function (res) {
			clearTimeout(reqTimeout);

			const headers = createHeadersLenient(res.headers);

			// HTTP fetch step 5
			if (fetch.isRedirect(res.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				const locationURL = location === null ? null : resolve_url(request.url, location);

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
						if (locationURL !== null) {
							// handle corrupted header
							try {
								headers.set('Location', locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
						}
						break;
					case 'follow':
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOpts = {
							headers: new Headers(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: request.body,
							signal: request.signal,
							timeout: request.timeout
						};

						// HTTP-redirect fetch step 9
						if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
							requestOpts.method = 'GET';
							requestOpts.body = undefined;
							requestOpts.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 15
						resolve(fetch(new Request(locationURL, requestOpts)));
						finalize();
						return;
				}
			}

			// prepare response
			res.once('end', function () {
				if (signal) signal.removeEventListener('abort', abortAndFinalize);
			});
			let body = res.pipe(new PassThrough$1());

			const response_options = {
				url: request.url,
				status: res.statusCode,
				statusText: res.statusMessage,
				headers: headers,
				size: request.size,
				timeout: request.timeout,
				counter: request.counter
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: external_zlib_.Z_SYNC_FLUSH,
				finishFlush: external_zlib_.Z_SYNC_FLUSH
			};

			// for gzip
			if (codings == 'gzip' || codings == 'x-gzip') {
				body = body.pipe(external_zlib_.createGunzip(zlibOptions));
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// for deflate
			if (codings == 'deflate' || codings == 'x-deflate') {
				// handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = res.pipe(new PassThrough$1());
				raw.once('data', function (chunk) {
					// see http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = body.pipe(external_zlib_.createInflate());
					} else {
						body = body.pipe(external_zlib_.createInflateRaw());
					}
					response = new Response(body, response_options);
					resolve(response);
				});
				return;
			}

			// for br
			if (codings == 'br' && typeof external_zlib_.createBrotliDecompress === 'function') {
				body = body.pipe(external_zlib_.createBrotliDecompress());
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// otherwise, use response as-is
			response = new Response(body, response_options);
			resolve(response);
		});

		writeToStream(req, request);
	});
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */
fetch.isRedirect = function (code) {
	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};

// expose Promise
fetch.Promise = global.Promise;

/* harmony default export */ var lib = (fetch);


// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/fetch-node.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


//# sourceMappingURL=fetch-node.js.map
// EXTERNAL MODULE: external "vm"
var external_vm_ = __webpack_require__(23);
var external_vm_default = /*#__PURE__*/__webpack_require__.n(external_vm_);

// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/vm-node.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


//# sourceMappingURL=vm-node.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/fs-node.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


//# sourceMappingURL=fs-node.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/converters/jsonldToManifest.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const supportedTypes = ['Text', 'URL', 'Number', 'Boolean'];
class JsonldToManifest {
    static convert(jsonld, theClass = undefined) {
        const obj = JSON.parse(jsonld);
        const classes = {};
        const properties = {};
        if (!obj['@graph']) {
            obj['@graph'] = [obj];
        }
        for (const item of obj['@graph']) {
            if (item['@type'] === 'rdf:Property') {
                properties[item['@id']] = item;
            }
            else if (item['@type'] === 'rdfs:Class') {
                classes[item['@id']] = item;
                item['subclasses'] = [];
                item['superclass'] = null;
            }
        }
        for (const clazz of Object.values(classes)) {
            if (clazz['rdfs:subClassOf'] !== undefined) {
                if (clazz['rdfs:subClassOf'].length == undefined) {
                    clazz['rdfs:subClassOf'] = [clazz['rdfs:subClassOf']];
                }
                for (const subClass of clazz['rdfs:subClassOf']) {
                    const superclass = subClass['@id'];
                    if (clazz['superclass'] == undefined) {
                        clazz['superclass'] = [];
                    }
                    if (classes[superclass]) {
                        classes[superclass].subclasses.push(clazz);
                        clazz['superclass'].push(classes[superclass]);
                    }
                    else {
                        clazz['superclass'].push({ '@id': superclass });
                    }
                }
            }
        }
        for (const clazz of Object.values(classes)) {
            if (clazz['subclasses'].length === 0 && theClass == undefined) {
                theClass = clazz;
            }
        }
        const relevantProperties = [];
        for (const property of Object.values(properties)) {
            let domains = property['schema:domainIncludes'];
            if (!domains) {
                domains = { '@id': theClass['@id'] };
            }
            if (!domains.length) {
                domains = [domains];
            }
            domains = domains.map(a => a['@id']);
            if (domains.includes(theClass['@id'])) {
                const name = property['@id'].split(':')[1];
                let type = property['schema:rangeIncludes'];
                // The property can only be used if we know the type.
                // If the type is not known, ignore the property.
                if (type) {
                    if (!type.length) {
                        type = [type];
                    }
                    type = type.map(a => a['@id'].split(':')[1]);
                    type = type.filter(type => supportedTypes.includes(type));
                    if (type.length > 0) {
                        relevantProperties.push({ name, type });
                    }
                }
            }
        }
        const className = theClass['@id'].split(':')[1];
        const superNames = theClass && theClass.superclass ? theClass.superclass.map(a => a['@id'].split(':')[1]) : [];
        let s = '';
        for (const superName of superNames) {
            s += `import 'https://schema.org/${superName}'\n\n`;
        }
        s += `schema ${className}`;
        if (superNames.length > 0) {
            s += ` extends ${superNames.join(', ')}`;
        }
        if (relevantProperties.length > 0) {
            for (const property of relevantProperties) {
                let type;
                if (property.type.length > 1) {
                    type = '(' + property.type.join(' or ') + ')';
                }
                else {
                    type = property.type[0];
                }
                s += `\n  ${property.name}: ${type}`;
            }
        }
        s += '\n';
        return s;
    }
}
//# sourceMappingURL=jsonldToManifest.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/storage-key-parser.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


/**
 * Parses storage key string representations back into real StorageKey
 * instances.
 *
 * Singleton class with static methods. If you modify the default set of storage
 * keys in a test, remember to call StorageKeyParser.reset() in the tear-down
 * method.
 */
class StorageKeyParser {
    static getDefaultParsers() {
        return new Map(this.defaultParsers);
    }
    static parse(key) {
        const match = key.match(/^((?:\w|-)+):\/\/(.*)$/);
        if (!match) {
            throw new Error('Failed to parse storage key: ' + key);
        }
        const protocol = match[1];
        const parser = StorageKeyParser.parsers.get(protocol);
        if (!parser) {
            throw new Error(`Unknown storage key protocol ${protocol} in key ${key}.`);
        }
        return parser(key, StorageKeyParser.parse);
    }
    static reset() {
        this.parsers = this.getDefaultParsers();
    }
    static addParser(protocol, parser) {
        if (this.parsers.has(protocol)) {
            throw new Error(`Parser for storage key protocol ${protocol} already exists.`);
        }
        this.parsers.set(protocol, parser);
    }
    static addDefaultParser(protocol, parser) {
        this.defaultParsers.push([protocol, parser]);
        if (!this.parsers.has(protocol)) {
            this.parsers.set(protocol, parser);
        }
    }
}
StorageKeyParser.defaultParsers = [
    [reference_mode_storage_key_ReferenceModeStorageKey.protocol, reference_mode_storage_key_ReferenceModeStorageKey.fromString],
];
StorageKeyParser.parsers = StorageKeyParser.getDefaultParsers();
StorageKey.fromLiteral = (literal) => StorageKeyParser.parse(literal.key);
//# sourceMappingURL=storage-key-parser.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/reference.js
/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */







var ReferenceMode;
(function (ReferenceMode) {
    ReferenceMode[ReferenceMode["Unstored"] = 0] = "Unstored";
    ReferenceMode[ReferenceMode["Stored"] = 1] = "Stored";
})(ReferenceMode || (ReferenceMode = {}));
function toDate(timestamp) {
    if (timestamp == undefined) {
        return null;
    }
    if (typeof (timestamp) === 'number') {
        return new Date(timestamp);
    }
    return timestamp;
}
class reference_Reference {
    constructor(data, type, frontend) {
        this.entity = null;
        this.storageProxy = null;
        this.handle = null;
        this.id = data.id;
        this.creationTimestamp = toDate(data.creationTimestamp);
        this.expirationTimestamp = toDate(data.expirationTimestamp);
        this.entityStorageKey = data.entityStorageKey;
        if (this.entityStorageKey == null) {
            throw Error('entity storage key must be defined');
        }
        this.backingKey = reference_Reference.extractBackingKey(this.entityStorageKey);
        this.frontend = frontend;
        this.type = type;
        this[SYMBOL_INTERNALS] = {
            serialize: () => ({
                id: this.id,
                creationTimestamp: this.creationTimestamp ? this.creationTimestamp.getTime() : null,
                expirationTimestamp: this.expirationTimestamp ? this.expirationTimestamp.getTime() : null,
                rawData: this.dataClone()
            })
        };
    }
    async ensureStorageProxyMuxer() {
        if (this.storageProxy == null) {
            const storageProxyMuxer = await this.frontend.getStorageProxyMuxer(this.backingKey, this.type.referredType);
            this.storageProxy = storageProxyMuxer.getStorageProxy(this.id);
            this.handle = new handle_EntityHandle(this.frontend.generateID(), this.storageProxy, this.frontend.idGenerator, null, true, true, this.id);
        }
    }
    async dereference() {
        external_assert_default()(this.frontend, 'Must have frontend to dereference');
        if (this.entity) {
            return this.entity;
        }
        await this.ensureStorageProxyMuxer();
        this.entity = await this.handle.fetch();
        return this.entity;
    }
    dataClone() {
        return {
            entityStorageKey: this.entityStorageKey,
            id: this.id,
            creationTimestamp: this.creationTimestamp ? this.creationTimestamp.getTime() : null,
            expirationTimestamp: this.expirationTimestamp ? this.expirationTimestamp.getTime() : null
        };
    }
    static extractBackingKey(storageKey) {
        const key = StorageKeyParser.parse(storageKey);
        if (key instanceof reference_mode_storage_key_ReferenceModeStorageKey) {
            return key.backingKey.toString();
        }
        else {
            throw Error('References must reference an entity in ReferenceModeStore');
        }
    }
    // Called by WasmParticle to retrieve the entity for a reference held in a wasm module.
    static async retrieve(frontend, id, storageKey, entityType, particleId) {
        const storageProxyMuxer = await frontend.getStorageProxyMuxer(this.extractBackingKey(storageKey), entityType);
        const proxy = storageProxyMuxer.getStorageProxy(id);
        const handle = new handle_EntityHandle(particleId, proxy, frontend.idGenerator, null, true, true, id);
        return handle.fetch();
    }
}
/** A subclass of Reference that clients can create. */
class reference_ClientReference extends reference_Reference {
    /** Use the newClientReference factory method instead. */
    constructor(entity, frontend) {
        // TODO(shans): start carrying storageKey information around on Entity objects
        super({
            id: entity_Entity.id(entity),
            creationTimestamp: entity_Entity.creationTimestamp(entity),
            expirationTimestamp: entity_Entity.expirationTimestamp(entity),
            entityStorageKey: entity_Entity.storageKey(entity)
        }, new type_ReferenceType(entity_Entity.entityClass(entity).type), frontend);
        this.mode = ReferenceMode.Unstored;
        this.entity = entity;
        this.stored = Promise.resolve();
        this.mode = ReferenceMode.Stored;
    }
    async dereference() {
        if (this.mode === ReferenceMode.Unstored) {
            return null;
        }
        await this.ensureStorageProxyMuxer();
        return super.dereference();
    }
    isIdentified() {
        return entity_Entity.isIdentified(this.entity);
    }
    static newClientReference(frontend) {
        return class extends reference_ClientReference {
            constructor(entity) {
                super(entity, frontend);
            }
        };
    }
}
/**
 * makeReference exists to break a cyclic dependency between handle.ts (both old and NG variants) and reference.ts.
 * Instead of statically depending on reference.ts, handle.ts defines a static makeReference method which is
 * dynamically populated here.
 */
function makeReference(data, type, frontend) {
    return new reference_Reference({
        id: data.id,
        creationTimestamp: data.creationTimestamp ? new Date(data.creationTimestamp) : null,
        expirationTimestamp: data.expirationTimestamp ? new Date(data.expirationTimestamp) : null,
        entityStorageKey: data.entityStorageKey
    }, type, frontend);
}
handle_Handle.makeReference = makeReference;
//# sourceMappingURL=reference.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/particle.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * A basic particle. For particles that provide UI, you may like to
 * instead use DOMParticle.
 */
class particle_Particle {
    constructor() {
        this.relevances = [];
        this._idle = Promise.resolve();
        this._busy = 0;
        // Typescript only sees this.constructor as a Function type.
        // TODO(shans): move spec off the constructor
        this.spec = this.constructor['spec'];
        if (this.spec && this.spec.inputs.length === 0) {
            this.extraData = true;
        }
        this.created = false;
    }
    callOnFirstStart() {
        if (this.created)
            return;
        this.created = true;
        this.onFirstStart();
    }
    /**
     * Called after handles are writable, only on first initialization of particle.
     */
    onFirstStart() { }
    callOnReady() {
        if (!this.created) {
            this.callOnFirstStart();
        }
        this.onReady();
    }
    setCreated() {
        this.created = true;
    }
    /**
     * Called after handles are synced the first time, override to provide initial processing.
     * This will be called after onFirstStart, but will not wait for onFirstStart to finish.
     */
    onReady() { }
    /**
     * This sets the capabilities for this particle.  This can only
     * be called once.
     */
    setCapabilities(capabilities) {
        if (this.capabilities) {
            // Capabilities already set, throw an error.
            throw new Error('capabilities should only be set once');
        }
        this.capabilities = capabilities || {};
    }
    // tslint:disable-next-line: no-any
    async invokeSafely(fun, err) {
        try {
            this.startBusy();
            return fun(this);
        }
        catch (e) {
            err(e);
        }
        finally {
            this.doneBusy();
        }
    }
    async callSetHandles(handles, handleFactories, onException) {
        this.handles = handles;
        this.handleFactories = handleFactories;
        const allHandles = new Map();
        this.handles.forEach((handle, name) => { allHandles.set(name, handle); });
        this.handleFactories.forEach((handleFactory, name) => { allHandles.set(name, handleFactory); });
        await this.invokeSafely(async (p) => p.setHandles(allHandles), onException);
        this._handlesToSync = this._countInputHandles(handles);
        this.onError = onException;
        if (!this._handlesToSync) {
            // onHandleSync is called IFF there are input handles, otherwise we are ready now
            this.callOnReady();
        }
    }
    /**
     * This method is invoked with a handle for each store this particle
     * is registered to interact with, once those handles are ready for
     * interaction. Override the method to register for events from
     * the handles.
     *
     * @param handles a map from handle names to store handles.
     */
    async setHandles(handles) {
    }
    _countInputHandles(handles) {
        let count = 0;
        for (const [name, handle] of handles) {
            if (handle.canRead) {
                count++;
            }
        }
        return count;
    }
    async callOnHandleSync(handle, model, onException) {
        await this.invokeSafely(async (p) => p.onHandleSync(handle, model), onException);
        // once we've synced each readable handle, we are ready to start
        if (--this._handlesToSync === 0) {
            this.callOnReady();
        }
    }
    /**
     * Called for handles that are configured with both keepSynced and notifySync, when they are
     * updated with the full model of their data. This will occur once after setHandles() and any time
     * thereafter if the handle is resynchronized.
     *
     * @param handle The Handle instance that was updated.
     * @param model For Singleton-backed Handles, the Entity data or null if the Singleton is not set.
     *        For Collection-backed Handles, the Array of Entities, which may be empty.
     */
    async onHandleSync(handle, model) {
    }
    // tslint:disable-next-line: no-any
    async callOnHandleUpdate(handle, update, onException) {
        await this.invokeSafely(async (p) => p.onHandleUpdate(handle, update), onException);
    }
    /**
     * Called for handles that are configured with notifyUpdate, when change events are received from
     * the backing store. For handles also configured with keepSynced these events will be correctly
     * ordered, with some potential skips if a desync occurs. For handles not configured with
     * keepSynced, all change events will be passed through as they are received.
     *
     * @param handle The Handle instance that was updated.
     * @param update An object containing one of the following fields:
     *  - data: The full Entity for a Singleton-backed Handle.
     *  - added: An Array of Entities added to a Collection-backed Handle.
     *  - removed: An Array of Entities removed from a Collection-backed Handle.
     *  - originator: whether the update originated from this particle.
     */
    // tslint:disable-next-line: no-any
    async onHandleUpdate(handle, update) {
    }
    async callOnHandleDesync(handle, onException) {
        await this.invokeSafely(async (p) => p.onHandleDesync(handle), onException);
    }
    /**
     * Called for handles that are configured with both keepSynced and notifyDesync, when they are
     * detected as being out-of-date against the backing store. For Singletons, the event that triggers
     * this will also resync the data and thus this call may usually be ignored. For Collections, the
     * underlying proxy will automatically request a full copy of the stored data to resynchronize.
     * onHandleSync will be invoked when that is received.
     *
     * @param handle The Handle instance that was desynchronized.
     */
    async onHandleDesync(handle) {
    }
    async constructInnerArc() {
        if (!this.capabilities.constructInnerArc) {
            throw new Error('This particle is not allowed to construct inner arcs');
        }
        return this.capabilities.constructInnerArc(this);
    }
    get busy() {
        return this._busy > 0;
    }
    get idle() {
        return this._idle;
    }
    set relevance(r) {
        this.relevances.push(r);
    }
    startBusy() {
        if (this._busy === 0) {
            this._idle = new Promise(resolve => this._idleResolver = () => resolve());
        }
        this._busy++;
    }
    doneBusy() {
        this._busy--;
        if (this._busy === 0) {
            this._idleResolver();
        }
    }
    inputs() {
        return this.spec.inputs;
    }
    outputs() {
        return this.spec.outputs;
    }
    /**
     * Request (outerPEC) service invocations.
     */
    async service(request) {
        if (!this.capabilities.serviceRequest) {
            console.warn(`${this.spec.name} has no service support.`);
            return null;
        }
        return new Promise(resolve => {
            this.capabilities.serviceRequest(this, request, response => resolve(response));
        });
    }
    static buildManifest(strings, ...bits) {
        const output = [];
        for (let i = 0; i < bits.length; i++) {
            const str = strings[i];
            const indent = / *$/.exec(str)[0];
            let bitStr;
            if (typeof bits[i] === 'string') {
                bitStr = bits[i];
            }
            else if (!bits[i]) {
                bitStr = '';
            }
            else {
                if (!bits[i].toManifestString) {
                    throw new Error(`${bits[i]} doesn't have toManifestString implementation`);
                }
                bitStr = bits[i].toManifestString();
            }
            bitStr = bitStr.replace(/(\n)/g, `$1${indent}`);
            output.push(str);
            output.push(bitStr);
        }
        if (strings.length > bits.length) {
            output.push(strings[strings.length - 1]);
        }
        return output.join('');
    }
    async setParticleDescription(pattern) {
        return this.setDescriptionPattern('pattern', pattern);
    }
    async setDescriptionPattern(connectionName, pattern) {
        const descriptions = this.handles.get('descriptions');
        if (descriptions) {
            return true;
        }
        throw new Error('A particle needs a description handle to set a decription pattern');
    }
    // Entity functions.
    idFor(entity) {
        return entity_Entity.id(entity);
    }
    dataClone(entity) {
        return entity_Entity.dataClone(entity);
    }
    mutate(entity, mutation) {
        entity_Entity.mutate(entity, mutation);
    }
    // render path
    output(content) {
        const { output } = this.capabilities;
        if (output) {
            output(this, content);
        }
    }
    // abstract
    fireEvent(slotName, event) { }
}
//# sourceMappingURL=particle.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/html.js
/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// no-op html tagged template literal useful for hinting code-tools (e.g. highlighters)
// about html content in strings. e.g. html`<span>this is html</span>`
const html = (strings, ...values) => (strings[0] + values.map((v, i) => v + strings[i + 1]).join('')).trim();
//# sourceMappingURL=html.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/log-node.js
/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// TODO(wkorman): Consider outputting preamble in the specified color via ANSI escape codes.
const logFactory = (preamble, color, log = 'log') => {
    return console[log].bind(console, `(${preamble})`);
};
//# sourceMappingURL=log-node.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/logs-factory.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

const getGlobal = () => {
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw new Error('unable to locate global object');
};
const getLogLevel = () => {
    // acquire global scope
    const g = getGlobal();
    // use specified logLevel otherwise 0
    return ('logLevel' in g) ? g['logLevel'] : 0;
};
// if reporting at all, report log level
if (getLogLevel() > 0) {
    console.log(`log-factory: log level is [${getLogLevel()}]`);
}
const stubFactory = () => () => { };
const logsFactory = (preamble, color = '') => {
    const level = getLogLevel();
    const logs = {};
    ['log', 'warn', 'error', 'group', 'groupCollapsed', 'groupEnd'].
        forEach(log => logs[log] = (level > 0 ? logFactory(preamble, color, log) : stubFactory));
    return logs;
};
//# sourceMappingURL=logs-factory.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/types/internal/schema-from-literal.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */





function fromLiteral(data = { fields: {}, names: [], description: {}, refinement: null }) {
    const fields = {};
    for (const key of Object.keys(data.fields)) {
        fields[key] = fieldFromLiteral(data.fields[key]);
        if (fields[key].refinement) {
            fields[key].refinement = refiner_Refinement.fromLiteral(fields[key].refinement);
        }
    }
    const result = new schema_Schema(data.names, fields);
    result.description = data.description || {};
    if (data.refinement) {
        result.refinement = refiner_Refinement.fromLiteral(data.refinement);
    }
    return result;
}
function fieldFromLiteral(field) {
    const kind = field.kind;
    switch (kind) {
        case SchemaFieldKind.Reference:
            return schema_field_FieldType.create({ ...field, kind, schema: { kind: field.schema.kind, model: type_Type.fromLiteral(field.schema.model) } });
        case SchemaFieldKind.Collection:
        case SchemaFieldKind.OrderedList:
            return schema_field_FieldType.create({ ...field, kind, schema: fieldFromLiteral(field.schema) });
        case SchemaFieldKind.Inline:
            return schema_field_FieldType.create({ ...field, kind, model: type_EntityType.fromLiteral(field.model) });
        default:
            return schema_field_FieldType.create(field);
    }
}
schema_Schema.fromLiteral = fromLiteral;
schema_field_FieldType.fromLiteral = fieldFromLiteral;
//# sourceMappingURL=schema-from-literal.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/types/internal/type-from-literal.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */



function type_from_literal_fromLiteral(literal) {
    switch (literal.tag) {
        case 'Entity':
            return new type_EntityType(schema_Schema.fromLiteral(literal.data));
        case 'TypeVariable':
            return new type_TypeVariable(type_TypeVariableInfo.fromLiteral(literal.data));
        case 'Collection':
            return new type_CollectionType(type_Type.fromLiteral(literal.data));
        case 'BigCollection':
            return new type_BigCollectionType(type_Type.fromLiteral(literal.data));
        case 'Tuple':
            return new type_TupleType(literal.data.map(t => type_Type.fromLiteral(t)));
        case 'Interface':
            return new type_InterfaceType(type_InterfaceInfo.fromLiteral(literal.data));
        case 'Slot':
            return new type_SlotType(SlotInfo.fromLiteral(literal.data));
        case 'Reference':
            return new type_ReferenceType(type_Type.fromLiteral(literal.data));
        case 'Mux':
            return new type_MuxType(type_Type.fromLiteral(literal.data));
        case 'Handle':
            return new type_HandleType();
        case 'Singleton':
            return new type_SingletonType(type_Type.fromLiteral(literal.data));
        default:
            throw new Error(`fromLiteral: unknown type ${literal}`);
    }
}
type_Type.fromLiteral = type_from_literal_fromLiteral;
//# sourceMappingURL=type-from-literal.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/types/internal/interface-info-impl.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */



const handleConnectionFields = ['type', 'name', 'direction'];
const slotFields = ['name', 'direction', 'isRequired', 'isSet'];
function _typeVarOrStringFromLiteral(member) {
    if (typeof member === 'object') {
        return type_Type.fromLiteral(member);
    }
    return member;
}
function _HandleConnectionFromLiteral({ type, name, direction }) {
    return {
        type: type ? type_Type.fromLiteral(type) : undefined,
        name: name ? _typeVarOrStringFromLiteral(name) : undefined,
        direction: direction || 'any'
    };
}
function _SlotFromLiteral({ name, direction, isRequired, isSet }) {
    return {
        name: name ? _typeVarOrStringFromLiteral(name) : undefined,
        direction, isRequired, isSet
    };
}
function _typeToLiteral(member) {
    return member.toLiteral();
}
function _typeVarOrStringToLiteral(member) {
    if (member instanceof type_TypeVariable) {
        return member.toLiteral();
    }
    return member;
}
function _HandleConnectionToLiteral({ type, name, direction }) {
    return {
        type: type && _typeToLiteral(type),
        name: name && _typeVarOrStringToLiteral(name),
        direction
    };
}
function _SlotToLiteral({ name, direction, isRequired, isSet }) {
    return {
        name: name && _typeVarOrStringToLiteral(name),
        direction,
        isRequired,
        isSet
    };
}
class interface_info_impl_InterfaceInfoImpl extends type_InterfaceInfo {
    constructor(name, handleConnections, slots) {
        super(name, handleConnections, slots);
        for (const handleConnection of handleConnections) {
            for (const field of handleConnectionFields) {
                if (type_InterfaceInfo.isTypeVar(handleConnection[field])) {
                    this.typeVars.push({ object: handleConnection, field });
                }
            }
        }
        for (const slot of slots) {
            for (const field of slotFields) {
                if (type_InterfaceInfo.isTypeVar(slot[field])) {
                    this.typeVars.push({ object: slot, field });
                }
            }
        }
    }
    static makeImpl(name, handleConnections, slots) {
        return new interface_info_impl_InterfaceInfoImpl(name, handleConnections, slots);
    }
    static fromLiteral(data) {
        const handleConnections = data.handleConnections.map(_HandleConnectionFromLiteral);
        const slots = data.slots.map(_SlotFromLiteral);
        return new interface_info_impl_InterfaceInfoImpl(data.name, handleConnections, slots);
    }
    toLiteral() {
        const handleConnections = this.handleConnections.map(_HandleConnectionToLiteral);
        const slots = this.slots.map(_SlotToLiteral);
        return { name: this.name, handleConnections, slots };
    }
    get canReadSubset() {
        return this._cloneAndUpdate(typeVar => typeVar.canReadSubset);
    }
    get canWriteSuperset() {
        return this._cloneAndUpdate(typeVar => typeVar.canWriteSuperset);
    }
    isAtLeastAsSpecificAs(other) {
        if (this.handleConnections.length !== other.handleConnections.length ||
            this.slots.length !== other.slots.length) {
            return false;
        }
        // TODO: should probably confirm that handleConnections and slots actually match.
        for (let i = 0; i < this.typeVars.length; i++) {
            const thisTypeVar = this.typeVars[i];
            const otherTypeVar = other.typeVars[i];
            if (!thisTypeVar.object[thisTypeVar.field].isAtLeastAsSpecificAs(otherTypeVar.object[otherTypeVar.field])) {
                return false;
            }
        }
        return true;
    }
    _applyExistenceTypeTest(test) {
        for (const typeRef of this.typeVars) {
            if (test(typeRef.object[typeRef.field])) {
                return true;
            }
        }
        return false;
    }
    _handleConnectionsToManifestString(builder) {
        builder.push(...this.handleConnections.map(h => {
            const parts = [];
            if (h.name) {
                parts.push(`${h.name}:`);
            }
            if (h.direction !== undefined && h.direction !== 'any') {
                parts.push(h.direction);
            }
            parts.push(h.type.toString());
            return parts.join(' ');
        }));
    }
    _slotsToManifestString(builder) {
        // TODO deal with isRequired
        builder.push(...this.slots.map(slot => {
            const nameStr = slot.name ? `${slot.name}: ` : '';
            return `${nameStr}${slot.direction}${slot.isRequired ? '' : '?'} ${slot.isSet ? '[Slot]' : 'Slot'}`;
        }));
    }
    // TODO: Include name as a property of the interface and normalize this to just toString()
    toManifestString(builder = new IndentingStringBuilder()) {
        builder.push(`interface ${this.name}`);
        builder.withIndent(builder => {
            this._handleConnectionsToManifestString(builder);
            this._slotsToManifestString(builder);
        });
        return builder.toString();
    }
    clone(variableMap) {
        const handleConnections = this.handleConnections.map(({ name, direction, type }) => ({ name, direction, type: type ? type.clone(variableMap) : undefined }));
        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));
        return new interface_info_impl_InterfaceInfoImpl(this.name, handleConnections, slots);
    }
    cloneWithResolutions(variableMap) {
        return this._cloneWithResolutions(variableMap);
    }
    _cloneWithResolutions(variableMap) {
        const handleConnections = this.handleConnections.map(({ name, direction, type }) => ({ name, direction, type: type ? type._cloneWithResolutions(variableMap) : undefined }));
        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));
        return new interface_info_impl_InterfaceInfoImpl(this.name, handleConnections, slots);
    }
    canEnsureResolved() {
        for (const typeVar of this.typeVars) {
            if (!typeVar.object[typeVar.field].canEnsureResolved()) {
                return false;
            }
        }
        return true;
    }
    maybeEnsureResolved() {
        for (const typeVar of this.typeVars) {
            let variable = typeVar.object[typeVar.field];
            variable = variable.clone(new Map());
            if (!variable.maybeEnsureResolved())
                return false;
        }
        for (const typeVar of this.typeVars) {
            typeVar.object[typeVar.field].maybeEnsureResolved();
        }
        return true;
    }
    tryMergeTypeVariablesWith(other) {
        // Type variable enabled slot matching will Just Work when we
        // unify slots and handleConnections.
        if (!this._equalItems(other.slots, this.slots, this._equalSlot)) {
            return null;
        }
        if (other.handleConnections.length !== this.handleConnections.length) {
            return null;
        }
        const handleConnections = new Set(this.handleConnections);
        const otherHandleConnections = new Set(other.handleConnections);
        const handleConnectionMap = new Map();
        let sizeCheck = handleConnections.size;
        while (handleConnections.size > 0) {
            const handleConnectionMatches = [...handleConnections.values()].map(handleConnection => ({ handleConnection, match: [...otherHandleConnections.values()].filter(otherHandleConnection => this._equalHandleConnection(handleConnection, otherHandleConnection)) }));
            for (const handleConnectionMatch of handleConnectionMatches) {
                // no match!
                if (handleConnectionMatch.match.length === 0) {
                    return null;
                }
                if (handleConnectionMatch.match.length === 1) {
                    handleConnectionMap.set(handleConnectionMatch.handleConnection, handleConnectionMatch.match[0]);
                    otherHandleConnections.delete(handleConnectionMatch.match[0]);
                    handleConnections.delete(handleConnectionMatch.handleConnection);
                }
            }
            // no progress!
            if (handleConnections.size === sizeCheck) {
                return null;
            }
            sizeCheck = handleConnections.size;
        }
        const handleConnectionList = [];
        for (const handleConnection of this.handleConnections) {
            const otherHandleConnection = handleConnectionMap.get(handleConnection);
            let resultType;
            if (handleConnection.type.hasVariable || otherHandleConnection.type.hasVariable) {
                resultType = type_checker_TypeChecker._tryMergeTypeVariable(handleConnection.type, otherHandleConnection.type);
                if (!resultType) {
                    return null;
                }
            }
            else {
                resultType = handleConnection.type || otherHandleConnection.type;
            }
            handleConnectionList.push({ name: handleConnection.name || otherHandleConnection.name, direction: handleConnection.direction || otherHandleConnection.direction, type: resultType });
        }
        const slots = this.slots.map(({ name, direction, isRequired, isSet }) => ({ name, direction, isRequired, isSet }));
        return new interface_info_impl_InterfaceInfoImpl(this.name, handleConnectionList, slots);
    }
    resolvedType() {
        return this._cloneAndUpdate(typeVar => typeVar.resolvedType());
    }
    equals(other) {
        if (this.handleConnections.length !== other.handleConnections.length) {
            return false;
        }
        // TODO: this isn't quite right as it doesn't deal with duplicates properly
        if (!this._equalItems(other.handleConnections, this.handleConnections, this._equalHandleConnection)) {
            return false;
        }
        if (!this._equalItems(other.slots, this.slots, this._equalSlot)) {
            return false;
        }
        return true;
    }
    _equalHandleConnection(handleConnection, otherHandleConnection) {
        return handleConnection.name === otherHandleConnection.name
            && handleConnection.direction === otherHandleConnection.direction
            && type_checker_TypeChecker.compareTypes({ type: handleConnection.type }, { type: otherHandleConnection.type });
    }
    _equalSlot(slot, otherSlot) {
        return slot.name === otherSlot.name && slot.direction === otherSlot.direction && slot.isRequired === otherSlot.isRequired && slot.isSet === otherSlot.isSet;
    }
    _equalItems(otherItems, items, compareItem) {
        for (const otherItem of otherItems) {
            let exists = false;
            for (const item of items) {
                if (compareItem(item, otherItem)) {
                    exists = true;
                    break;
                }
            }
            if (!exists) {
                return false;
            }
        }
        return true;
    }
    _cloneAndUpdate(update) {
        const copy = this.clone(new Map());
        copy.typeVars.forEach(typeVar => type_InterfaceInfo._updateTypeVar(typeVar, update));
        return copy;
    }
    static handleConnectionsMatch(interfaceHandleConnection, particleHandleConnection) {
        if (type_InterfaceInfo.mustMatch(interfaceHandleConnection.name) &&
            interfaceHandleConnection.name !== particleHandleConnection.name) {
            return false;
        }
        // TODO: FIXME direction subsetting?
        if (type_InterfaceInfo.mustMatch(interfaceHandleConnection.direction)
            && interfaceHandleConnection.direction !== 'any'
            && particleHandleConnection.direction !== 'any'
            && interfaceHandleConnection.direction !== particleHandleConnection.direction) {
            return false;
        }
        if (interfaceHandleConnection.type == undefined) {
            return true;
        }
        const [left, right] = type_Type.unwrapPair(interfaceHandleConnection.type, particleHandleConnection.type);
        if (left instanceof type_TypeVariable) {
            return [{ var: left, value: right, direction: interfaceHandleConnection.direction }];
        }
        else {
            return type_checker_TypeChecker.compareTypes({ type: left }, { type: right });
        }
    }
    static slotsMatch(interfaceSlot, particleSlot) {
        if (type_InterfaceInfo.mustMatch(interfaceSlot.name) &&
            interfaceSlot.name !== particleSlot.name) {
            return false;
        }
        if (type_InterfaceInfo.mustMatch(interfaceSlot.direction) &&
            interfaceSlot.direction !== particleSlot.direction) {
            return false;
        }
        if (type_InterfaceInfo.mustMatch(interfaceSlot.isRequired) &&
            interfaceSlot.isRequired !== particleSlot.isRequired) {
            return false;
        }
        if (type_InterfaceInfo.mustMatch(interfaceSlot.isSet) &&
            interfaceSlot.isSet !== particleSlot.isSet) {
            return false;
        }
        return true;
    }
    particleMatches(particleSpec) {
        const interfaceInfo = this.cloneWithResolutions(new Map());
        return interfaceInfo.restrictType(particleSpec) !== false;
    }
    restrictType(particleSpec) {
        return this._restrictThis(particleSpec);
    }
    _restrictThis(particleSpec) {
        const handleConnectionMatches = this.handleConnections.map(h => particleSpec.handleConnections.map(c => ({ match: c, result: type_InterfaceInfo.handleConnectionsMatch(h, c) }))
            .filter((a) => a.result !== false));
        const particleSlots = [];
        particleSpec.slotConnections.forEach(consumedSlot => {
            particleSlots.push({ name: consumedSlot.name, direction: 'consumes', isRequired: consumedSlot.isRequired, isSet: consumedSlot.isSet });
            consumedSlot.provideSlotConnections.forEach(providedSlot => {
                particleSlots.push({ name: providedSlot.name, direction: 'provides', isRequired: false, isSet: providedSlot.isSet });
            });
        });
        const slotsThatMatch = this.slots.map(slot => particleSlots.filter(particleSlot => type_InterfaceInfo.slotsMatch(slot, particleSlot)));
        const slotMatches = slotsThatMatch.map(matchList => matchList.map(slot => ({ match: slot, result: true })));
        // TODO: this probably doesn't deal with multiple match options.
        function choose(list, exclusions) {
            if (list.length === 0) {
                return [];
            }
            const thisLevel = list.pop();
            for (const connection of thisLevel) {
                if (exclusions.includes(connection.match)) {
                    continue;
                }
                const newExclusions = exclusions.slice();
                newExclusions.push(connection.match);
                const constraints = choose(list, newExclusions);
                if (constraints !== false) {
                    if (typeof connection.result === 'boolean') {
                        return constraints;
                    }
                    return constraints.concat(connection.result);
                }
            }
            return false;
        }
        const handleConnectionOptions = choose(handleConnectionMatches, []);
        const slotOptions = choose(slotMatches, []);
        if (handleConnectionOptions === false || slotOptions === false) {
            return false;
        }
        for (const constraint of handleConnectionOptions) {
            if (!constraint.var.variable.resolution) {
                constraint.var.variable.resolution = constraint.value;
            }
            else if (constraint.var.variable.resolution instanceof type_TypeVariable) {
                // TODO(shans): revisit how this should be done,
                // consider reusing tryMergeTypeVariablesWith(other).
                if (!type_checker_TypeChecker.processTypeList(constraint.var, [{
                        type: constraint.value, direction: constraint.direction
                    }]))
                    return false;
            }
            else {
                if (!type_checker_TypeChecker.compareTypes({ type: constraint.var.variable.resolution }, { type: constraint.value })) {
                    return false;
                }
            }
        }
        return true;
    }
}
type_InterfaceInfo.make = interface_info_impl_InterfaceInfoImpl.makeImpl;
type_InterfaceInfo.handleConnectionsMatch = interface_info_impl_InterfaceInfoImpl.handleConnectionsMatch;
type_InterfaceInfo.fromLiteral = interface_info_impl_InterfaceInfoImpl.fromLiteral;
type_InterfaceInfo.slotsMatch = interface_info_impl_InterfaceInfoImpl.slotsMatch;
//# sourceMappingURL=interface-info-impl.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/types/side-effects.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// To break circular import dependencies we need to use dynamic injection
// of static methods into various classes. This file imports the necessary
// internals to do this, and should only be used by platform/loader-base.ts.



//# sourceMappingURL=side-effects.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/handle-constructors.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */



// We inject SingletonHandle and CollectionHandle constructors into the
// corresponding types to avoid type.js depending on storage/handle.js.
type_SingletonType.handleClass = handle_SingletonHandle;
type_CollectionType.handleClass = handle_CollectionHandle;
type_MuxType.handleClass = entity_handle_factory_EntityHandleFactory;
//# sourceMappingURL=handle-constructors.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/active-store.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


// A representation of an active store. Subclasses of this class provide specific
// behaviour as controlled by the provided StorageMode.
class active_store_ActiveStore {
    constructor(options) {
        this.storageKey = options.storageKey;
        this.type = options.type;
        this.storeInfo = options.storeInfo;
    }
    get mode() { return this.storeInfo.mode; }
    async idle() {
        return Promise.resolve();
    }
    async cloneFrom(activeStore) {
        // TODO(shans): work out what ID to use for messages that aren't from an established
        // channel, like these.
        external_assert_default()(this.mode === activeStore.mode);
        await this.onProxyMessage({
            type: ProxyMessageType.ModelUpdate,
            model: await activeStore.serializeContents(),
            id: 0
        });
    }
    async modelForSynchronization() {
        return this.serializeContents();
    }
}
active_store_ActiveStore.constructors = null;
//# sourceMappingURL=active-store.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/drivers/driver-factory.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class DriverFactory {
    static async driverInstance(storageKey, exists) {
        for (const provider of this.providers) {
            if (provider.willSupport(storageKey)) {
                return provider.driver(storageKey, exists);
            }
        }
        return null;
    }
    static register(storageDriverProvider) {
        this.providers.add(storageDriverProvider);
    }
    static unregister(storageDriverProvider) {
        this.providers.delete(storageDriverProvider);
    }
    static willSupport(storageKey) {
        for (const provider of this.providers) {
            if (provider.willSupport(storageKey)) {
                return true;
            }
        }
        return false;
    }
}
DriverFactory.providers = new Set();
//# sourceMappingURL=driver-factory.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/direct-store.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */





var DirectStoreState;
(function (DirectStoreState) {
    DirectStoreState["Idle"] = "Idle";
    DirectStoreState["AwaitingResponse"] = "AwaitingResponse";
    DirectStoreState["AwaitingResponseDirty"] = "AwaitingResponseDirty";
    DirectStoreState["AwaitingDriverModel"] = "AwaitingDriverModel";
})(DirectStoreState || (DirectStoreState = {}));
class direct_store_DirectStore extends active_store_ActiveStore {
    /*
     * This class should only ever be constructed via the static construct method
     */
    constructor(options) {
        super(options);
        this.callbacks = new Map();
        this.nextCallbackID = 1;
        this.version = 0;
        this.pendingException = null;
        this.pendingResolves = [];
        this.pendingRejects = [];
        this.pendingDriverModels = [];
        this.state = DirectStoreState.Idle;
    }
    async serializeContents() {
        await this.idle();
        return this.localModel.getData();
    }
    async idle() {
        if (this.pendingException) {
            return Promise.reject(this.pendingException);
        }
        if (this.state === DirectStoreState.Idle) {
            return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
            this.pendingResolves.push(resolve);
            this.pendingRejects.push(reject);
        });
    }
    get versionToken() {
        return this.driver.getToken();
    }
    setState(state) {
        this.state = state;
        if (state === DirectStoreState.Idle) {
            // If we are already idle, this won't notify external parties.
            this.notifyIdle();
        }
    }
    notifyIdle() {
        if (this.pendingException) {
            // this is termination.
            this.pendingRejects.forEach(reject => reject(this.pendingException));
        }
        else {
            this.pendingResolves.forEach(resolve => resolve());
            this.pendingResolves = [];
        }
    }
    static async construct(options) {
        const me = new direct_store_DirectStore(options);
        me.localModel = new (options.type.crdtInstanceConstructor())();
        me.driver = await DriverFactory.driverInstance(options.storageKey, options.exists);
        if (me.driver == null) {
            throw new CRDTError(`No driver exists to support storage key ${options.storageKey}`);
        }
        me.driver.registerReceiver(me.onReceive.bind(me), me.storeInfo.versionToken);
        return me;
    }
    // The driver will invoke this method when it has an updated remote model
    async onReceive(model, version) {
        this.pendingDriverModels.push({ model, version });
        if (this.state === DirectStoreState.AwaitingResponse || this.state === DirectStoreState.AwaitingResponseDirty) {
            return;
        }
        this.applyPendingDriverModels();
    }
    deliverCallbacks(thisChange, messageFromDriver, channel) {
        if (thisChange.changeType === ChangeType.Operations && thisChange.operations.length > 0) {
            this.callbacks.forEach((cb, id) => {
                if (messageFromDriver || channel !== id) {
                    void cb({ type: ProxyMessageType.Operations, operations: thisChange.operations, id });
                }
            });
        }
        else if (thisChange.changeType === ChangeType.Model) {
            this.callbacks.forEach((cb, id) => {
                if (messageFromDriver || channel !== id) {
                    void cb({ type: ProxyMessageType.ModelUpdate, model: thisChange.modelPostChange, id });
                }
            });
        }
    }
    async processModelChange(modelChange, otherChange, version, channel) {
        this.deliverCallbacks(modelChange, /* messageFromDriver= */ false, channel);
        await this.updateStateAndAct(this.noDriverSideChanges(modelChange, otherChange, false), version, false);
    }
    // This function implements a state machine that controls when data is sent to the driver.
    // You can see the state machine in all its glory at the following URL:
    //
    // https://github.com/PolymerLabs/arcs/wiki/Store-object-State-Machine
    //
    async updateStateAndAct(noDriverSideChanges, version, messageFromDriver) {
        // Don't send to the driver if we're already in sync and there are no driver-side changes.
        if (noDriverSideChanges) {
            // Need to record the driver version so that we can continue to send.
            if (messageFromDriver) {
                this.setState(DirectStoreState.Idle);
            }
            this.version = version;
            return;
        }
        switch (this.state) {
            case DirectStoreState.AwaitingDriverModel:
                if (!messageFromDriver) {
                    return;
                }
            /* falls through */
            case DirectStoreState.Idle:
                // This loop implements sending -> AwaitingResponse -> AwaitingResponseDirty -> sending.
                // Breakouts happen if:
                //  (1) a response arrives while still AwaitingResponse. This returns the store to Idle.
                //  (2) a negative response arrives. This means we're now waiting for driver models
                //      (AwaitingDriverModel). Note that in this case we are likely to end up back in
                //      this loop when a driver model arrives.
                while (true) {
                    this.setState(DirectStoreState.AwaitingResponse);
                    // Work around a typescript compiler bug. Apparently typescript won't guarantee that
                    // a Map key you've just set will exist, but is happy to assure you that a private
                    // member variable couldn't possibly change in any function outside the local scope
                    // when within a switch statement.
                    this.state = DirectStoreState.AwaitingResponse;
                    this.version = ++version;
                    const response = await this.driver.send(this.localModel.getData(), version);
                    if (response) {
                        if (this.state === DirectStoreState.AwaitingResponse) {
                            this.setState(DirectStoreState.Idle);
                            this.applyPendingDriverModels();
                            break;
                        }
                        if (this.state !== DirectStoreState.AwaitingResponseDirty) {
                            // This shouldn't be possible as only a 'nack' should put us into
                            // AwaitingDriverModel, and only the above code should put us back
                            // into Idle.
                            throw new Error('reached impossible state in store state machine');
                        }
                        // fallthrough to re-execute the loop.
                    }
                    else {
                        this.setState(DirectStoreState.AwaitingDriverModel);
                        this.applyPendingDriverModels();
                        break;
                    }
                }
                return;
            case DirectStoreState.AwaitingResponse:
                this.setState(DirectStoreState.AwaitingResponseDirty);
                return;
            case DirectStoreState.AwaitingResponseDirty:
                return;
            default:
                throw new Error('reached impossible default state in switch statement');
        }
    }
    applyPendingDriverModels() {
        if (this.pendingDriverModels.length > 0) {
            const models = this.pendingDriverModels;
            this.pendingDriverModels = [];
            let noDriverSideChanges = true;
            let theVersion = 0;
            for (const { model, version } of models) {
                try {
                    const { modelChange, otherChange } = this.localModel.merge(model);
                    this.deliverCallbacks(modelChange, /* messageFromDriver= */ true, 0);
                    noDriverSideChanges = noDriverSideChanges && this.noDriverSideChanges(modelChange, otherChange, true);
                    theVersion = version;
                }
                catch (e) {
                    this.pendingException = e;
                    this.notifyIdle();
                    return;
                }
            }
            void this.updateStateAndAct(noDriverSideChanges, theVersion, true);
        }
    }
    // Note that driver-side changes are stored in 'otherChange' when the merged operations/model is sent
    // from the driver, and 'thisChange' when the merged operations/model is sent from a storageProxy.
    // In the former case, we want to look at what has changed between what the driver sent us and what
    // we now have. In the latter, the driver is only as up-to-date as our local model before we've
    // applied the operations.
    noDriverSideChanges(thisChange, otherChange, messageFromDriver) {
        if (messageFromDriver) {
            return otherChange.changeType === ChangeType.Operations && otherChange.operations.length === 0;
        }
        else {
            return thisChange.changeType === ChangeType.Operations && thisChange.operations.length === 0;
        }
    }
    // Operation or model updates from connected StorageProxies will arrive here.
    // Additionally, StorageProxy objects may request a SyncRequest, which will
    // result in an up-to-date model being sent back to that StorageProxy.
    // a return value of true implies that the message was accepted, a
    // return value of false requires that the proxy send a model sync
    async onProxyMessage(message) {
        if (typeof message.id !== 'number') {
            throw new Error('Direct Store received message from StorageProxy without an ID');
        }
        if (this.pendingException) {
            throw this.pendingException;
        }
        switch (message.type) {
            case ProxyMessageType.SyncRequest:
                await this.callbacks.get(message.id)({ type: ProxyMessageType.ModelUpdate, model: this.localModel.getData(), id: message.id });
                return;
            case ProxyMessageType.Operations: {
                for (const operation of message.operations) {
                    if (!this.localModel.applyOperation(operation)) {
                        await this.callbacks.get(message.id)({ type: ProxyMessageType.SyncRequest, id: message.id });
                        return;
                    }
                }
                const change = { changeType: ChangeType.Operations, operations: message.operations };
                // to make tsetse checks happy
                noAwait(this.processModelChange(change, null, this.version, message.id));
                return;
            }
            case ProxyMessageType.ModelUpdate: {
                const { modelChange, otherChange } = this.localModel.merge(message.model);
                // to make tsetse checks happy
                noAwait(this.processModelChange(modelChange, otherChange, this.version, message.id));
                return;
            }
            default:
                throw new CRDTError('Invalid operation provided to onProxyMessage');
        }
    }
    on(callback) {
        const id = this.nextCallbackID++;
        this.callbacks.set(id, callback);
        if (this.version > 0) {
            noAwait(callback({ type: ProxyMessageType.ModelUpdate, model: this.localModel.getData(), id }));
        }
        return id;
    }
    off(callback) {
        this.callbacks.delete(callback);
    }
    reportExceptionInHost(exception) {
        this.pendingException = exception;
        this.notifyIdle();
    }
}
//# sourceMappingURL=direct-store.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/direct-store-muxer.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */






/**
 * A store that allows multiple CRDT models to be stored as sub-keys of a single storageKey location.
 */
class direct_store_muxer_DirectStoreMuxer extends active_store_ActiveStore {
    constructor(options) {
        super(options);
        this.stores = {};
        this.callbacks = new Map();
        this.callbackIdToMuxIdMap = new Map();
        this.nextCallbackId = 1;
        this.storageKey = options.storageKey;
        this.options = options;
    }
    on(callback) {
        this.callbacks.set(this.nextCallbackId, callback);
        this.callbackIdToMuxIdMap.set(this.nextCallbackId, new Set());
        return this.nextCallbackId++;
    }
    off(callback) {
        this.callbacks.delete(callback);
        for (const muxId of this.callbackIdToMuxIdMap[callback]) {
            const storeRecord = this.stores[muxId];
            if (storeRecord.type === 'record') {
                storeRecord.store.off(storeRecord.idMap.getR(callback));
                storeRecord.idMap.deleteL(callback);
            }
        }
    }
    getLocalModel(muxId, id) {
        const store = this.stores[muxId];
        if (store == null) {
            this.stores[muxId] = { type: 'pending', promise: this.setupStore(muxId, id) };
            return null;
        }
        if (store.type === 'pending') {
            return null;
        }
        else {
            if (!store.idMap.hasL(id)) {
                store.idMap.set(id, this.createListenerForStore(store.store, muxId, id));
                this.callbackIdToMuxIdMap.get(id).add(muxId);
            }
            return store.store.localModel;
        }
    }
    async setupStore(muxId, callbackId) {
        const store = await direct_store_DirectStore.construct({ ...this.options, storageKey: this.storageKey.childKeyForBackingElement(muxId) });
        const record = { store, idMap: new BiMap(), type: 'record' };
        // Creating a listener for the store may trigger an event; this will be delivered upstream and may in turn trigger
        // a request for the localModel. It's important that there's a recorded store in place for the local model to be
        // retrieved from, even though we don't have the correct id until store.on returns.
        this.stores[muxId] = record;
        const storeCallbackId = await this.createListenerForStore(store, muxId, callbackId);
        record.idMap.set(callbackId, storeCallbackId);
        this.callbackIdToMuxIdMap.get(callbackId).add(muxId);
        return record;
    }
    async createListenerForStore(store, muxId, id) {
        const dsm = this;
        const callbackForStore = async (msg) => {
            msg.muxId = muxId;
            const callback = dsm.callbacks.get(id);
            noAwait(callback({ ...msg, id }));
        };
        const storeCallbackId = await store.on(callbackForStore);
        return storeCallbackId;
    }
    async onProxyMessage(message) {
        external_assert_default()(message.muxId != null);
        let storeRecord = this.stores[message.muxId];
        if (storeRecord == null) {
            storeRecord = { type: 'pending', promise: this.setupStore(message.muxId, message.id) };
            this.stores[message.muxId] = storeRecord;
        }
        if (storeRecord.type === 'pending') {
            storeRecord = await storeRecord.promise;
        }
        // check if there's a channel for message.id
        if (!storeRecord.idMap.hasL(message.id)) {
            const storeCallbackId = await this.createListenerForStore(storeRecord.store, message.muxId, message.id);
            storeRecord.idMap.set(message.id, storeCallbackId);
            this.callbackIdToMuxIdMap.get(message.id).add(message.muxId);
        }
        const { store, idMap } = storeRecord;
        await store.onProxyMessage({ ...message, id: await idMap.getL(message.id) });
    }
    static async construct(options) {
        return new direct_store_muxer_DirectStoreMuxer(options);
    }
    async idle() {
        const stores = [];
        for (const store of Object.values(this.stores)) {
            if (store.type === 'record') {
                stores.push(store.store);
            }
        }
        await Promise.all(stores.map(store => store.idle()));
    }
    reportExceptionInHost(exception) {
        reportSystemException(null, exception);
    }
    async cloneFrom(store) {
        external_assert_default()(store instanceof direct_store_muxer_DirectStoreMuxer);
        const dsm = store;
        for (const muxId of Object.keys(dsm.stores)) {
            await this.onProxyMessage({
                type: ProxyMessageType.ModelUpdate,
                model: dsm.getLocalModel(muxId, 0).getData(),
                id: 0
            });
        }
    }
    async serializeContents() {
        throw new Error('DirectStoreMuxer contents can not be serialized.');
    }
}
//# sourceMappingURL=direct-store-muxer.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/reference-mode-store.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */







class reference_mode_store_ReferenceCollection extends crdt_collection_CRDTCollection {
}
class reference_mode_store_ReferenceSingleton extends crdt_singleton_CRDTSingleton {
}
var ReferenceModeUpdateSource;
(function (ReferenceModeUpdateSource) {
    ReferenceModeUpdateSource[ReferenceModeUpdateSource["Container"] = 0] = "Container";
    ReferenceModeUpdateSource[ReferenceModeUpdateSource["BackingStore"] = 1] = "BackingStore";
    ReferenceModeUpdateSource[ReferenceModeUpdateSource["StorageProxy"] = 2] = "StorageProxy";
})(ReferenceModeUpdateSource || (ReferenceModeUpdateSource = {}));
/**
 * ReferenceModeStores adapt between a collection (CRDTCollection or CRDTSingleton) of entities from the perspective of their public API,
 * and a collection of references + a backing store of entity CRDTs from an internal storage perspective.
 *
 * ReferenceModeStores maintain a queue of incoming updates (the receiveQueue) and process them one at a time. When possible, the results
 * of this processing are immediately sent upwards (to connected StorageProxies) and downwards (to storage). However, there are a few
 * caveats:
 * - incoming operations and models from StorageProxies may require several writes to storage - one for each modified entity, and one
 *   to the container store. These are processed serially, so that a container doesn't get updated if backing store modifications fail.
 * - updates from the container store need to be blocked on ensuring the required data is also available in the backing store.
 *   The holdQueue ensures that these blocks are tracked and processed appropriately.
 * - updates should always be sent in order, so a blocked send should block subsequent sends too. The pendingSends queue ensures that all
 *   outgoing updates are sent in the correct order.
 *
 */
class reference_mode_store_ReferenceModeStore extends active_store_ActiveStore {
    constructor() {
        super(...arguments);
        /*
         * Registered callbacks to Storage Proxies
         */
        this.callbacks = new Map();
        this.nextCallbackID = 1;
        /*
         * A randomly generated key that is used for synthesized entity CRDT modifications.
         *
         * When entity updates are received by instances of ReferenceModeStore, they're non-CRDT blobs of data.
         * The ReferenceModeStore needs to convert them to tracked CRDTs, which means it needs to synthesize
         * updates. This key is used as the unique write key for those updates.
         */
        this.crdtKey = (Math.random() * Math.pow(2, 64)) + '';
        /*
         * The versions dictionary tracks the maximum write version for each entity ID, to ensure synthesized
         * updates can be correctly applied downstream.
         */
        this.versions = {};
        /*
         * A queue of incoming updates from the backing store, container store, and connected proxies.
         * These are dealt with atomically, to avoid transient states where an operation has only been partially
         * processed (e.g. backing written but container update not written).
         */
        this.receiveQueue = [];
        /*
         * A queue of send Runnables. Some of these may be blocked on entities becoming available in the
         * backing store.
         */
        this.pendingSends = [];
        /*
         * A queue of blocks to the pendingSends queue.
         */
        this.holdQueue = new HoldQueue();
        /*
         * An incrementing ID to uniquely identify each blocked send.
         */
        this.blockCounter = 0;
    }
    static async construct(options) {
        const result = new reference_mode_store_ReferenceModeStore(options);
        const { storageKey, type } = options;
        result.backingStore = await direct_store_muxer_DirectStoreMuxer.construct({
            storageKey: storageKey.backingKey,
            type: new type_MuxType(type.getContainedType()),
            exists: options.exists,
            storeInfo: options.storeInfo,
        });
        let refType;
        if (type.isCollectionType()) {
            refType = new type_CollectionType(new type_ReferenceType(type.getContainedType()));
        }
        else {
            refType = new type_SingletonType(new type_ReferenceType(type.getContainedType()));
        }
        result.containerStore = await direct_store_DirectStore.construct({
            storageKey: storageKey.storageKey,
            type: refType,
            exists: options.exists,
            storeInfo: options.storeInfo,
        });
        result.registerStoreCallbacks();
        return result;
    }
    async serializeContents() {
        const data = await this.containerStore.serializeContents();
        const { pendingIds, model } = this.constructPendingIdsAndModel(data);
        if (pendingIds.length === 0) {
            return model();
        }
        return new Promise((resolve, reject) => {
            this.enqueueBlockingSend(pendingIds, () => resolve(model()));
        });
    }
    reportExceptionInHost(exception) {
        // TODO(shans): Figure out idle / exception store for reference mode stores.
        throw new Error(exception.message);
    }
    // For referenceMode stores, the version tracked is just the version
    // of the container, because any updates to Entities must necessarily be
    // stored as version updates to the references in the container.
    get versionToken() {
        return this.containerStore.versionToken;
    }
    on(callback) {
        const id = this.nextCallbackID++;
        this.callbacks.set(id, callback);
        return id;
    }
    off(callback) {
        this.callbacks.delete(callback);
    }
    registerStoreCallbacks() {
        this.backingStoreId = this.backingStore.on(this.onBackingStore.bind(this));
        this.containerStoreId = this.containerStore.on(this.onContainerStore.bind(this));
    }
    /**
     * Messages are enqueued onto an object-wide queue and processed in order.
     * Internally, each handler (handleContainerStore, handleBackingStore, handleProxyMessage)
     * should not return until the response relevant to the message has been received.
     *
     * When handling proxy messages, this implies 2 rounds of update - first the backing
     * store needs to be updated, and once that has completed then the container store needs
     * to be updated.
     *
     * Note that though there's no explicit return value from processing these messages,
     * returning implies that they've taken local effect.
     */
    async onContainerStore(message) {
        return this.enqueue({ from: ReferenceModeUpdateSource.Container, message });
    }
    async onBackingStore(message) {
        return this.enqueue({ from: ReferenceModeUpdateSource.BackingStore, message });
    }
    async onProxyMessage(message) {
        return this.enqueue({ from: ReferenceModeUpdateSource.StorageProxy, message });
    }
    /**
     * enqueue an incoming update onto the object-wide queue and return a promise that will be resolved
     * when the update is processed.
     */
    async enqueue(entry) {
        return new Promise((resolve, reject) => {
            const startProcessing = this.receiveQueue.length === 0;
            this.receiveQueue.push({ ...entry, promise: resolve });
            if (startProcessing) {
                void this.processQueue();
            }
        });
    }
    async processQueue() {
        while (this.receiveQueue.length > 0) {
            // ths.receiveQueue.length === 0 is used as a signal to start processing (see enqueue). As
            // this method is asynchronous, we can't remove the current element until it's processed
            // or we'll potentially get duplicate calls to processQueue.
            const nextMessage = this.receiveQueue[0];
            switch (nextMessage.from) {
                case ReferenceModeUpdateSource.StorageProxy:
                    await this.handleProxyMessage(nextMessage.message);
                    break;
                case ReferenceModeUpdateSource.BackingStore:
                    await this.handleBackingStore(nextMessage.message);
                    break;
                case ReferenceModeUpdateSource.Container:
                    await this.handleContainerStore(nextMessage.message);
                    break;
                default:
                    throw new Error('invalid message type');
            }
            nextMessage.promise();
            this.receiveQueue.shift();
        }
    }
    /**
     * Handle an update from the container store.
     *
     * Operations and Models either enqueue an immediate send (if all referenced entities
     * are available in the backing store) or enqueue a blocked send (if some referenced
     * entities are not yet present or are at the incorrect version).
     *
     * Sync requests are propagated upwards to the storage proxy.
     */
    async handleContainerStore(message) {
        switch (message.type) {
            case ProxyMessageType.Operations: {
                for (const operation of message.operations) {
                    const reference = this.operationElement(operation);
                    let getEntity;
                    if (reference) {
                        const entityCRDT = this.backingStore.getLocalModel(reference.id, this.backingStoreId);
                        if (!entityCRDT) {
                            this.enqueueBlockingSend([reference], () => {
                                const entityCRDT = this.backingStore.getLocalModel(reference.id, this.backingStoreId);
                                const getEntity = () => this.entityFromModel(entityCRDT.getData(), reference.id);
                                const upstreamOp = this.updateOp(operation, getEntity);
                                void this.send({ type: ProxyMessageType.Operations, operations: [upstreamOp] });
                            });
                            break;
                        }
                        getEntity = () => this.entityFromModel(entityCRDT.getData(), reference.id);
                    }
                    else {
                        getEntity = () => null;
                    }
                    this.enqueueSend(() => {
                        const upstreamOp = this.updateOp(operation, getEntity);
                        void this.send({ type: ProxyMessageType.Operations, operations: [upstreamOp] });
                    });
                }
                break;
            }
            case ProxyMessageType.ModelUpdate: {
                const data = message.model;
                const { pendingIds, model } = this.constructPendingIdsAndModel(data);
                const send = () => void this.send({ type: ProxyMessageType.ModelUpdate, model: model() });
                if (pendingIds.length === 0) {
                    this.enqueueSend(send);
                }
                else {
                    this.enqueueBlockingSend(pendingIds, send);
                }
                break;
            }
            case ProxyMessageType.SyncRequest: {
                this.enqueueSend(() => {
                    void this.send({ type: ProxyMessageType.SyncRequest });
                });
                break;
            }
            default: {
                throw new Error('Unexpected ProxyMessageType');
            }
        }
        return true;
    }
    /**
     * Handle an update from the backing store.
     *
     * Model and Operation updates are routed directly to the holdQueue, where they may unblock
     * pending sends but will not have any other action.
     *
     * Syncs should never occur as operation/model updates to the backing store are generated
     * by this ReferenceModeStore object and hence should never be out-of-order.
     */
    async handleBackingStore(message) {
        switch (message.type) {
            case ProxyMessageType.ModelUpdate:
                this.holdQueue.processID(message.muxId, message.model.version);
                break;
            case ProxyMessageType.Operations:
                this.holdQueue.processID(message.muxId, message.operations[message.operations.length - 1].versionMap);
                break;
            case ProxyMessageType.SyncRequest:
                throw new Error('Unexpected SyncRequest from backing store');
            default:
                throw new Error('Unexpected ProxyMessageType');
        }
        return true;
    }
    /**
     * Handle an update from an upstream StorageProxy.
     *
     * Model and Operation updates apply first to the backing store, then to the container store.
     * Backing store updates should never fail as updates are locally generated.
     * For Operations:
     * - If the container store update succeeds, then the update is mirrored to non-sending StorageProxies.
     * - If the container store update fails, then a `false` return value ensures that the upstream proxy
     *   will request a sync.
     * Model updates should not fail.
     *
     * Sync requests are handled by directly constructing and sending a model
     */
    async handleProxyMessage(message) {
        switch (message.type) {
            case ProxyMessageType.Operations: {
                const operations = message.operations;
                for (const operation of operations) {
                    const entity = this.operationElement(operation);
                    let reference = null;
                    if (entity) {
                        if (operation.type === CollectionOpTypes.Remove) {
                            // If an entity is removed from a collection, we also clear the backing store.
                            await this.clearEntityInBackingStore(entity);
                        }
                        else {
                            await this.updateBackingStore(entity);
                        }
                        const version = this.backingStore.getLocalModel(entity.id, this.backingStoreId).getData().version;
                        reference = { id: entity.id, storageKey: this.backingStore.storageKey, version };
                    }
                    const containerMessage = this.updateOp(operation, () => reference);
                    await this.containerStore.onProxyMessage({ type: ProxyMessageType.Operations, operations: [containerMessage], id: this.containerStoreId });
                    this.enqueueSend(() => void this.sendExcept(message, message.id));
                }
                break;
            }
            case ProxyMessageType.ModelUpdate: {
                const { version, values } = message.model;
                const newValues = {};
                const backingStoreReceipts = [];
                Object.entries(values).forEach(([id, { value, version }]) => {
                    backingStoreReceipts.push(this.updateBackingStore(value).then(_ => {
                        const entityVersion = this.backingStore.getLocalModel(id, this.backingStoreId).getData().version;
                        newValues[id] = { value: { id, storageKey: this.backingStore.storageKey, version: entityVersion }, version };
                    }));
                });
                await Promise.all(backingStoreReceipts);
                const model = { version, values: newValues };
                await this.containerStore.onProxyMessage({ type: ProxyMessageType.ModelUpdate, model, id: this.containerStoreId });
                this.enqueueSend(() => this.sendExcept(message, message.id));
                break;
            }
            case ProxyMessageType.SyncRequest: {
                const { pendingIds, model } = this.constructPendingIdsAndModel(this.containerStore.localModel.getData());
                const send = () => void this.callbacks.get(message.id)({ type: ProxyMessageType.ModelUpdate, model: model(), id: message.id });
                if (pendingIds.length === 0) {
                    this.enqueueSend(send);
                }
                else {
                    this.enqueueBlockingSend(pendingIds, send);
                }
                break;
            }
            default:
                throw new Error('Unexpected ProxyMessageType');
        }
        return true;
    }
    /**
     * Enqueues a sending function on the send queue. If the send queue is empty then
     * the function is immediately invoked.
     */
    enqueueSend(runnable) {
        if (this.pendingSends.length === 0) {
            runnable();
        }
        else {
            this.pendingSends.push({ fn: runnable });
        }
    }
    /**
     * Enqueues a send function on the send queue, deferring execution until the
     * provided id list is available in the backing store.
     */
    enqueueBlockingSend(entities, runnable) {
        const block = (this.blockCounter++) + '';
        this.pendingSends.push({ fn: runnable, block });
        this.holdQueue.enqueue(entities, () => this.processPendingSends(block));
    }
    /**
     * Process any sends in the pending send queue, including sends blocked on the
     * provided block. This should only be called by the holdQueue.
     */
    processPendingSends(block) {
        while (this.pendingSends.length > 0) {
            if (this.pendingSends[0].block == null || this.pendingSends[0].block === block) {
                const send = this.pendingSends.shift();
                send.fn();
            }
            else {
                return;
            }
        }
    }
    addFieldToValueList(list, value, version) {
        // construct id for primitive fields
        if (value['id'] === undefined) {
            value = { id: value.toString(), value };
        }
        list[value['id']] = { value, version };
    }
    /**
     * Convert the provided entity to a CRDT Model of the entity. This requires synthesizing
     * a version map for the CRDT model, which is also provided as an output.
     */
    entityToModel(entity) {
        if (this.versions[entity.id] == undefined) {
            this.versions[entity.id] = {};
        }
        const entityVersion = this.versions[entity.id];
        const model = this.newBackingInstance().getData();
        let maxVersion = 0;
        for (const key of Object.keys(entity.rawData)) {
            if (entityVersion[key] == undefined) {
                entityVersion[key] = 0;
            }
            const version = { [this.crdtKey]: ++entityVersion[key] };
            maxVersion = Math.max(maxVersion, entityVersion[key]);
            if (model.singletons[key]) {
                model.singletons[key].values = {};
                this.addFieldToValueList(model.singletons[key].values, entity.rawData[key], version);
                model.singletons[key].version = version;
            }
            else if (model.collections[key]) {
                model.collections[key].values = {};
                for (const value of entity.rawData[key]) {
                    this.addFieldToValueList(model.collections[key].values, value, version);
                }
                model.collections[key].version = version;
            }
            else {
                throw new Error(`key ${key} not found for model ${model}`);
            }
        }
        model.version = { [this.crdtKey]: maxVersion };
        return model;
    }
    /**
     * Convert the provided CRDT model into an entity.
     */
    entityFromModel(model, id) {
        const entity = { id, rawData: {} };
        const singletons = {};
        for (const field of Object.keys(model.singletons)) {
            singletons[field] = new crdt_singleton_CRDTSingleton();
        }
        const collections = {};
        for (const field of Object.keys(model.collections)) {
            collections[field] = new crdt_collection_CRDTCollection();
        }
        const entityCRDT = new crdt_entity_CRDTEntity(singletons, collections);
        entityCRDT.merge(model);
        const data = entityCRDT.getParticleView();
        for (const [key, value] of Object.entries(data.singletons)) {
            // For primitives, only the value property of the Referenceable should be included in rawData
            if (value != null && value['value'] !== undefined) {
                entity.rawData[key] = value['value'];
            }
            else {
                entity.rawData[key] = value;
            }
        }
        for (const [key, value] of Object.entries(data.collections)) {
            if (value != null && value['value'] !== undefined) {
                entity.rawData[key] = value['value'];
            }
            else {
                entity.rawData[key] = value;
            }
        }
        return entity;
    }
    cloneMap(map) {
        const result = {};
        Object.entries(map).forEach(([key, value]) => result[key] = value);
        return result;
    }
    /**
     * Returns a function that can construct a CRDTModel of a Container of Entities based off the
     * provided Container of References. Any referenced IDs that are not yet available in the backing
     * store are returned in the pendingIds list. The returned function should not be invoked until
     * all references in pendingIds have valid backing in the backing store.
     */
    constructPendingIdsAndModel(data) {
        const pendingIds = [];
        for (const id of Object.keys(data.values)) {
            const version = data.values[id].value.version;
            if (Object.keys(version).length === 0) {
                // This object is requested at an empty version, which means that it's new and can be directly constructed
                // rather than waiting for an update.
                continue;
            }
            const backingModel = this.backingStore.getLocalModel(id, this.backingStoreId);
            if ((backingModel == null) || !versionIsLarger(backingModel.getData().version, version)) {
                pendingIds.push({ id, version });
            }
        }
        const fn = () => {
            const model = { values: {}, version: this.cloneMap(data.version) };
            for (const id of Object.keys(data.values)) {
                const version = data.values[id].value.version;
                const entity = Object.keys(version).length === 0 ? this.newBackingInstance() : this.backingStore.getLocalModel(id, this.backingStoreId);
                model.values[id] = { value: this.entityFromModel(entity.getData(), id), version: data.values[id].version };
            }
            return model;
        };
        return { pendingIds, model: fn };
    }
    /**
     * Add appropriate ids and send the provided message on all registered StorageProxy callbacks.
     */
    async send(message) {
        for (const key of this.callbacks.keys()) {
            noAwait(this.callbacks.get(key)({ ...message, id: key }));
        }
    }
    /**
     * Add appropriate ids and send the provided message on all registered StorageProxy callbacks,
     * except for the callback identified by the provided callback ID.
     */
    async sendExcept(message, notTo) {
        for (const key of this.callbacks.keys()) {
            if (key === notTo) {
                continue;
            }
            noAwait(this.callbacks.get(key)({ ...message, id: key }));
        }
    }
    /**
     * Write the provided entity to the backing store.
     */
    async updateBackingStore(entity) {
        const model = this.entityToModel(entity);
        return this.backingStore.onProxyMessage({ type: ProxyMessageType.ModelUpdate, model, id: this.backingStoreId, muxId: entity.id });
    }
    /* Clear the entity in the backing store. */
    async clearEntityInBackingStore(entity) {
        const model = this.entityToModel(entity);
        const op = { type: EntityOpTypes.ClearAll, actor: this.crdtKey, versionMap: model.version };
        return this.backingStore.onProxyMessage({ type: ProxyMessageType.Operations, operations: [op], id: this.backingStoreId, muxId: entity.id });
    }
    newBackingInstance() {
        const instanceConstructor = this.type.getContainedType().crdtInstanceConstructor();
        return new instanceConstructor();
    }
    /**
     * Apply the an add, remove, set or clear method to the provided operation
     * based on the operation type.
     */
    processOp(onAdd, onRemove, onSet, onClear, operation) {
        if (isCollectionOperation(operation)) {
            switch (operation.type) {
                case CollectionOpTypes.Add:
                    return onAdd(operation);
                case CollectionOpTypes.Remove:
                    return onRemove(operation);
                default:
                    throw new Error('unexpected operation type');
            }
        }
        else if (isSingletonOperation(operation)) {
            switch (operation.type) {
                case SingletonOpTypes.Set:
                    return onSet(operation);
                case SingletonOpTypes.Clear:
                    return onClear(operation);
                default:
                    throw new Error('unexpected operation type');
            }
        }
        throw new Error('unexpected operation type');
    }
    /**
     * Return the element referenced by the provided operation, or null if the operation is a clear operation.
     */
    operationElement(operation) {
        return this.processOp(addOp => addOp.added, removeOp => removeOp.removed, setOp => setOp.value, clearOp => null, operation);
    }
    /**
     * Update the provided operation's element using the provided producer.
     */
    updateOp(operation, getValue) {
        const add = addOp => ({ ...addOp, added: getValue() });
        const remove = removeOp => ({ ...removeOp, removed: getValue() });
        const set = setOp => ({ ...setOp, value: getValue() });
        const clear = clearOp => clearOp;
        return this.processOp(add, remove, set, clear, operation);
    }
}
function versionIsLarger(larger, smaller) {
    for (const key in Object.keys(smaller)) {
        if (larger[key] < smaller[key]) {
            return false;
        }
    }
    return true;
}
class HoldQueue {
    constructor() {
        this.queue = {};
    }
    enqueue(entities, onRelease) {
        const ids = {};
        for (const { id, version } of entities) {
            ids[id] = version;
        }
        const holdRecord = { ids, onRelease };
        for (const entity of entities) {
            if (!this.queue[entity.id]) {
                this.queue[entity.id] = [];
            }
            this.queue[entity.id].push(holdRecord);
        }
    }
    processID(id, version) {
        const records = this.queue[id];
        if (!records) {
            return;
        }
        for (const record of records) {
            if (versionIsLarger(version, record.ids[id])) {
                delete record.ids[id];
                if (Object.keys(record.ids).length === 0) {
                    record.onRelease();
                }
            }
        }
        this.queue[id] = [];
    }
}
function isCollectionOperation(operation) {
    return Boolean(operation['added'] || operation['removed']);
}
function isSingletonOperation(operation) {
    return !isCollectionOperation(operation);
}
//# sourceMappingURL=reference-mode-store.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/store-constructors.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */





// Inject into StoreConstructors to avoid a direct reference to
// ReferenceModeStore from Store, which causes a cyclic dependency.
active_store_ActiveStore.constructors = new Map([
    [StorageMode.Direct, direct_store_DirectStore],
    [StorageMode.ReferenceMode, reference_mode_store_ReferenceModeStore],
    [StorageMode.Backing, direct_store_muxer_DirectStoreMuxer]
]);
//# sourceMappingURL=store-constructors.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/entity-utils.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */




function convertToJsType(primitiveType, schemaName) {
    switch (primitiveType.type) {
        case 'Text':
            return 'string';
        case 'URL':
            return 'string';
        case 'Number':
            return 'number';
        case 'BigInt':
            return 'bigint';
        case 'Boolean':
            return 'boolean';
        case 'Bytes':
            return 'Uint8Array';
        default:
            throw new Error(`Unknown field type ${primitiveType.type} in schema ${schemaName}`);
    }
}
function valueType(value) {
    return value.constructor.name === 'Uint8Array' ? 'Uint8Array' : typeof (value);
}
// tslint:disable-next-line: no-any
function validateFieldAndTypes(name, value, schema, fieldType) {
    fieldType = fieldType || schema.fields[name];
    if (fieldType === undefined) {
        throw new Error(`Can't set field ${name}; not in schema ${schema.name}`);
    }
    if (value === undefined || value === null) {
        return;
    }
    switch (fieldType.kind) {
        case 'schema-primitive': {
            if (valueType(value) !== convertToJsType(fieldType, schema.name)) {
                throw new TypeError(`Type mismatch setting field ${name} (type ${fieldType.getType()}); ` +
                    `value '${value}' is type ${valueType(value)}`);
            }
            break;
        }
        case 'kotlin-primitive': {
            throw new Error(`Kotlin primitive values can't yet be used in TS`);
        }
        case 'schema-union':
            // Value must be a primitive that matches one of the union types.
            for (const innerType of fieldType.getFieldTypes()) {
                if (valueType(value) === convertToJsType(innerType, schema.name)) {
                    return;
                }
            }
            throw new TypeError(`Type mismatch setting field ${name} (union [${fieldType.getFieldTypes().map(d => d.getType())}]); ` +
                `value '${value}' is type ${valueType(value)}`);
        case 'schema-tuple':
            // Value must be an array whose contents match each of the tuple types.
            if (!Array.isArray(value)) {
                throw new TypeError(`Cannot set tuple ${name} with non-array value '${value}'`);
            }
            if (value.length !== fieldType.getFieldTypes().length) {
                throw new TypeError(`Length mismatch setting tuple ${name} ` +
                    `[${fieldType.getFieldTypes().map(d => d.getType())}] with value '${value}'`);
            }
            for (const [i, innerType] of fieldType.getFieldTypes().entries()) {
                if (value[i] != null && valueType(value[i]) !== convertToJsType(innerType, schema.name)) {
                    throw new TypeError(`Type mismatch setting field ${name} (tuple [${fieldType.getFieldTypes().map(d => d.getType())}]); ` +
                        `value '${value}' has type ${valueType(value[i])} at index ${i}`);
                }
            }
            break;
        case 'schema-reference':
            if (!(value instanceof reference_Reference)) {
                throw new TypeError(`Cannot set reference ${name} with non-reference '${value}'`);
            }
            if (!type_checker_TypeChecker.compareTypes({ type: value.type }, { type: new type_ReferenceType(fieldType.getEntityType()) })) {
                throw new TypeError(`Cannot set reference ${name} with value '${value}' of mismatched type`);
            }
            break;
        case 'schema-collection':
            // WTF?! value instanceof Set is returning false sometimes here because the Set in
            // this environment (a native code constructor) isn't equal to the Set that the value
            // has been constructed with (another native code constructor)...
            if (value.constructor.name !== 'Set') {
                throw new TypeError(`Cannot set collection ${name} with non-Set '${value}'`);
            }
            for (const element of value) {
                validateFieldAndTypes(name, element, schema, fieldType.getFieldType());
            }
            break;
        case 'schema-ordered-list':
            if (typeof value.length !== 'number') {
                throw new TypeError(`Cannot set ordered list ${name} with non-list '${value}'`);
            }
            for (const element of value) {
                validateFieldAndTypes(name, element, schema, fieldType.getFieldType());
            }
            break;
        case 'schema-nested':
            // sanitizeEntry will check the nested fields, no need to do so here.
            break;
        default:
            throw new Error(`Unknown kind '${fieldType.kind}' for field ${name} in schema ${schema.name}`);
    }
}
function sanitizeEntry(type, value, name, frontend) {
    if (!type) {
        // If there isn't a field type for this, the proxy will pick up
        // that fact and report a meaningful error.
        return value;
    }
    if (type.isReference && value) {
        if (value instanceof reference_Reference) {
            // Setting value as Reference (Particle side). This will enforce that the type provided for
            // the handle matches the type of the reference.
            return value;
        }
        else if (value.id &&
            (!value['creationTimestamp'] || value.creationTimestamp) &&
            value.entityStorageKey) {
            // Setting value from raw data (Channel side).
            // TODO(shans): This can't enforce type safety here as there isn't any type data available.
            // Maybe this is OK because there's type checking on the other side of the channel?
            return new reference_Reference(value, new type_ReferenceType(type.getEntityType()), frontend);
        }
        else {
            throw new TypeError(`Cannot set reference ${name} with non-reference '${value}'`);
        }
    }
    else if (type.isCollection && value) {
        // WTF?! value instanceof Set is returning false sometimes here because the Set in
        // this environment (a native code constructor) isn't equal to the Set that the value
        // has been constructed with (another native code constructor)...
        if (value.constructor.name === 'Set') {
            return value;
        }
        else if (value instanceof Object && 'length' in value) {
            return new Set(value.map(v => sanitizeEntry(type.getFieldType(), v, name, frontend)));
        }
        else {
            throw new TypeError(`Cannot set collection ${name} with non-collection '${value}'`);
        }
    }
    else if (type.isNested) {
        if (value instanceof entity_Entity) {
            return value;
        }
        else if (typeof value !== 'object') {
            throw new TypeError(`Cannot set nested schema ${name} with non-object '${value}'`);
        }
        else {
            return new (entity_Entity.createEntityClass(type.getEntityType().entitySchema, null))(value);
        }
    }
    else {
        return value;
    }
}
entity_Entity.sanitizeEntry = sanitizeEntry;
entity_Entity.validateFieldAndTypes = validateFieldAndTypes;
//# sourceMappingURL=entity-utils.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/loader-base.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */







// The following imports just run the code in them on loading. These assign
// static functions into classes in order to break circular dependencies.





const { warn } = logsFactory('Loader', 'green');
const isString = s => (typeof s === 'string');
const isSchemaOrgUrl = (s) => /\/\/schema.org\//.test(s);
// a qualified url is an absolute path with `https` protocol
const isQualifiedUrl = (s) => /^https?:\/\//.test(s);
/**
 * Key public API:
 *   async loadResource(file: string): Promise<string>
 *   async loadBinaryResource(file: string): Promise<ArrayBuffer>
 *   async loadParticleClass(spec: ParticleSpec): Promise<typeof Particle>
 */
class loader_base_LoaderBase {
    constructor(urlMap = {}, staticMap = {}) {
        // urlMap shan't be nullish
        this.urlMap = urlMap || {};
        this.staticMap = staticMap;
        this.compileRegExp(this.urlMap);
    }
    setParticleExecutionContext(pec) {
        this.pec = pec;
    }
    flushCaches() {
        // as needed
    }
    // load[Resource|Static] and loadBinary[Resource|Static] methods are forked for type-safety (can we DRY?)
    async loadResource(file) {
        const content = this.loadStatic(file);
        if (content) {
            return content;
        }
        const path = this.resolve(file);
        if (isQualifiedUrl(path)) {
            return this.loadUrl(path);
        }
        return this.loadFile(path);
    }
    jvmClassExists(classPath) {
        return false;
    }
    async loadBinaryResource(file) {
        const content = this.loadStaticBinary(file);
        if (content) {
            return content;
        }
        const path = this.resolve(file);
        if (isQualifiedUrl(path)) {
            return this.loadBinaryUrl(path);
        }
        return this.loadBinaryFile(path);
    }
    loadStatic(path) {
        const content = this.staticMap[path] || this.staticMap['*'];
        if (content && !isString(content)) {
            throw new Error('Cannot load static binary content as string');
        }
        return content;
    }
    loadStaticBinary(path) {
        const content = this.staticMap[path];
        if (content) {
            if (content instanceof ArrayBuffer) {
                return content;
            }
            throw new Error('Cannot load static string content as binary');
        }
        return null;
    }
    async loadUrl(url) {
        if (isSchemaOrgUrl(url)) {
            return this.loadSchemaOrgUrl(url);
        }
        return this.fetchString(url);
    }
    async fetchString(url) {
        const res = await lib(url);
        if (res.ok) {
            return res.text();
        }
        return Promise.reject(new Error(`HTTP ${res.status}: ${res.statusText}`));
    }
    async loadBinaryUrl(url) {
        return this.fetchBuffer(url);
    }
    async fetchBuffer(url) {
        const res = await lib(url);
        if (res.ok) {
            return res.arrayBuffer();
        }
        return Promise.reject(new Error(`HTTP ${res.status}: ${res.statusText} for ${url}`));
    }
    // TODO(sjmiles): there are tests that enforce these methods
    // are overridable on loader, but I would suggest we keep them
    // static, and factor them into a util.
    // The strategy would be to let all internal paths be unix-like,
    // and make necessary platform transforms only at the last mile
    // (aka in the abstract methods above).
    join(prefix, path) {
        return loader_base_LoaderBase.join(prefix, path);
    }
    path(fileName) {
        return loader_base_LoaderBase.path(fileName);
    }
    resolve(path) {
        const resolved = this.resolvePath(path);
        const compact = loader_base_LoaderBase.normalizeDots(resolved);
        return compact;
    }
    resolvePath(path) {
        let resolved = path;
        const macro = this.findUrlMapMacro(path);
        if (macro) {
            const config = this.urlMap[macro];
            if (isString(config)) {
                resolved = `${config}${path.slice(macro.length)}`;
            }
            else {
                resolved = this.resolveConfiguredPath(path, macro, config);
            }
        }
        return resolved;
    }
    findUrlMapMacro(path) {
        // find longest key in urlMap that is a prefix of path
        return Object.keys(this.urlMap)
            .sort((a, b) => b.length - a.length)
            .find(k => isString(path) && (path.slice(0, k.length) === k));
    }
    resolveConfiguredPath(path, macro, config) {
        return [
            config.root,
            (path.match(config.compiledRegex) ? config.buildDir : ''),
            (config.path || ''),
            path.slice(macro.length)
        ].join('');
    }
    mapParticleUrl(path) {
        if (!path) {
            return undefined;
        }
        const resolved = this.resolve(path);
        const parts = resolved.split('/');
        parts.pop();
        const folder = parts.join('/');
        this.urlMap['$here'] = folder;
        this.urlMap['$module'] = folder;
    }
    async loadSchemaOrgUrl(url) {
        let href = `${url}.jsonld`;
        let opts = null;
        if (url.endsWith('/Thing')) {
            href = 'https://schema.org/Product.jsonld';
            opts = { '@id': 'schema:Thing' };
        }
        const data = await this.fetchString(href);
        return JsonldToManifest.convert(data, opts);
    }
    async provisionObjectUrl(fileName) {
        // no facility for this by default
        return null;
    }
    //
    // Below here invoked from inside isolation scope (e.g. Worker)
    //
    /**
     * Returns a particle class implementation by loading and executing
     * the code defined by a particle.  In the following example `x.js`
     * will be loaded and executed:
     *
     * ```
     * Particle foo in 'x.js'
     * ```
     */
    async loadParticleClass(spec) {
        let particleClass = null;
        const userClass = await this.requireParticle(spec.implFile || '', spec.implBlobUrl);
        if (!userClass) {
            warn(`[${spec.implFile}]::defineParticle() returned no particle.`);
        }
        else {
            particleClass = userClass;
            particleClass.spec = spec;
        }
        return particleClass;
    }
    /**
     * executes the defineParticle() code and returns the results which should be a class definition.
     */
    unwrapParticle(particleWrapper, log) {
        external_assert_default()(this.pec);
        return particleWrapper({
            // Particle base
            Particle: particle_Particle,
            // utilities
            Reference: reference_ClientReference.newClientReference(this.pec),
            resolver: this.resolve.bind(this),
            log: log || (() => { }),
            html: html,
            // additional namespace items
            ...loader_base_LoaderBase.namespace
        });
    }
    provisionLogger(fileName) {
        return logsFactory(fileName.split('/').pop(), '#1faa00').log;
    }
    compileRegExp(urlMap) {
        for (const config of Object.values(urlMap)) {
            if (typeof config === 'string')
                continue;
            config.compiledRegex = RegExp(config.buildOutputRegex);
        }
    }
    // concatenate paths
    static join(prefix, path) {
        if (isQualifiedUrl(path)) {
            return path;
        }
        // TODO: replace this with something that isn't hacky
        if (path[0] === '/' || path[1] === ':') {
            return path;
        }
        prefix = prefix ? this.path(prefix) : '';
        path = this.normalizeDots(`${prefix}${path}`);
        return path;
    }
    // return up to, but not including, the last delimeter (e.g. remove filename, /foo/bar => /foo)
    // TODO(sjmiles): name needs work
    static path(fileName) {
        return fileName.replace(/[/][^/]+$/, '/');
    }
    // convert `././foo/bar/../baz` to `./foo/baz`
    static normalizeDots(path) {
        // don't be nullish
        path = path || '';
        // only unix slashes
        path = path.replace(/\\/g, '/');
        // remove './'
        path = path.replace(/\/\.\//g, '/');
        // remove 'foo/..' (a down-up)
        const norm = (s) => s.replace(/[^./]+\/\.\.\//g, '');
        // remove down-ups until there are no more
        for (let n = norm(path); n !== path; path = n, n = norm(path))
            ;
        // remove '//' except after `:`
        path = path.replace(/([^:])(\/\/)/g, '$1/');
        return path;
    }
    /**
     * Test to determine if string matches JVM package / class naming convention:
     * https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html
     */
    static isJvmClasspath(candidate) {
        if (!candidate)
            return false;
        const isCapitalized = (s) => s[0] === s[0].toUpperCase();
        const startsWithLetter = (s) => /[a-zA-Z]/.test(s[0]);
        let capitalGate = false;
        for (const it of candidate.split('.')) {
            if (!it)
                return false;
            if (!/\w+/.test(it))
                return false;
            if (!startsWithLetter(it))
                return false;
            // Switch from lower to upper
            if (isCapitalized(it) && !capitalGate) {
                capitalGate = true;
            }
            // Reject invalid capitalization -- switch from upper to lower case
            if (!isCapitalized(it) && capitalGate) {
                return false;
            }
        }
        // Should end with capitals
        return capitalGate;
    }
}
//# sourceMappingURL=loader-base.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/loader-node.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */





class loader_node_Loader extends loader_base_LoaderBase {
    clone() {
        return new loader_node_Loader(this.urlMap, this.staticMap);
    }
    async loadFile(path) {
        const data = await this.loadFileData(path, 'utf-8');
        if (typeof data !== 'string') {
            throw new Error(`loadFileData returned type [${typeof data}] instead of non-String for utf-8 file [${path}]`);
        }
        return data;
    }
    async loadBinaryFile(path) {
        const data = await this.loadFileData(path);
        if (!(data instanceof Buffer)) {
            throw new Error(`loadFileData returned non-Buffer for binary file [${path}]`);
        }
        // convert Buffer to ArrayBuffer (slice in case a small Buffer is a view on a shared ArrayBuffer)
        return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
    }
    async loadFileData(path, encoding) {
        return new Promise((resolve, reject) => {
            external_fs_default.a.readFile(path, encoding, (err, data) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(data);
                }
            });
        });
    }
    /**
     * Parse a Java-style package string to verify that class exists.
     *
     * @param classPath java.style.ClassPath
     * @param startingPath (optional) list of (nested) directories to search in
     */
    jvmClassExists(classPath, startingPath = ['java']) {
        const isCapitalized = (word) => word[0] === word[0].toUpperCase();
        const pathSoFar = startingPath;
        let maybeFile = '';
        for (const it of classPath.split('.')) {
            // Parse directory
            if (!isCapitalized(it)) {
                pathSoFar.push(it);
                if (!external_fs_default.a.existsSync(pathSoFar.join('/'))) {
                    return false;
                }
            }
            // Parse class or inner class
            else {
                // Check inner class
                if (maybeFile) {
                    if (!maybeFile.includes(it)) {
                        return false;
                    }
                }
                // Try to load Jvm file based on class name
                else {
                    const path = pathSoFar.join('/');
                    const jvmFiles = external_fs_default.a.readdirSync(path, { withFileTypes: true })
                        .filter(x => x.name.endsWith('.java') || x.name.endsWith('.kt'))
                        .map(jvmFile => `${path}/${jvmFile.name}`);
                    for (const file of jvmFiles) {
                        const candidateFile = external_fs_default.a.readFileSync(file, { encoding: 'utf8' });
                        if (candidateFile.includes(`class ${it}`) || candidateFile.includes(`object ${it}`)) {
                            maybeFile = candidateFile;
                            break;
                        }
                    }
                    if (!maybeFile) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    async requireParticle(fileName, blobUrl) {
        // inject path to this particle into the UrlMap,
        // allows Foo particle to invoke `importScripts(resolver('$here/othermodule.js'))`
        this.mapParticleUrl(fileName);
        // resolve path
        const path = this.resolve(fileName);
        // get source code
        const src = await this.loadResource(blobUrl || path);
        // Note. This is not real isolation.
        const script = new external_vm_default.a.Script(src, { filename: fileName, displayErrors: true });
        const result = [];
        // TODO(lindner): restrict Math.random here.
        const self = {
            defineParticle(particleWrapper) {
                result.push(particleWrapper);
            },
            console,
            fetch: lib,
            setTimeout,
            importScripts: s => null //console.log(`(skipping browser-space import for [${s}])`)
        };
        script.runInNewContext(self, { filename: fileName, displayErrors: true });
        const wrapper = result[0];
        external_assert_default()(typeof wrapper === 'function', `Error while instantiating particle implementation from ${fileName}`);
        // unwrap particle wrapper
        return this.unwrapParticle(wrapper, this.provisionLogger(fileName));
    }
}
//# sourceMappingURL=loader-node.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/loader.js
/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

//# sourceMappingURL=loader.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/manifest-meta.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class ManifestMeta {
    constructor() {
        this.storageKey = null;
        this.name = null;
    }
    apply(items) {
        items.forEach(item => { this[item.key] = item.value; });
    }
}
//# sourceMappingURL=manifest-meta.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/arcs-types/direction-util.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
function connectionMatchesHandleDirection(connectionDirection, handleDirection) {
    return acceptedDirections(connectionDirection).includes(handleDirection);
}
function acceptedDirections(direction) {
    // @param direction: the direction of a handleconnection.
    // @return acceptedDirections: the list of directions a handle can have that
    // are allowed with this handle connection.
    //
    switch (direction) {
        case 'any':
            return ['any', 'reads', 'writes', 'reads writes', 'hosts', '`consumes', '`provides'];
        case 'reads':
            return ['any', 'reads', 'reads writes', 'hosts', '`consumes'];
        case 'writes':
            return ['any', 'writes', 'reads writes', '`provides'];
        case 'reads writes':
            return ['any', 'reads writes'];
        case 'hosts':
            return ['any', 'hosts'];
        case '`consumes':
            return ['any', '`consumes'];
        case '`provides':
            return ['any', '`provides'];
        default:
            // Catch nulls and unsafe values from javascript.
            throw new Error(`Bad direction ${direction}`);
    }
}
//# sourceMappingURL=direction-util.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/internal/slot-connection.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


class slot_connection_SlotConnection {
    constructor(name, particle) {
        this._targetSlot = undefined;
        this._providedSlots = {};
        this._tags = [];
        external_assert_default()(particle);
        external_assert_default()(particle.recipe);
        external_assert_default()(name);
        this._recipe = particle.recipe;
        this._particle = particle;
        this._name = name;
    }
    remove() {
        this._particle.removeSlotConnection(this);
    }
    get recipe() { return this._recipe; }
    get particle() { return this._particle; }
    get name() { return this._name; }
    getQualifiedName() { return `${this.particle.name}::${this.name}`; }
    get targetSlot() { return this._targetSlot; }
    set targetSlot(targetSlot) { this._targetSlot = targetSlot; }
    get providedSlots() { return this._providedSlots; }
    get tags() { return this._tags; }
    set tags(tags) { this._tags = tags; }
    getSlotSpec() {
        return this.particle.spec && this.particle.spec.getSlandleSpec(this.name);
    }
    connectToSlot(targetSlot) {
        external_assert_default()(targetSlot);
        external_assert_default()(!this.targetSlot);
        external_assert_default()(this.recipe.isRequireSection || this.recipe === targetSlot.recipe, 'Cannot connect to slot from different recipe');
        this._targetSlot = targetSlot;
        this._targetSlot.consumeConnections.push(this);
    }
    disconnectFromSlot() {
        if (this._targetSlot) {
            this._targetSlot.removeConsumeConnection(this);
            this._targetSlot = undefined;
        }
    }
    _clone(particle, cloneMap) {
        if (cloneMap.has(this)) {
            return cloneMap.get(this);
        }
        const slotConnection = particle.addSlotConnectionAsCopy(this.name);
        slotConnection.tags = this.tags;
        cloneMap.set(this, slotConnection);
        return slotConnection;
    }
    _normalize() {
        const normalizedSlots = {};
        for (const key of (Object.keys(this._providedSlots).sort())) {
            normalizedSlots[key] = this._providedSlots[key];
        }
        this._providedSlots = normalizedSlots;
        Object.freeze(this);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareStrings(this.name, other.name)) !== 0)
            return cmp;
        if ((cmp = compareComparables(this._targetSlot, other._targetSlot)) !== 0)
            return cmp;
        if ((cmp = compareComparables(this._particle, other._particle)) !== 0)
            return cmp;
        return 0;
    }
    _isValid(options) {
        if (this._targetSlot && this._targetSlot.sourceConnection &&
            this._targetSlot !== this._targetSlot.sourceConnection.providedSlots[this._targetSlot.name]) {
            if (options && options.errors) {
                options.errors.set(this, `Invalid target slot '${this._targetSlot.name}' for slot connection '${this.name}' of particle ${this.particle.name}`);
            }
            return false;
        }
        // TODO: add more checks.
        return true;
    }
    isResolved(options) {
        const error = (label) => {
            if (options && options.errors) {
                options.errors.set(this.name, label);
            }
            if (options && options.details) {
                options.details = label; // TODO(jopra): use .errors instead.
            }
        };
        external_assert_default()(Object.isFrozen(this), `slot connection ${this.name} must be frozen before it is resolved`);
        if (!this.name) {
            error('missing name');
            return false;
        }
        if (!this.particle) {
            error('missing particle');
            return false;
        }
        const slotSpec = this.getSlotSpec();
        if (slotSpec === undefined || slotSpec.isRequired) {
            if (!this.targetSlot) {
                // The required connection has no target slot
                error(`missing target-slot`);
                return false;
            }
            if (!this.targetSlot.id && !(this.targetSlot.sourceConnection && this.targetSlot.sourceConnection.isConnected())) {
                // The required connection's target slot is not resolved (has no ID or source connection).
                error(`unresolved target-slot`);
                return false;
            }
        }
        if (!this.targetSlot) {
            return true;
        }
        if (slotSpec === undefined)
            return true;
        return this.getSlotSpec().provideSlotConnections.every(providedSlot => {
            if (providedSlot && providedSlot.isRequired && this.providedSlots[providedSlot.name].consumeConnections.length === 0) {
                error('missing consuming slot');
                return false;
            }
            return true;
        });
    }
    getConnectedProvideSlots() {
        return Object.values(this.providedSlots).filter(slot => slot.consumeConnections.length > 0);
    }
    connectProvidedSlot(name, slot) {
        this.providedSlots[name] = slot;
        slot.sourceConnection = this;
    }
    disconnectProvidedSlot(name) {
        this.providedSlots[name].remove();
    }
    isConnectedToInternalSlot() {
        return this.targetSlot && (!!this.targetSlot.sourceConnection);
    }
    isConnectedToRemoteSlot() {
        return this.targetSlot && (!!this.targetSlot.id);
    }
    isConnected() {
        return this.isConnectedToInternalSlot() || this.isConnectedToRemoteSlot();
    }
    toString(nameMap, options) {
        const consumeRes = [];
        consumeRes.push(`${this.name}:`);
        consumeRes.push('consumes');
        if (this.targetSlot) {
            consumeRes.push((nameMap && nameMap.get(this.targetSlot)) ||
                this.targetSlot.localName);
        }
        if (options && options.showUnresolved) {
            if (!this.isResolved(options)) {
                consumeRes.push(`// unresolved slot-connection: ${options.details}`);
            }
        }
        const result = [];
        result.push(consumeRes.join(' '));
        Object.keys(this.providedSlots).forEach(psName => {
            const providedSlot = this.providedSlots[psName];
            const provideRes = [];
            // Only assert that there's a spec for this provided slot if there's a spec for
            // the consumed slot .. otherwise this is just a constraint.
            if (this.getSlotSpec()) {
                const providedSlotSpec = this.particle.getSlotSpecByName(psName);
                external_assert_default()(providedSlotSpec, `Cannot find providedSlotSpec for ${psName}`);
            }
            provideRes.push(`  ${psName}:`);
            provideRes.push('provides');
            provideRes.push(`${(nameMap && nameMap.get(providedSlot)) || providedSlot}`);
            result.push(provideRes.join(' '));
        });
        return result.join('\n');
    }
}
//# sourceMappingURL=slot-connection.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/internal/slot.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */



class slot_Slot {
    constructor(recipe, name) {
        this._id = undefined;
        this._localName = undefined;
        this._tags = [];
        this._sourceConnection = undefined;
        this._formFactor = undefined;
        this._consumeConnections = [];
        external_assert_default()(recipe);
        this._recipe = recipe;
        this._name = name;
    }
    get recipe() { return this._recipe; }
    get id() { return this._id; }
    set id(id) { this._id = id; }
    get localName() { return this._localName; }
    set localName(localName) { this._localName = localName; }
    get name() { return this._name; }
    set name(name) { this._name = name; }
    get tags() { return this._tags; }
    set tags(tags) { this._tags = tags; }
    get formFactor() { return this._formFactor; }
    set formFactor(formFactor) { this._formFactor = formFactor; }
    get sourceConnection() { return this._sourceConnection; }
    set sourceConnection(sourceConnection) { this._sourceConnection = sourceConnection; }
    get consumeConnections() { return this._consumeConnections; }
    get spec() {
        // TODO: should this return something that indicates this isn't available yet instead of
        // the constructed {isSet: false, tags: []}?
        return (this.sourceConnection && this.sourceConnection.getSlotSpec()) ? this.sourceConnection.particle.getSlotSpecByName(this.name) : { isSet: false, tags: [] };
    }
    get handles() {
        // TODO(jopra): This lazy initialization is surprising. Consider removing.
        const handles = [];
        if (this.sourceConnection && this.sourceConnection.getSlotSpec()) {
            for (const handleName of this.sourceConnection.particle.getSlotSpecByName(this.name).handles) {
                const handleConn = this.sourceConnection.particle.connections[handleName];
                if (handleConn || handleConn.handle) {
                    handles.push(handleConn.handle);
                }
            }
        }
        return handles;
    }
    _copyInto(recipe, cloneMap) {
        let slot = undefined;
        if (cloneMap.has(this)) {
            return cloneMap.get(this);
        }
        if (!this.sourceConnection && this.id) {
            slot = recipe.findSlot(this.id);
        }
        if (slot == undefined) {
            slot = recipe.newSlot(this.name);
            slot._id = this.id;
            slot._formFactor = this.formFactor;
            slot._localName = this._localName;
            slot._tags = [...this._tags];
            // the connections are re-established when Particles clone their attached SlotConnection objects.
            slot._sourceConnection = cloneMap.get(this._sourceConnection);
            if (slot.sourceConnection) {
                slot.sourceConnection.providedSlots[slot.name] = slot;
            }
        }
        this._consumeConnections.forEach(connection => {
            const clonedConnection = cloneMap.get(connection);
            if (clonedConnection && clonedConnection instanceof slot_connection_SlotConnection && clonedConnection.targetSlot == undefined) {
                clonedConnection.connectToSlot(slot);
            }
        });
        return slot;
    }
    _startNormalize() {
        this.localName = null;
        this._tags.sort();
    }
    _finishNormalize() {
        // TODO(mmandlis): This was assert(Object.isFroze(this._source)) - but there is no _source.
        // Changing to _sourceConnection makes the assert fail.
        // assert(Object.isFrozen(this._sourceConnection));
        this._consumeConnections.forEach(cc => external_assert_default()(Object.isFrozen(cc)));
        this._consumeConnections.sort(compareComparables);
        Object.freeze(this);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareStrings(this.id, other.id)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this.localName, other.localName)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this.formFactor, other.formFactor)) !== 0)
            return cmp;
        if ((cmp = compareArrays(this._tags, other._tags, compareStrings)) !== 0)
            return cmp;
        return 0;
    }
    findHandleByID(id) {
        return this.handles.find(handle => handle.id === id);
    }
    removeConsumeConnection(slotConnection) {
        const idx = this._consumeConnections.indexOf(slotConnection);
        external_assert_default()(idx > -1);
        this._consumeConnections.splice(idx, 1);
        if (this._consumeConnections.length === 0) {
            this.remove();
        }
    }
    remove() {
        this._recipe.removeSlot(this);
    }
    isResolved(options) {
        external_assert_default()(Object.isFrozen(this));
        if (options && options.showUnresolved) {
            options.details = [];
            if (!this._sourceConnection) {
                options.details.push('missing source-connection');
            }
            if (!this.id) {
                options.details.push('missing id');
            }
        }
        return Boolean(this._sourceConnection || this.id);
    }
    _isValid(options) {
        // TODO: implement
        return true;
    }
    toString(options = {}, nameMap) {
        const result = [];
        const name = (nameMap && nameMap.get(this)) || this.localName;
        result.push(`${name}:`);
        result.push('slot');
        if (this.id) {
            result.push(`'${this.id}'`);
        }
        if (this.tags.length > 0) {
            result.push(this.tags.map(tag => `#${tag}`).join(' '));
        }
        const includeUnresolved = options.showUnresolved && !this.isResolved(options);
        if (includeUnresolved) {
            result.push(`// unresolved slot: ${options.details}`);
        }
        if (this.id || includeUnresolved) {
            return result.join(' ');
        }
        return '';
    }
}
//# sourceMappingURL=slot.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/internal/handle.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */







class internal_handle_Handle {
    constructor(recipe) {
        this._id = null;
        this._localName = undefined;
        this._tags = [];
        this._type = undefined;
        this._fate = null;
        // TODO: replace originalFate and originalId with more generic mechanism for tracking
        // how and from what the recipe was generated.
        this._originalFate = null;
        this._originalId = null;
        this._connections = [];
        // Handles being joined by this handle.
        // E.g. for `x: join (a, b, c)`, this field on x has references to a, b, c.
        this._joinedHandles = [];
        // Whether this handle is being joined by other handles.
        // E.g. for `x: join (a, b, c)`, this field is true on a, b and c.
        this._isJoined = false;
        this._mappedType = undefined;
        this._storageKey = undefined;
        this._pattern = undefined;
        // Value assigned in the immediate mode, E.g. hostedParticle = ShowProduct
        // Currently only supports ParticleSpec.
        this._immediateValue = undefined;
        this.claims = undefined;
        this._annotations = [];
        this._capabilities = capabilities_Capabilities.create();
        external_assert_default()(recipe);
        this._recipe = recipe;
    }
    toSlot() {
        if (!this.type) {
            return undefined;
        }
        if (this.fate !== '`slot') {
            return undefined;
        }
        const slandle = new slot_Slot(this.recipe, this.localName);
        slandle.tags = this.tags;
        slandle.id = this.id;
        const slotType = this.type.slandleType();
        if (slotType) {
            const slotInfo = slotType.getSlot();
            if (slotInfo) {
                slandle.formFactor = slotInfo.formFactor;
                if (slotInfo.handle) {
                    // TODO(jopra): cannot assign slandle handles as the slots do not
                    // actually track their handles but use a source particle connection
                    // mapping.
                    const particle = undefined;
                    slandle.sourceConnection = new slot_connection_SlotConnection(slotInfo.handle, particle);
                }
            }
        }
        return slandle;
    }
    _copyInto(recipe, cloneMap, variableMap) {
        let handle = undefined;
        if (this._id !== null && ['map', 'use', 'copy'].includes(this.fate)) {
            handle = recipe.findHandleByID(this._id);
        }
        if (handle == undefined) {
            handle = recipe.newHandle();
            handle._id = this._id;
            handle._tags = [...this._tags];
            handle._type = this._type ? this._type._cloneWithResolutions(variableMap) : undefined;
            handle._fate = this._fate;
            handle._originalFate = this._originalFate;
            handle._originalId = this._originalId;
            handle._mappedType = this._mappedType;
            handle._storageKey = this._storageKey;
            handle._immediateValue = this._immediateValue;
            handle.annotations = this.annotations.map(a => a.clone());
            // the connections are re-established when Particles clone their
            // attached HandleConnection objects.
            handle._connections = [];
            handle._pattern = this._pattern;
            for (const joined of this.joinedHandles) {
                handle.joinDataFromHandle(cloneMap.get(joined));
            }
        }
        return handle;
    }
    // Merges `this` recipe handle into `handle`
    mergeInto(handle) {
        external_assert_default()(this.recipe === handle.recipe, 'Cannot merge handles from different recipes.');
        while (this.connections.length > 0) {
            const [connection] = this.connections;
            connection.disconnectHandle();
            connection.connectToHandle(handle);
        }
        handle._immediateValue = this._immediateValue;
        handle.tags = handle.tags.concat(this.tags);
        handle.recipe.removeHandle(this);
        handle.fate = this._mergedFate([this.fate, handle.fate]);
        handle.annotations = handle.annotations.concat(this.annotations);
    }
    _mergedFate(fates) {
        external_assert_default()(fates.length > 0, `Cannot merge empty fates list`);
        // Merging handles only used in coalesce-recipe strategy, which is only done for use/create/? fates.
        external_assert_default()(!fates.some(f => f === 'map' || f === 'copy' || f === 'join'), `Merging map/copy/join not supported yet`);
        // If all fates were `use` keep their fate, otherwise set to `create`.
        return fates.every(fate => fate === 'use') ? 'use' : 'create';
    }
    _startNormalize() {
        this._localName = null;
        this._tags.sort();
        const isSlotType = (type) => {
            const hasTypeWithoutFate = type && this._fate === '?';
            const supersetIsSlandle = type.canWriteSuperset && type.canWriteSuperset.slandleType();
            const subersetIsSlandle = type.canReadSubset && type.canReadSubset.slandleType();
            return hasTypeWithoutFate && (supersetIsSlandle || subersetIsSlandle);
        };
        const resolvedType = this.type.resolvedType();
        const collectionType = resolvedType && resolvedType.isCollectionType() && resolvedType.collectionType;
        if (isSlotType(resolvedType) || isSlotType(collectionType)) {
            this._fate = '`slot';
        }
        this.updateCapabilities();
    }
    _finishNormalize() {
        for (const connection of this._connections) {
            external_assert_default()(Object.isFrozen(connection), `Handle connection '${connection.name}' is not frozen.`);
        }
        this._connections.sort(compareComparables);
        Object.freeze(this);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareStrings(this._id, other._id)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this._localName, other._localName)) !== 0)
            return cmp;
        if ((cmp = compareArrays(this._tags, other._tags, compareStrings)) !== 0)
            return cmp;
        // TODO: type?
        if ((cmp = compareStrings(this.fate, other.fate)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this._immediateValue && this._immediateValue.toString() || '', other._immediateValue && other._immediateValue.toString() || '')) !== 0)
            return cmp;
        return 0;
    }
    // a resolved Handle has either an id or create=true
    get fate() { return this._fate || '?'; }
    set fate(fate) {
        if (this._originalFate == null) {
            this._originalFate = this._fate;
        }
        this._fate = fate;
    }
    get originalFate() { return this._originalFate || '?'; }
    get originalId() { return this._originalId; }
    get recipe() { return this._recipe; }
    get tags() { return this._tags; } // only tags owned by the handle
    set tags(tags) { this._tags = tags; }
    get type() { return this._type; } // nullable
    get id() { return this._id; }
    set id(id) {
        if (!this._originalId) {
            this._originalId = this._id;
        }
        this._id = id;
    }
    mapToStorage(storage) {
        if (!storage) {
            throw new Error(`Cannot map to undefined storage`);
        }
        this._id = storage.id;
        this._originalId = storage.originalId;
        this._type = undefined;
        this._mappedType = storage.type;
        if (this._mappedType.isSingleton) {
            // TODO(shans): Extend notion of singleton types through recipes and remove this conversion.
            this._mappedType = this._mappedType.getContainedType();
        }
        this._storageKey = storage.storageKey;
        this.claims = storage.claims;
    }
    restrictType(restrictedType) {
        external_assert_default()(this.type && this.type.restrictTypeRanges(restrictedType));
        this._type = restrictedType;
    }
    get localName() { return this._localName; }
    set localName(name) { this._localName = name; }
    get connections() { return this._connections; } // HandleConnection*
    get storageKey() { return this._storageKey; }
    set storageKey(key) { this._storageKey = key; }
    get pattern() { return this._pattern; }
    set pattern(pattern) { this._pattern = pattern; }
    get mappedType() { return this._mappedType; }
    set mappedType(mappedType) { this._mappedType = mappedType; }
    get immediateValue() { return this._immediateValue; }
    set immediateValue(value) { this._immediateValue = value; }
    get isSynthetic() { return this.fate === 'join'; } // Join handles are the first type of synthetic handles, other may come.
    get joinedHandles() { return this._joinedHandles; }
    get isJoined() { return this._isJoined; }
    get annotations() { return this._annotations; }
    set annotations(annotations) {
        annotations.every(a => external_assert_default()(a.isValidForTarget('Handle'), `Annotation '${a.name}' is invalid for Handle`));
        this._annotations = annotations;
        this.updateCapabilities();
    }
    getAnnotation(name) {
        const annotations = this.findAnnotations(name);
        external_assert_default()(annotations.length <= 1, `Multiple annotations found for '${name}'. Use findAnnotations instead.`);
        return annotations.length === 0 ? null : annotations[0];
    }
    findAnnotations(name) {
        return this.annotations.filter(a => a.name === name);
    }
    get capabilities() {
        return this._capabilities;
    }
    hasHardRef(schema) {
        for (const field of Object.values(schema.fields)) {
            if (field.annotations.some(a => a.name === 'hardRef')) {
                return true;
            }
            if (field.isNested || field.isOrderedList) {
                if (field.getEntityType() && this.hasHardRef(field.getEntityType().getEntitySchema())) {
                    return true;
                }
            }
        }
        return false;
    }
    updateCapabilities() {
        // Combines capabilities extracted from annotations with implicit
        // capabilities derived from the recipe.
        this._capabilities = capabilities_Capabilities.fromAnnotations(this.annotations);
        if (this._connections.some(c => c.type && c.type.getEntitySchema()
            && c.type.getEntitySchema().refinement)) {
            this._capabilities.setCapability(new capabilities_Queryable(true));
        }
        if (this._connections.some(c => c.type && c.type.getEntitySchema()
            && this.hasHardRef(c.type.getEntitySchema()))) {
            this._capabilities.setCapability(new DeletePropagation(true));
        }
        // Note: Consider adding `Shareable` if handle has an id, or used in other recipes.
    }
    getTtl() {
        return this.capabilities.getTtl() || capabilities_Ttl.infinite();
    }
    static effectiveType(handleType, connections) {
        const variableMap = new Map();
        // It's OK to use _cloneWithResolutions here as for the purpose of this test, the handle set + handleType
        // contain the full set of type variable information that needs to be maintained across the clone.
        const typeSet = connections.filter(connection => connection.type != null).map(connection => ({ type: connection.type._cloneWithResolutions(variableMap), direction: connection.direction, relaxed: connection.relaxed }));
        return type_checker_TypeChecker.processTypeList(handleType ? handleType._cloneWithResolutions(variableMap) : null, typeSet);
    }
    resolveEffectiveType(options) {
        const typeSet = this.connections
            .filter(connection => connection.type != null)
            .map(connection => ({ type: connection.type, direction: connection.direction, relaxed: connection.relaxed }));
        // If a handle is joined, it needs to be a collection (at least for now).
        if (this._isJoined) {
            typeSet.push({
                type: type_TypeVariable.make('').collectionOf(),
                direction: 'reads'
            });
        }
        // Joining a list of handles is a kin to writing from joined handle into a joining handle.
        if (this.fate === 'join') {
            typeSet.push({
                // We forced the joined handles to be collections and resolve their type first,
                // so that we can pull out their collection type here.
                type: new type_TupleType(this.joinedHandles.map(h => h.type.collectionType)).collectionOf(),
                direction: 'writes'
            });
        }
        return type_checker_TypeChecker.processTypeList(this._mappedType, typeSet, options);
    }
    _isValid(options) {
        const tags = new Set();
        for (const connection of this._connections) {
            // A remote handle cannot be connected to an output param.
            if (['map', 'join'].includes(this.fate) && ['writes', 'reads writes'].includes(connection.direction)) {
                if (options && options.errors) {
                    options.errors.set(this, `Invalid fate '${this.fate}' for handle '${this}'; it is used for '${connection.direction}' ${connection.getQualifiedName()} connection`);
                }
                return false;
            }
            connection.tags.forEach(tag => tags.add(tag));
        }
        if (!this.mappedType && this.fate === '`slot') {
            this._mappedType = type_TypeVariable.make(this.id);
        }
        if (options && options.errors) {
            options.typeErrors = [];
        }
        const type = this.resolveEffectiveType(options);
        if (!type) {
            if (options && options.errors) {
                const errs = options.typeErrors;
                if (errs && errs.length > 0) {
                    options.errors.set(this, `Type validations failed for handle '${this}': ${errs.join(', ')}`);
                }
                else {
                    options.errors.set(this, `Type validations failed for handle '${this}' with type ${this._mappedType} and fate ${this.fate}`);
                }
            }
            return false;
        }
        this._type = type;
        this._tags.forEach(tag => tags.add(tag));
        this._tags = [...tags];
        return true;
    }
    isResolved(options) {
        external_assert_default()(Object.isFrozen(this));
        let resolved = true;
        if (this.type) {
            let mustBeResolved = true;
            if (this.fate === 'create' || this.fate === '`slot') {
                mustBeResolved = false;
            }
            if (!this.type.canEnsureResolved()) {
                if (options) {
                    options.details.push('unresolved type (cannot ensure resolved)');
                }
                resolved = false;
            }
            if (mustBeResolved && !this.type.isResolved()) {
                if (options) {
                    options.details.push('unresolved type');
                }
                resolved = false;
            }
        }
        else {
            if (options) {
                options.details.push('missing type');
            }
            resolved = false;
        }
        switch (this.fate) {
            case '?': {
                if (options) {
                    options.details.push('missing fate');
                }
                resolved = false;
                break;
            }
            case 'copy':
            case 'map':
            case 'use': {
                if (options && this.id === null) {
                    options.details.push('missing id');
                }
                resolved = resolved && (this.id !== null);
                break;
            }
            case '`slot':
            case 'create':
            case 'join':
                break;
            default: {
                if (options) {
                    options.details.push(`invalid fate ${this.fate}`);
                }
                throw new Error(`Unexpected fate: ${this.fate}`);
            }
        }
        return resolved;
    }
    toString(options = {}, nameMap) {
        if (this._immediateValue) {
            // Immediate Value handles are only rendered inline with particle connections.
            // E.g. hostedParticle = ShowProduct
            return undefined;
        }
        const getName = (h) => ((nameMap && nameMap.get(h)) || h.localName);
        // TODO: type? maybe output in a comment
        const result = [];
        const name = getName(this);
        if (name) {
            result.push(`${name}:`);
        }
        result.push(this.fate);
        if (this.fate === 'join') {
            result.push(`(${this.joinedHandles.map(h => getName(h)).join(', ')})`);
        }
        if (this.id) {
            result.push(`'${this.id}'`);
        }
        result.push(...this.tags.map(a => `#${a}`));
        if (this.annotations && this.annotations.length > 0) {
            result.push(this.annotations.map(a => a.toString()).join(' '));
        }
        // Debug information etc.
        if (this.type) {
            result.push('//');
            if (this.type.isResolved()) {
                result.push(this.type.resolvedType().toString({ hideFields: options.hideFields == undefined ? true : options.hideFields }));
            }
            else {
                // TODO: include the unresolved constraints in toString (ie in the hash).
                result.push(this.type.toString());
                if (options.showUnresolved && this.type.canEnsureResolved()) {
                    const type = type_Type.fromLiteral(this.type.toLiteral());
                    type.maybeEnsureResolved();
                    result.push('//');
                    result.push(type.resolvedType().toString({ hideFields: options.hideFields == undefined ? true : options.hideFields }));
                }
            }
        }
        if (options.showUnresolved) {
            const unresolvedOptions = { details: [] };
            if (!this.isResolved(unresolvedOptions)) {
                result.push(` // unresolved handle: ${unresolvedOptions.details.join(', ')}`);
            }
        }
        return result.join(' ');
    }
    findConnectionByDirection(dir) {
        return this._connections.find(conn => conn.direction === dir);
    }
    joinDataFromHandle(handle) {
        external_assert_default()(this.fate === 'join');
        this._joinedHandles.push(handle);
        handle._isJoined = true;
    }
}
//# sourceMappingURL=handle.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/internal/recipe-interface.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

// TODO(shanestephens): this should move into the type library.
const effectiveTypeForHandle = internal_handle_Handle.effectiveType;
//# sourceMappingURL=recipe-interface.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/internal/connection-constraint.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */



class EndPoint {
    select(selector) {
        if (this instanceof connection_constraint_ParticleEndPoint && selector.isParticleEndPoint) {
            selector.isParticleEndPoint(this);
        }
        else if (this instanceof connection_constraint_HandleEndPoint && selector.isHandleEndPoint) {
            selector.isHandleEndPoint(this);
        }
        else if (this instanceof connection_constraint_TagEndPoint && selector.isTagEndPoint) {
            selector.isTagEndPoint(this);
        }
        else if (this instanceof connection_constraint_InstanceEndPoint && selector.isInstanceEndPoint) {
            selector.isInstanceEndPoint(this);
        }
    }
    requireInstanceEndPoint(errorMessage) {
        if (this instanceof connection_constraint_InstanceEndPoint) {
            return this;
        }
        throw new TypeError(errorMessage());
    }
    requireParticleEndPoint(errorMessage) {
        if (this instanceof connection_constraint_ParticleEndPoint) {
            return this;
        }
        throw new TypeError(errorMessage());
    }
}
class connection_constraint_ParticleEndPoint extends EndPoint {
    constructor(particle, connection) {
        super();
        this.particle = particle;
        this.connection = connection;
    }
    _clone(cloneMap) {
        return new connection_constraint_ParticleEndPoint(this.particle, this.connection);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareStrings(this.particle.name, other.particle.name)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this.connection, other.connection)) !== 0)
            return cmp;
        return 0;
    }
    toString(nameMap) {
        if (!this.connection) {
            return `${this.particle.name}`;
        }
        return `${this.particle.name}.${this.connection}`;
    }
}
class connection_constraint_InstanceEndPoint extends EndPoint {
    constructor(instance, connection) {
        super();
        external_assert_default()(instance);
        //this.recipe = instance.recipe;
        this.instance = instance;
        this.connection = connection;
    }
    _clone(cloneMap) {
        return new connection_constraint_InstanceEndPoint(cloneMap.get(this.instance), this.connection);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareComparables(this.instance, other.instance)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this.connection, other.connection)) !== 0)
            return cmp;
        return 0;
    }
    toString(nameMap) {
        if (!this.connection) {
            return `${nameMap.get(this.instance)}`;
        }
        return `${nameMap.get(this.instance)}.${this.connection}`;
    }
}
class connection_constraint_HandleEndPoint extends EndPoint {
    constructor(handle) {
        super();
        this.handle = handle;
    }
    _clone(cloneMap = undefined) {
        return new connection_constraint_HandleEndPoint(this.handle);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareStrings(this.handle.localName, other.handle.localName)) !== 0)
            return cmp;
        return 0;
    }
    toString(nameMap = undefined) {
        return `${this.handle.localName}`;
    }
}
class connection_constraint_TagEndPoint extends EndPoint {
    constructor(tags) {
        super();
        this.tags = tags;
    }
    _clone(cloneMap = undefined) {
        return new connection_constraint_TagEndPoint(this.tags);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareArrays(this.tags, other.tags, compareStrings)) !== 0)
            return cmp;
        return 0;
    }
    // TODO: nameMap is not used. Remove it?
    toString(nameMap = undefined) {
        return this.tags.map(a => `#${a}`).join(' ');
    }
}
//type EndPoint = ParticleEndPoint | InstanceEndPoint | HandleEndPoint | TagEndPoint;
class connection_constraint_ConnectionConstraint {
    constructor(fromConnection, toConnection, direction, relaxed, type) {
        external_assert_default()(direction);
        external_assert_default()(type);
        this.from = fromConnection;
        this.to = toConnection;
        this.direction = direction;
        this.relaxed = relaxed;
        this.type = type;
        Object.freeze(this);
    }
    _copyInto(recipe, cloneMap) {
        if (this.type === 'constraint') {
            if (this.from instanceof connection_constraint_InstanceEndPoint || this.to instanceof connection_constraint_InstanceEndPoint) {
                external_assert_default()(false, `Can't have connection constraints of type constraint with InstanceEndPoints`);
            }
            else {
                return recipe.newConnectionConstraint(this.from._clone(), this.to._clone(), this.direction, this.relaxed);
            }
        }
        return recipe.newObligation(this.from._clone(cloneMap), this.to._clone(cloneMap), this.direction, this.relaxed);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = this.from._compareTo(other.from)) !== 0)
            return cmp;
        if ((cmp = this.to._compareTo(other.to)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this.direction, other.direction)) !== 0)
            return cmp;
        if ((cmp = compareBools(this.relaxed, other.relaxed)) !== 0)
            return cmp;
        return 0;
    }
    toString(nameMap, options) {
        const subresults = [
            `${this.from.toString(nameMap)}:`,
            this.direction !== 'any' ? this.direction : '',
            this.relaxed ? RELAXATION_KEYWORD : '',
            this.to.toString(nameMap)
        ];
        if (options && options.showUnresolved === true && this.type === 'obligation') {
            subresults.push('// unresolved obligation');
        }
        return subresults.filter(s => s !== '').join(' ');
    }
}
//# sourceMappingURL=connection-constraint.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/internal/handle-connection.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */






class handle_connection_HandleConnection {
    constructor(name, particle) {
        this._tags = [];
        this.resolvedType = undefined;
        this._direction = 'any';
        this._relaxed = false;
        this._handle = undefined;
        external_assert_default()(particle);
        external_assert_default()(particle.recipe);
        this._recipe = particle.recipe;
        this._name = name;
        this._particle = particle;
    }
    get name() { return this._name; } // Parameter name?
    get recipe() { return this._recipe; }
    get isOptional() { return this.spec !== null && this.spec.isOptional; }
    get spec() {
        return this.particle.spec && this.particle.spec.handleConnectionMap.get(this.name);
    }
    get isInput() { return this.direction === 'reads' || this.direction === 'reads writes'; }
    get isOutput() { return this.direction === 'writes' || this.direction === 'reads writes'; }
    get handle() { return this._handle; } // Handle?
    get particle() { return this._particle; } // never null
    get relaxed() { return this._relaxed; }
    set relaxed(relaxed) { this._relaxed = relaxed; }
    get tags() { return this._tags; }
    set tags(tags) { this._tags = tags; }
    get type() {
        if (this.resolvedType) {
            return this.resolvedType;
        }
        const spec = this.spec;
        // TODO: We need a global way to generate variables so that everything can
        // have proper type bounds.
        return spec ? spec.type : undefined;
    }
    set type(type) {
        this.resolvedType = type;
        this._resetHandleType();
    }
    get direction() {
        // TODO: Should take the most strict of the direction and the spec direction.
        if (this._direction !== 'any') {
            return this._direction;
        }
        const spec = this.spec;
        return spec ? spec.direction : 'any';
    }
    set direction(direction) {
        if (direction === null) {
            throw new Error(`Invalid direction '${direction}' for handle connection '${this.getQualifiedName()}'`);
        }
        this._direction = direction;
        this._resetHandleType();
    }
    _clone(particle, cloneMap) {
        if (cloneMap.has(this)) {
            return cloneMap.get(this);
        }
        const handleConnection = new handle_connection_HandleConnection(this._name, particle);
        handleConnection._tags = [...this._tags];
        // Note: _resolvedType will be cloned later by the particle that references this connection.
        // Doing it there allows the particle to maintain variable associations across the particle
        // scope.
        handleConnection.resolvedType = this.resolvedType;
        handleConnection._direction = this._direction;
        handleConnection._relaxed = this._relaxed;
        if (this._handle != undefined) {
            handleConnection._handle = cloneMap.get(this._handle);
            external_assert_default()(handleConnection._handle !== undefined);
            handleConnection._handle.connections.push(handleConnection);
        }
        cloneMap.set(this, handleConnection);
        return handleConnection;
    }
    // Note: don't call this method directly, only called from particle cloning.
    cloneTypeWithResolutions(variableMap) {
        if (this.resolvedType) {
            this.resolvedType = this.resolvedType._cloneWithResolutions(variableMap);
        }
    }
    _normalize() {
        this._tags.sort();
        // TODO: type?
        Object.freeze(this);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareComparables(this._particle, other._particle)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this._name, other._name)) !== 0)
            return cmp;
        if ((cmp = compareArrays(this._tags, other._tags, compareStrings)) !== 0)
            return cmp;
        if ((cmp = compareComparables(this._handle, other._handle)) !== 0)
            return cmp;
        // TODO(cypher1): add type comparison
        // if ((cmp = compareStrings(this._type, other._type)) != 0) return cmp;
        if ((cmp = compareStrings(this._direction, other._direction)) !== 0)
            return cmp;
        if ((cmp = compareBools(this._relaxed, other._relaxed)) !== 0)
            return cmp;
        return 0;
    }
    getQualifiedName() { return `${this.particle.name}::${this.name}`; }
    toSlotConnection() {
        // TODO: Remove in SLANDLESv2
        if (!this.handle || this.handle.fate !== '`slot') {
            return undefined;
        }
        const slandle = new slot_connection_SlotConnection(this.name, this.particle);
        slandle.tags = this.tags;
        slandle.targetSlot = this.handle && this.handle.toSlot();
        slandle.targetSlot.name = slandle.targetSlot.name || this.name;
        if (this.spec) {
            this.spec.dependentConnections.forEach(connSpec => {
                const conn = this.particle.getConnectionByName(connSpec.name);
                if (!conn)
                    return;
                const slandleConn = conn.toSlotConnection();
                if (!slandleConn)
                    return;
                external_assert_default()(!slandle.providedSlots[conn.spec.name], `provided slot '${conn.spec.name}' already exists`);
                slandle.providedSlots[conn.spec.name] = slandleConn.targetSlot;
            });
        }
        return slandle;
    }
    _isValid(options) {
        // Note: The following casts are necessary to catch invalid values that typescript does not manage to check).
        if (this.direction === null || this.direction === undefined) {
            if (options && options.errors) {
                options.errors.set(this, `Invalid direction '${this.direction}' for handle connection '${this.getQualifiedName()}'`);
            }
            return false;
        }
        if (this.particle.spec && this.name) {
            const connectionSpec = this.spec;
            if (!connectionSpec) {
                if (options && options.errors) {
                    options.errors.set(this, `Connection ${this.name} is not defined by ${this.particle.name}.`);
                }
                return false;
            }
            if (!acceptedDirections(this.direction).includes(connectionSpec.direction)) {
                if (options && options.errors) {
                    options.errors.set(this, `Direction '${this.direction}' for handle connection '${this.getQualifiedName()}' doesn't match particle spec's direction '${connectionSpec.direction}'`);
                }
                return false;
            }
            if (this.resolvedType) {
                if (!connectionSpec.isCompatibleType(this.resolvedType)) {
                    if (options && options.errors) {
                        options.errors.set(this, `Type '${this.resolvedType.toString()} for handle connection '${this.getQualifiedName()}' doesn't match particle spec's type '${connectionSpec.type.toString()}'`);
                    }
                    return false;
                }
            }
            else {
                this.resolvedType = connectionSpec.type;
            }
        }
        return true;
    }
    isResolved(options) {
        external_assert_default()(Object.isFrozen(this));
        let parent;
        if (this.spec && this.spec.parentConnection) {
            parent = this.particle.connections[this.spec.parentConnection.name];
            if (!parent) {
                if (options) {
                    options.details = `parent connection '${this.spec.parentConnection.name}' missing`;
                }
                return false;
            }
            if (!parent.handle) {
                if (options) {
                    options.details = `parent connection '${this.spec.parentConnection.name}' missing handle`;
                }
                return false;
            }
        }
        if (!this.handle) {
            if (this.isOptional) {
                // We're optional we don't need to resolve.
                return true;
            }
            // We're not optional we do need to resolve.
            if (options) {
                options.details = 'missing handle';
            }
            return false;
        }
        if (!this.direction) {
            if (options) {
                options.details = 'missing direction';
            }
            return false;
        }
        // TODO: This should use this._type, or possibly not consider type at all.
        if (!this.type) {
            if (options) {
                options.details = 'missing type';
            }
            return false;
        }
        return true;
    }
    _resetHandleType() {
        if (this._handle) {
            this._handle._type = undefined;
        }
    }
    connectToHandle(handle) {
        external_assert_default()(handle.recipe === this.recipe);
        this._handle = handle;
        this._resetHandleType();
        this._handle.connections.push(this);
    }
    disconnectHandle() {
        const idx = this._handle.connections.indexOf(this);
        external_assert_default()(idx >= 0);
        this._handle.connections.splice(idx, 1);
        this._handle = undefined;
    }
    toString(nameMap, options) {
        const result = [];
        result.push(`${this.name || '*'}:`);
        // TODO(cypher1): support optionality.
        result.push(this.direction);
        result.push(this.relaxed ? RELAXATION_KEYWORD : '');
        if (this.handle) {
            if (this.handle.immediateValue) {
                result.push(this.handle.immediateValue.name);
            }
            else {
                result.push(`${(nameMap && nameMap.get(this.handle)) || this.handle.localName}`);
            }
        }
        result.push(...this.tags.map(a => `#${a}`));
        if (options && options.showUnresolved) {
            if (!this.isResolved(options)) {
                result.push(`// unresolved handle-connection: ${options.details}`);
            }
        }
        return result.filter(s => s !== '').join(' ');
    }
    // TODO: the logic is wrong :)
    findSpecsForUnnamedHandles() {
        return this.particle.spec.handleConnections.filter(specConn => {
            // filter specs with matching types that don't have handles bound to the corresponding handle connection.
            return !specConn.isOptional &&
                type_checker_TypeChecker.compareTypes({ type: this.handle.type }, { type: specConn.type }) &&
                !this.particle.getConnectionByName(specConn.name);
        });
    }
}
//# sourceMappingURL=handle-connection.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/internal/particle.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */





class internal_particle_Particle {
    constructor(recipe, name) {
        this._id = undefined;
        this._localName = undefined;
        this.spec = undefined;
        this._verbs = [];
        this._tags = [];
        this._connections = {};
        // TODO: replace with constraint connections on the recipe
        this._unnamedConnections = [];
        // map of consumed Slot connections by slot name.
        this._consumedSlotConnections = {};
        external_assert_default()(recipe);
        this._recipe = recipe;
        this._name = name;
    }
    _copyInto(recipe, cloneMap, variableMap) {
        const particle = recipe.newParticle(this._name);
        particle._id = this._id;
        particle._verbs = [...this._verbs];
        particle._tags = [...this._tags];
        particle.spec = this.spec ? this.spec.cloneWithResolutions(variableMap) : undefined;
        Object.keys(this._connections).forEach(key => {
            particle._connections[key] = this._connections[key]._clone(particle, cloneMap);
        });
        particle._unnamedConnections = this._unnamedConnections.map(connection => connection._clone(particle, cloneMap));
        particle._cloneConnectionRawTypes(variableMap);
        for (const key of this.getSlotConnectionNames()) {
            const slotConn = this.getSlotConnectionByName(key);
            particle._consumedSlotConnections[key] = slotConn._clone(particle, cloneMap);
            // if recipe is a requireSection, then slot may already exist in recipe.
            if (cloneMap.has(slotConn.targetSlot)) {
                external_assert_default()(recipe.isRequireSection);
                const targetSlot = cloneMap.get(slotConn.targetSlot);
                particle.getSlotConnectionByName(key).connectToSlot(targetSlot);
                if (particle.recipe.slots.indexOf(targetSlot) === -1) {
                    particle.recipe.slots.push(targetSlot);
                }
            }
            for (const [name, slot] of Object.entries(slotConn.providedSlots)) {
                if (cloneMap.has(slot)) {
                    external_assert_default()(recipe.isRequireSection);
                    const clonedSlot = cloneMap.get(slot);
                    clonedSlot.sourceConnection = particle.getSlotConnectionByName(key);
                    particle.getSlotConnectionByName(key).providedSlots[name] = clonedSlot;
                    if (particle.recipe.slots.indexOf(clonedSlot) === -1) {
                        particle.recipe.slots.push(clonedSlot);
                    }
                }
            }
        }
        return particle;
    }
    _cloneConnectionRawTypes(variableMap) {
        for (const connection of Object.values(this._connections)) {
            connection.cloneTypeWithResolutions(variableMap);
        }
        for (const connection of this._unnamedConnections) {
            connection.cloneTypeWithResolutions(variableMap);
        }
    }
    _startNormalize() {
        this._localName = null;
        this._verbs.sort();
        this._tags.sort();
        const normalizedConnections = {};
        for (const key of (Object.keys(this._connections).sort())) {
            normalizedConnections[key] = this._connections[key];
        }
        this._connections = normalizedConnections;
        const normalizedSlotConnections = {};
        for (const key of this.getSlotConnectionNames().sort()) {
            normalizedSlotConnections[key] = this.getSlotConnectionByName(key);
        }
        this._consumedSlotConnections = normalizedSlotConnections;
    }
    _finishNormalize() {
        this._unnamedConnections.sort(compareComparables);
        Object.freeze(this);
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareStrings(this._id ? this._id.toString() : '', other._id ? other._id.toString() : '')) !== 0)
            return cmp;
        if ((cmp = compareStrings(this._name, other._name)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this._localName, other._localName)) !== 0)
            return cmp;
        // TODO: spec?
        if ((cmp = compareArrays(this._verbs, other._verbs, compareStrings)) !== 0)
            return cmp;
        if ((cmp = compareArrays(this._tags, other._tags, compareStrings)) !== 0)
            return cmp;
        // TODO: slots
        return 0;
    }
    /**
     * Param particle matches this particle if the names are the same and the slot and handle requirements this particle
     * is a subset of the slot and handle requirements of the param particle.
     * @param particle
     */
    matches(particle) {
        if (this.name && particle.name && this.name !== particle.name)
            return false;
        for (const name of this.getSlotConnectionNames()) {
            const slotConn = this.getSlotConnectionByName(name);
            if (particle.getSlotConnectionByName(name) == undefined
                || particle.getSlotConnectionByName(name).targetSlot == undefined)
                return false;
            if (slotConn.targetSlot && slotConn.targetSlot.id && slotConn.targetSlot.id !== particle.getSlotConnectionByName(name).targetSlot.id)
                return false;
            for (const pname of Object.keys(slotConn.providedSlots)) {
                const slot = slotConn.providedSlots[pname];
                const pslot = particle.getSlotConnectionByName(name).providedSlots[pname];
                if (pslot == undefined || (slot.id && pslot.id && slot.id !== pslot.id))
                    return false;
            }
        }
        return true;
    }
    _isValid(options) {
        if (!this.spec) {
            return true;
        }
        if (!this.name && !this.primaryVerb) {
            // Must have either name of a verb
            if (options && options.errors) {
                options.errors.set(this, `Particle has no name and no verb`);
            }
            return false;
        }
        // TODO: What
        return true;
    }
    isResolved(options = undefined) {
        external_assert_default()(Object.isFrozen(this));
        if (!this.spec) {
            if (options && options.showUnresolved) {
                options.details = 'missing spec';
            }
            return false;
        }
        const slandleConnections = Object.values(this.connections).filter(connection => Boolean(connection.type.slandleType()));
        if (slandleConnections.length === 0 && this.spec.slotConnections.size > 0) {
            const fulfilledSlotConnections = this.getSlotConnections().filter(connection => connection.targetSlot !== undefined);
            if (fulfilledSlotConnections.length === 0) {
                if (options && options.showUnresolved) {
                    options.details = `unfulfilled slot connections ${JSON.stringify([...this.spec.slotConnections])}`;
                }
                return false;
            }
        }
        if (!this.spec) {
            if (options && options.showUnresolved) {
                options.details = 'missing spec';
            }
            return false;
        }
        const unresolvedRequiredConnections = this.getUnboundConnections().filter(connSpec => {
            // A non-optional connection dependent on an optional and unresolved is ok.
            let parent = connSpec.parentConnection;
            while (parent !== null) {
                if (!this.connections[parent.name]) {
                    return false;
                }
                parent = parent.parentConnection;
            }
            return true;
        });
        if (unresolvedRequiredConnections.length > 0) {
            if (options && options.showUnresolved) {
                options.details = `unresolved connections: ${unresolvedRequiredConnections.map(c => c.name).join(', ')}`;
            }
            return false;
        }
        if (this.unnamedConnections.length !== 0) {
            if (options && options.showUnresolved) {
                options.details = `${this.unnamedConnections.length} unnamed connections`;
            }
            return false;
        }
        return true;
    }
    get recipe() { return this._recipe; }
    get localName() { return this._localName; }
    set localName(name) { this._localName = name; }
    get id() { return this._id; } // Not resolved until we have an ID.
    set id(id) { external_assert_default()(!this._id, 'Particle ID can only be set once.'); this._id = id; }
    get name() { return this._name; }
    set name(name) { this._name = name; }
    get connections() { return this._connections; } // {parameter -> HandleConnection}
    get unnamedConnections() { return this._unnamedConnections; } // HandleConnection*
    get primaryVerb() { return (this._verbs.length > 0) ? this._verbs[0] : undefined; }
    set verbs(verbs) { this._verbs = verbs; }
    set tags(tags) { this._tags = tags; }
    addUnnamedConnection() {
        const connection = new handle_connection_HandleConnection(undefined, this);
        this._unnamedConnections.push(connection);
        return connection;
    }
    addConnectionName(name) {
        external_assert_default()(name, `Cannot create connection with no name`);
        external_assert_default()(this._connections[name] == undefined, `Cannot add connection ${name}: connection already exists`);
        this._connections[name] = new handle_connection_HandleConnection(name, this);
        return this._connections[name];
    }
    allConnections() {
        return Object.values(this._connections).concat(this._unnamedConnections);
    }
    ensureConnectionName(name) {
        return this._connections[name] || this.addConnectionName(name);
    }
    getSlotConnectionNames() {
        return Object.keys(this._consumedSlotConnections);
    }
    getSlandleConnectionByName(name) {
        if (name in this._connections) {
            const slandle = this._connections[name].toSlotConnection();
            return slandle;
        }
        return this._consumedSlotConnections[name];
    }
    getSlandleConnectionBySpec(spec) {
        return this.getSlandleConnections().find(slotConn => slotConn.getSlotSpec() === spec);
    }
    getSlotConnectionByName(name) {
        return this._consumedSlotConnections[name];
    }
    getSlandleConnections() {
        // TODO(jopra): Revisit when slots are removed.
        return [...Object.values(this._consumedSlotConnections), ...this.allConnections().map(conn => conn.direction === '`consumes' && conn.toSlotConnection()).filter(conn => conn)];
    }
    getSlotConnections() {
        // TODO(jopra): Revisit when slots are removed.
        return Object.values(this._consumedSlotConnections);
    }
    getSlotSpecByName(name) {
        if (!this.spec)
            return undefined;
        const slot = this.spec.slotConnections.get(name);
        if (slot)
            return slot;
        // TODO(jopra): Provided slots should always be listed in the particle spec.
        for (const slot of this.spec.slotConnections.values()) {
            for (const provided of slot.provideSlotConnections) {
                if (provided.name === name)
                    return provided;
            }
        }
        return undefined;
    }
    getProvidedSlotByName(consumeName, name) {
        const conn = this.getSlotConnectionByName(consumeName);
        return conn && conn.providedSlots[name];
    }
    getUnboundSlotConnections() {
        if (this.spec) {
            return [...this.spec.slotConnections.entries()]
                .filter(([name, _]) => this._consumedSlotConnections[name] == undefined)
                .map(([_, spec]) => spec);
        }
        return [];
    }
    getConnectionByName(name) {
        return this._connections[name];
    }
    nameConnection(connection, name) {
        external_assert_default()(!this._connections[name], `Connection "${name}" already has a handle`);
        const idx = this._unnamedConnections.indexOf(connection);
        external_assert_default()(idx >= 0, `Cannot name '${name}' nonexistent unnamed connection.`);
        // TODO: FIX: The following is accessing a readonly field illegally.
        // tslint:disable-next-line: no-any
        connection._name = name;
        const connectionSpec = this.spec.getConnectionByName(name);
        connection.type = connectionSpec.type;
        if (connection.direction !== connectionSpec.direction) {
            external_assert_default()(connection.direction === 'reads writes', `Unnamed connection cannot adjust direction ${connection.direction} to ${name}'s direction ${connectionSpec.direction}`);
            connection.direction = connectionSpec.direction;
        }
        this._connections[name] = connection;
        this._unnamedConnections.splice(idx, 1);
    }
    getUnboundConnections(type) {
        return this.spec.handleConnections.filter(connSpec => !connSpec.isOptional &&
            !this.getConnectionByName(connSpec.name) &&
            (!type || type_checker_TypeChecker.compareTypes({ type }, { type: connSpec.type })));
    }
    addSlotConnection(name) {
        external_assert_default()(!this.getSlotConnectionByName(name), 'slot connection already exists');
        const slandle = this.spec && this.spec.connections.find(conn => conn.name === name);
        const isSlandle = slandle && slandle.type.isSlot();
        const isSetSlandle = slandle && slandle.type.isCollectionType() && slandle.type.getContainedType().isSlot();
        external_assert_default()(!this.spec || this.spec.slotConnections.has(name) || isSlandle || isSetSlandle, `slot connection '${name}' is not in particle spec`);
        const slotConn = this.addSlotConnectionAsCopy(name);
        const slotSpec = this.getSlotSpecByName(name);
        if (slotSpec) {
            slotSpec.provideSlotConnections.forEach(providedSlot => {
                const slot = this.recipe.newSlot(providedSlot.name);
                slot.sourceConnection = slotConn;
                slotConn.providedSlots[providedSlot.name] = slot;
                // TODO: hook the handles up
            });
        }
        return slotConn;
    }
    addSlotConnectionAsCopy(name) {
        // Called when a recipe and all of it's contents are being cloned.
        // Each slot connection in the existing recipe has to be created for the clone,
        // This method must not create slots for provided slot connections otherwise there
        // will be duplicate slots.
        const slotConn = new slot_connection_SlotConnection(name, this);
        this._consumedSlotConnections[name] = slotConn;
        return slotConn;
    }
    removeSlotConnection(slotConnection) {
        this._consumedSlotConnections[slotConnection.name] = null;
        slotConnection.disconnectFromSlot();
    }
    remove() {
        this.recipe.removeParticle(this);
    }
    isExternalParticle() {
        return this.spec && this.spec.external;
    }
    toString(options = {}, nameMap) {
        let result = [];
        // TODO: we need at least name or verb(s)
        if (this.name) {
            result.push(this.name);
            result.push(`as ${(nameMap && nameMap.get(this)) || this.localName}`);
            if (this.primaryVerb && this.primaryVerb !== this.name) {
                result.push(`// verb=${this.primaryVerb}`);
            }
        }
        else { // verb must exist, if there is no name.
            result.push(`&${this.primaryVerb}`);
        }
        if (options.showUnresolved) {
            if (!this.isResolved(options)) {
                result.push(`// unresolved particle: ${options.details}`);
            }
        }
        result = [result.join(' ')];
        for (const connection of this.unnamedConnections) {
            result.push(connection.toString(nameMap, options).replace(/^|(\n)/g, '$1  '));
        }
        for (const connection of Object.values(this.connections)) {
            result.push(connection.toString(nameMap, options).replace(/^|(\n)/g, '$1  '));
        }
        for (const slotConnection of this.getSlotConnections()) {
            result.push(slotConnection.toString(nameMap, options).replace(/^|(\n)/g, '$1  '));
        }
        return result.join('\n');
    }
}
//# sourceMappingURL=particle.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/internal/search.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

class search_Search {
    constructor(phrase, unresolvedTokens) {
        external_assert_default()(phrase);
        this._phrase = phrase;
        const tokens = this.phrase.toLowerCase().split(/[^a-z0-9]/g);
        // If unresolvedTokens not passed, consider all tokens unresolved.
        this._unresolvedTokens = [];
        (unresolvedTokens || tokens).forEach(token => this._unresolvedTokens.push(token));
        // compute the resolved tokens
        this._resolvedTokens = tokens.slice();
        for (const token of this.unresolvedTokens) {
            const index = this._resolvedTokens.indexOf(token);
            if (index >= 0) {
                this._resolvedTokens.splice(index, 1);
            }
        }
        external_assert_default()(tokens.length === this.unresolvedTokens.length + this.resolvedTokens.length);
    }
    _append(phrase, unresolvedTokens, resolvedTokens) {
        // concat phrase
        if (this._phrase.length > 0) {
            this._phrase = this.phrase.concat(' ');
        }
        this._phrase = this._phrase.concat(phrase);
        resolvedTokens.forEach(t => this._resolvedTokens.push(t));
        unresolvedTokens.forEach(t => this._unresolvedTokens.push(t));
    }
    get phrase() { return this._phrase; }
    get unresolvedTokens() { return this._unresolvedTokens; }
    get resolvedTokens() { return this._resolvedTokens; }
    resolveToken(token) {
        const index = this.unresolvedTokens.indexOf(token.toLowerCase());
        external_assert_default()(index >= 0, `Cannot resolved nonexistent token ${token}`);
        this._unresolvedTokens.splice(index, 1);
        this._resolvedTokens.push(token.toLowerCase());
    }
    isValid() {
        return this._unresolvedTokens.length > 0 || this._resolvedTokens.length > 0;
    }
    isResolved() {
        external_assert_default()(Object.isFrozen(this));
        // Recipe is considered resolved, if at least one of the search tokens was resolved.
        // TODO: Unresolved tokens don't prevent the recipe from being resolved. For now...
        return this._resolvedTokens.length > 0;
    }
    _normalize() {
        this._unresolvedTokens.sort();
        this._resolvedTokens.sort();
        Object.freeze(this);
    }
    _copyInto(recipe) {
        if (recipe.search) {
            recipe.search._append(this.phrase, this.unresolvedTokens, this.resolvedTokens);
        }
        else {
            recipe.search = new search_Search(this.phrase, this.unresolvedTokens);
            external_assert_default()(recipe.search.resolvedTokens.length === this.resolvedTokens.length, `${recipe.search.resolvedTokens} is not same as ${this.resolvedTokens}`);
        }
        external_assert_default()(this.resolvedTokens.every(rt => recipe.search.resolvedTokens.indexOf(rt) >= 0) &&
            this.unresolvedTokens.every(rt => recipe.search.unresolvedTokens.indexOf(rt) >= 0));
        return recipe.search;
    }
    toString(options) {
        const result = [];
        result.push(`search \`${this.phrase}\``);
        const tokenStr = [];
        tokenStr.push('  tokens');
        if (this.unresolvedTokens.length > 0) {
            tokenStr.push(this.unresolvedTokens.map(t => `\`${t}\``).join(' '));
        }
        if (this.resolvedTokens.length > 0) {
            tokenStr.push(`// ${this.resolvedTokens.map(t => `\`${t}\``).join(' ')}`);
        }
        if (options && options.showUnresolved) {
            if (this.unresolvedTokens.length > 0) {
                tokenStr.push('// unresolved search tokens');
            }
        }
        result.push(tokenStr.join(' '));
        return result.join('\n');
    }
}
//# sourceMappingURL=search.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/internal/recipe.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */











class recipe_Recipe {
    constructor(name) {
        this._requires = [];
        this._particles = [];
        this._handles = [];
        this._slots = [];
        this._localName = undefined;
        this._policy = null;
        this._annotations = [];
        // TODO: Recipes should be collections of records that are tagged
        // with a type. Strategies should register the record types they
        // can handle. ConnectionConstraints should be a different record
        // type to particles/handles.
        this._connectionConstraints = [];
        // Obligations are like connection constraints in that they describe
        // required connections between particles/verbs. However, where
        // connection constraints can be acted upon in order to create these
        // connections, obligations can't be. Instead, they describe requirements
        // that must be discharged before a recipe can be considered to be
        // resolved.
        this._obligations = [];
        this._verbs = [];
        // TODO: Change to array, if needed for search strings of merged recipes.
        this._search = null;
        this._patterns = [];
        this.isRequireSection = false;
        this._name = name;
    }
    newConnectionConstraint(from, to, direction, relaxed) {
        const result = new connection_constraint_ConnectionConstraint(from, to, direction, relaxed, 'constraint');
        this._connectionConstraints.push(result);
        return result;
    }
    newObligation(from, to, direction, relaxed) {
        const result = new connection_constraint_ConnectionConstraint(from, to, direction, relaxed, 'obligation');
        this._obligations.push(result);
        return result;
    }
    removeObligation(obligation) {
        const idx = this._obligations.indexOf(obligation);
        external_assert_default()(idx > -1);
        this._obligations.splice(idx, 1);
    }
    removeConstraint(constraint) {
        const idx = this._connectionConstraints.indexOf(constraint);
        external_assert_default()(idx >= 0);
        this._connectionConstraints.splice(idx, 1);
    }
    clearConnectionConstraints() {
        this._connectionConstraints.length = 0; // truncate
    }
    newRequireSection() {
        const require = new RequireSection(this);
        this._requires.push(require);
        return require;
    }
    newParticle(name) {
        const particle = new internal_particle_Particle(this, name);
        this._particles.push(particle);
        return particle;
    }
    removeParticle(particle) {
        const idx = this._particles.indexOf(particle);
        external_assert_default()(idx > -1);
        this._particles.splice(idx, 1);
        particle.getSlotConnections().forEach(conn => conn.remove());
    }
    newHandle() {
        const handle = new internal_handle_Handle(this);
        this._handles.push(handle);
        return handle;
    }
    removeHandle(handle) {
        external_assert_default()(handle.connections.length === 0);
        const idx = this._handles.indexOf(handle);
        external_assert_default()(idx > -1);
        this._handles.splice(idx, 1);
    }
    newSlot(name) {
        const slot = new slot_Slot(this, name);
        this._slots.push(slot);
        return slot;
    }
    addSlot(slot) {
        if (this.slots.indexOf(slot) === -1) {
            this.slots.push(slot);
        }
    }
    removeSlot(slot) {
        external_assert_default()(slot.consumeConnections.length === 0);
        let idx = this._slots.indexOf(slot);
        external_assert_default()(idx > -1);
        this._slots.splice(idx, 1);
        for (const requires of this.requires) {
            idx = requires.slots.indexOf(slot);
            if (idx !== -1) {
                requires.slots.splice(idx, 1);
            }
        }
    }
    isResolved(options) {
        external_assert_default()(Object.isFrozen(this), 'Recipe must be normalized to be resolved.');
        const checkThat = (check, label) => {
            if (!check && options && options.errors) {
                options.errors.set(this.name, label);
            }
            return check;
        };
        return checkThat(this._obligations.length === 0, 'unresolved obligations')
            && checkThat(this._connectionConstraints.length === 0, 'unresolved constraints')
            && checkThat(this.requires.every(require => require.isEmpty()), 'unresolved require')
            && checkThat((this._search === null || this._search.isResolved()), 'unresolved search')
            && checkThat(this._handles.every(handle => handle.isResolved()), 'unresolved handles')
            && checkThat(this._particles.every(particle => particle.isResolved(options)), 'unresolved particles')
            && checkThat(this.modality.isResolved(), 'unresolved modality')
            && checkThat(this.allRequiredSlotsPresent(options), 'unresolved required slot')
            && checkThat(this._slots.every(slot => slot.isResolved()), 'unresolved slots')
            && checkThat(this.handleConnections.every(connection => connection.isResolved(options)), 'unresolved handle connections')
            && checkThat(this.slotConnections.every(slotConnection => slotConnection.isResolved(options)), 'unresolved slot connections');
        // TODO: check recipe level resolution requirements, eg there is no slot loops.
    }
    isCompatible(modality) {
        return this.particles.every(p => !p.spec || p.spec.isCompatible(modality));
    }
    get modality() {
        return modality_Modality.intersection(this.particles.filter(p => Boolean(p.spec && p.spec.slandleConnectionNames().length > 0)).map(p => p.spec.modality));
    }
    allRequiredSlotsPresent(options = undefined) {
        // All required slots and at least one consume slot for each particle must be present in order for the
        // recipe to be considered resolved.
        for (const particle of this.particles) {
            if (particle.spec.slotConnections.size === 0) {
                continue;
            }
            let atLeastOneSlotConnection = false;
            let usesSlandles = false;
            for (const handleSpec of Object.values(particle.spec.connections)) {
                if (handleSpec.type.slandleType()) {
                    usesSlandles = true;
                }
            }
            for (const [name, slotSpec] of particle.spec.slotConnections) {
                if (slotSpec.isRequired && !particle.getSlotConnectionByName(name)) {
                    if (options && options.errors) {
                        options.errors.set(name, `required slot ${name} has no matching connection`);
                    }
                    return false;
                }
                // required provided slots are only required when the corresponding consume slot connection is present
                if (particle.getSlotConnectionByName(name)) {
                    atLeastOneSlotConnection = true;
                    for (const providedSlotSpec of slotSpec.provideSlotConnections) {
                        if (providedSlotSpec.isRequired && !particle.getProvidedSlotByName(name, providedSlotSpec.name)) {
                            if (options && options.errors) {
                                options.errors.set(name, `required provided slot ${providedSlotSpec.name} has no matching connection`);
                            }
                            return false;
                        }
                    }
                }
            }
            // TODO: Remove check for slots in SLANDLESv2
            if (!usesSlandles && !atLeastOneSlotConnection) {
                if (options && options.errors) {
                    options.errors.set(`?`, `no slot connections`);
                }
                return false;
            }
        }
        return true;
    }
    _findDuplicate(items, options) {
        const seenHandles = new Set();
        const duplicateHandle = items.find(handle => {
            if (handle.id) {
                if (seenHandles.has(handle.id)) {
                    return handle;
                }
                seenHandles.add(handle.id);
            }
        });
        if (duplicateHandle && options && options.errors) {
            options.errors.set(duplicateHandle, `Has Duplicate ${duplicateHandle instanceof internal_handle_Handle ? 'Handle' : 'Slot'} '${duplicateHandle.id}'`);
        }
        return duplicateHandle;
    }
    _isValid(options = undefined) {
        const checkAllValid = (list) => list.every(item => item._isValid(options));
        return !this._findDuplicate(this._handles, options)
            && !this._findDuplicate(this._slots, options)
            && checkAllValid(this._handles)
            && checkAllValid(this._particles)
            && checkAllValid(this._slots)
            && checkAllValid(this.handleConnections)
            && checkAllValid(this.slotConnections)
            && (!this.search || this.search.isValid());
    }
    get requires() { return this._requires; }
    get name() { return this._name; }
    set name(name) { this._name = name; }
    get localName() { return this._localName; }
    set localName(name) { this._localName = name; }
    get particles() { return this._particles; }
    set particles(particles) { this._particles = particles; }
    get handles() { return this._handles; }
    set handles(handles) { this._handles = handles; }
    get slots() { return this._slots; }
    set slots(slots) { this._slots = slots; }
    get connectionConstraints() { return this._connectionConstraints; }
    get obligations() { return this._obligations; }
    get verbs() { return this._verbs; }
    set verbs(verbs) { this._verbs = verbs; }
    get search() { return this._search; }
    set search(search) {
        this._search = search;
    }
    setSearchPhrase(phrase) {
        external_assert_default()(!this._search, 'Cannot override search phrase');
        if (phrase) {
            this._search = new search_Search(phrase);
        }
    }
    get slotConnections() {
        // TODO: Is this the correct api?
        const slotConnections = [];
        this._particles.forEach(particle => {
            slotConnections.push(...particle.getSlotConnections());
        });
        return slotConnections;
    }
    get handleConnections() {
        const handleConnections = [];
        this._particles.forEach(particle => {
            handleConnections.push(...Object.values(particle.connections));
            handleConnections.push(...particle._unnamedConnections);
        });
        return handleConnections;
    }
    get annotations() { return this._annotations; }
    set annotations(annotations) {
        annotations.every(a => external_assert_default()(a.isValidForTarget('Recipe'), `Annotation '${a.name}' is invalid for Recipe`));
        this._annotations = annotations;
    }
    getAnnotation(name) {
        const annotations = this.findAnnotations(name);
        external_assert_default()(annotations.length <= 1, `Multiple annotations found for '${name}'. Use findAnnotations instead.`);
        return annotations.length === 0 ? null : annotations[0];
    }
    findAnnotations(name) {
        return this.annotations.filter(a => a.name === name);
    }
    /** The name of the policy with which this recipe must comply. */
    get policyName() {
        const policyAnnotation = this.getAnnotation('policy');
        if (policyAnnotation == null) {
            return null;
        }
        const policyName = policyAnnotation.params['name'];
        external_assert_default()(policyName, `You must provide a policy name in the @policy annotation.`);
        return policyName;
    }
    set policy(policy) {
        const policyName = this.policyName;
        external_assert_default()(policy.name === policyName, `Expected policy with name '${policyName}' but policy was named '${policy.name}'.`);
        this._policy = policy;
    }
    get policy() {
        return this._policy;
    }
    isEmpty() {
        return this.particles.length === 0 &&
            this.handles.length === 0 &&
            this.slots.length === 0 &&
            this._connectionConstraints.length === 0;
    }
    findSlot(id) {
        for (const slot of this.slots) {
            if (slot.id === id) {
                return slot;
            }
        }
        return null;
    }
    findParticle(id) {
        for (const particle of this.particles) {
            if (particle.id.toString() === id) {
                return particle;
            }
        }
        return null;
    }
    get patterns() {
        return this._patterns;
    }
    set patterns(patterns) {
        this._patterns = patterns;
    }
    set description(description) {
        const pattern = description.find(desc => desc.name === 'pattern');
        if (pattern) {
            pattern.patterns.forEach(pattern => this._patterns.push(pattern));
        }
        description.forEach(desc => {
            if (desc.name !== 'pattern') {
                const handle = this.handles.find(handle => handle.localName === desc.name);
                external_assert_default()(handle, `Cannot set description pattern for nonexistent handle ${desc.name}.`);
                handle.pattern = desc.pattern;
            }
        });
    }
    async digest() {
        return digest(this.toString());
    }
    normalize(options) {
        if (Object.isFrozen(this)) {
            if (options && options.errors) {
                options.errors.set(this, 'already normalized');
            }
            return false;
        }
        if (!this._isValid()) {
            this._findDuplicate(this._handles, options);
            this._findDuplicate(this._slots, options);
            const checkForInvalid = (list) => list.forEach(item => !item._isValid(options));
            // We resolve the type of the regular handles first,
            // so that we can use it to resolve the type of synethetic handles later.
            checkForInvalid(this._handles.filter(h => !h.isSynthetic));
            checkForInvalid(this._handles.filter(h => h.isSynthetic));
            checkForInvalid(this._particles);
            checkForInvalid(this._slots);
            checkForInvalid(this.handleConnections);
            checkForInvalid(this.slotConnections);
            return false;
        }
        // Get handles and particles ready to sort connections.
        for (const particle of this._particles) {
            particle._startNormalize();
        }
        for (const handle of this._handles) {
            handle._startNormalize();
        }
        for (const slot of this._slots) {
            slot._startNormalize();
        }
        // Sort and normalize handle connections.
        const connections = this.handleConnections;
        for (const connection of connections) {
            connection._normalize();
        }
        connections.sort(compareComparables);
        // Sort and normalize slot connections.
        const slotConnections = this.slotConnections;
        for (const slotConnection of slotConnections) {
            slotConnection._normalize();
        }
        slotConnections.sort(compareComparables);
        if (this.search) {
            this.search._normalize();
        }
        for (const require of this.requires) {
            require.normalize();
        }
        // Finish normalizing particles and handles with sorted connections.
        for (const particle of this._particles) {
            particle._finishNormalize();
        }
        for (const handle of this._handles) {
            handle._finishNormalize();
        }
        for (const slot of this._slots) {
            slot._finishNormalize();
        }
        const seenHandles = new Set();
        const seenParticles = new Set();
        const seenSlots = new Set();
        const particles = [];
        const handles = [];
        const slots = [];
        // Reorder connections so that interfaces come last.
        // TODO: update handle-connection comparison method instead?
        let ordered = connections.filter(c => !c.type || !(c.type instanceof type_InterfaceType));
        ordered = ordered.concat(connections.filter(c => !!c.type && !!(c.type instanceof type_InterfaceType)));
        for (const connection of ordered) {
            if (!seenParticles.has(connection.particle)) {
                particles.push(connection.particle);
                seenParticles.add(connection.particle);
            }
            if (connection.handle && !seenHandles.has(connection.handle)) {
                handles.push(connection.handle);
                seenHandles.add(connection.handle);
            }
        }
        for (const slotConnection of slotConnections) {
            if (slotConnection.targetSlot && !seenSlots.has(slotConnection.targetSlot)) {
                slots.push(slotConnection.targetSlot);
                seenSlots.add(slotConnection.targetSlot);
            }
            Object.values(slotConnection.providedSlots).forEach(ps => {
                if (!seenSlots.has(ps)) {
                    slots.push(ps);
                    seenSlots.add(ps);
                }
            });
        }
        const orphanedHandles = this._handles.filter(handle => !seenHandles.has(handle));
        orphanedHandles.sort(compareComparables);
        handles.push(...orphanedHandles);
        const orphanedParticles = this._particles.filter(particle => !seenParticles.has(particle));
        orphanedParticles.sort(compareComparables);
        particles.push(...orphanedParticles);
        const orphanedSlots = this._slots.filter(slot => !seenSlots.has(slot));
        orphanedSlots.sort(compareComparables);
        slots.push(...orphanedSlots);
        // Put particles and handles in their final ordering.
        this._particles = particles;
        this._handles = handles;
        this._slots = slots;
        this._connectionConstraints.sort(compareComparables);
        this._verbs.sort();
        this._patterns.sort();
        Object.freeze(this._particles);
        Object.freeze(this._handles);
        Object.freeze(this._slots);
        Object.freeze(this._connectionConstraints);
        Object.freeze(this);
        return true;
    }
    clone(map = undefined) {
        // for now, just copy everything
        const recipe = new recipe_Recipe(this.name);
        if (map == undefined) {
            map = new Map();
        }
        this._copyInto(recipe, map);
        // TODO: figure out a better approach than stashing the cloneMap permanently
        // on the recipe
        recipe._cloneMap = map;
        return recipe;
    }
    // tslint:disable-next-line: no-any
    mergeInto(recipe) {
        const cloneMap = new Map();
        const numHandles = recipe._handles.length;
        const numParticles = recipe._particles.length;
        const numSlots = recipe._slots.length;
        this._copyInto(recipe, cloneMap);
        return {
            handles: recipe._handles.slice(numHandles),
            particles: recipe._particles.slice(numParticles),
            slots: recipe._slots.slice(numSlots),
            cloneMap
        };
    }
    _copyInto(recipe, cloneMap) {
        const variableMap = new Map();
        const cloneTheThing = (ob) => {
            const clonedObject = ob._copyInto(recipe, cloneMap, variableMap);
            cloneMap.set(ob, clonedObject);
        };
        recipe._name = this.name;
        recipe.annotations = this.annotations;
        recipe._verbs = recipe._verbs.concat(...this._verbs);
        // Clone regular handles first, then synthetic ones, as synthetic depend on regular.
        this._handles.filter(h => !h.isSynthetic).forEach(cloneTheThing);
        this._handles.filter(h => h.isSynthetic).forEach(cloneTheThing);
        this._particles.forEach(cloneTheThing);
        this._slots.forEach(cloneTheThing);
        this._connectionConstraints.forEach(cloneTheThing);
        this._obligations.forEach(cloneTheThing);
        recipe.verbs = recipe.verbs.slice();
        if (this.search) {
            this.search._copyInto(recipe);
        }
        for (const require of this.requires) {
            const newRequires = recipe.newRequireSection();
            require._copyInto(newRequires, cloneMap);
            newRequires._cloneMap = cloneMap;
        }
        recipe.patterns = recipe.patterns.concat(this.patterns);
    }
    updateToClone(dict) {
        const result = {};
        Object.keys(dict).forEach(key => result[key] = this._cloneMap.get(dict[key]));
        return result;
    }
    _makeLocalNameMap() {
        const names = new Set([...this.particles,
            ...this.handles,
            ...this.slots].map((item) => item.localName));
        let i;
        const nameMap = new Map();
        const mapName = (item, prefix) => {
            let localName = item.localName;
            if (!localName) {
                do {
                    localName = `${prefix}${i++}`;
                } while (names.has(localName));
            }
            nameMap.set(item, localName);
        };
        i = 0;
        this.particles.forEach(particle => mapName(particle, 'particle'));
        i = 0;
        this.handles.forEach(handle => mapName(handle, 'handle'));
        i = 0;
        this.slots.forEach(slot => mapName(slot, 'slot'));
        return nameMap;
    }
    // TODO: Add a normalize() which strips local names and puts and nested
    //       lists into a normal ordering.
    //
    // use { showUnresolved: true } in options to see why a recipe can't resolve.
    toString(options) {
        const nameMap = this._makeLocalNameMap();
        const result = [];
        for (const annotation of this.annotations) {
            result.push(annotation.toString());
        }
        const verbs = this.verbs.length > 0 ? ` ${this.verbs.map(verb => `&${verb}`).join(' ')}` : '';
        result.push(`recipe${this.name ? ` ${this.name}` : ''}${verbs}`);
        if (options && options.showUnresolved) {
            if (this.search) {
                result.push(this.search.toString(options).replace(/^|(\n)/g, '$1  '));
            }
        }
        for (const constraint of this._connectionConstraints) {
            let constraintStr = constraint.toString().replace(/^|(\n)/g, '$1  ');
            if (options && options.showUnresolved) {
                constraintStr = constraintStr.concat(' // unresolved connection-constraint');
            }
            result.push(constraintStr);
        }
        result.push(...this.handles
            .map(h => h.toString(options, nameMap))
            .filter(strValue => strValue)
            .map(strValue => strValue.replace(/^|(\n)/g, '$1  ')));
        for (const slot of this.slots) {
            const slotString = slot.toString(options, nameMap);
            if (slotString) {
                result.push(slotString.replace(/^|(\n)/g, '$1  '));
            }
        }
        for (const require of this.requires) {
            if (!require.isEmpty())
                result.push(require.toString(options, nameMap).replace(/^|(\n)/g, '$1  '));
        }
        for (const particle of this.particles) {
            result.push(particle.toString(options, nameMap).replace(/^|(\n)/g, '$1  '));
        }
        if (this.patterns.length > 0 || this.handles.find(h => h.pattern !== undefined)) {
            result.push(`  description \`${this.patterns[0]}\``);
            for (let i = 1; i < this.patterns.length; ++i) {
                result.push(`    pattern \`${this.patterns[i]}\``);
            }
            this.handles.forEach(h => {
                if (h.pattern) {
                    result.push(`    ${h.localName} \`${h.pattern}\``);
                }
            });
        }
        if (this._obligations.length > 0) {
            result.push('  obligations');
            for (const obligation of this._obligations) {
                const obligationStr = obligation.toString(nameMap).replace(/^|(\n)/g, '$1    ');
                result.push(obligationStr);
            }
        }
        return result.join('\n');
    }
    getFreeHandles() {
        return this.handles.filter(handle => handle.connections.length === 0);
    }
    get allSpecifiedConnections() {
        return [].concat(...this.particles.filter(p => p.spec && p.spec.connections).map(particle => particle.spec.connections.map(connSpec => ({ particle, connSpec }))));
    }
    getFreeConnections(type) {
        // TODO(jopra): Check that this works for required connections that are
        // dependent on optional connections.
        return this.allSpecifiedConnections.filter(({ particle, connSpec }) => connSpec.name !== 'descriptions' &&
            connSpec.direction !== 'hosts' &&
            !particle.connections[connSpec.name] &&
            (!type || type_checker_TypeChecker.compareTypes({ type }, { type: connSpec.type })));
    }
    findHandleByID(id) {
        return this.handles.find(handle => handle.id === id);
    }
    getUnnamedUntypedConnections() {
        return this.handleConnections.find(hc => !hc.type || !hc.name || hc.isOptional);
    }
    getParticlesByImplFile(files) {
        return this.particles.filter(particle => particle.spec && files.has(particle.spec.implFile));
    }
    // overridded by RequireSection
    findSlotByID(id) {
        let slot = this.slots.find(s => s.id === id);
        if (slot === undefined) {
            for (const require of this.requires) {
                slot = require.slots.find(s => s.id === id);
                if (slot !== undefined)
                    break;
            }
        }
        return slot;
    }
}
class RequireSection extends recipe_Recipe {
    constructor(parent, name) {
        super(name);
        this.isRequireSection = true;
        this.parent = parent;
    }
    findSlotByID(id) {
        let slot = this.slots.find(s => s.id === id);
        if (slot === undefined) {
            slot = this.parent.slots.find(s => s.id === id);
        }
        return slot;
    }
    toString(options = {}, nameMap) {
        if (nameMap == undefined) {
            nameMap = this._makeLocalNameMap();
        }
        const result = [];
        result.push(`require`);
        if (options.showUnresolved) {
            if (this.search) {
                result.push(this.search.toString(options).replace(/^|(\n)/g, '$1  '));
            }
        }
        for (const constraint of this.connectionConstraints) {
            let constraintStr = constraint.toString().replace(/^|(\n)/g, '$1  ');
            if (options.showUnresolved) {
                constraintStr = constraintStr.concat(' // unresolved connection-constraint');
            }
            result.push(constraintStr);
        }
        result.push(...this.handles
            .map(h => h.toString(options, nameMap))
            .filter(strValue => strValue)
            .map(strValue => strValue.replace(/^|(\n)/g, '$1  ')));
        for (const slot of this.slots) {
            const slotString = slot.toString(options, nameMap);
            if (slotString) {
                result.push(slotString.replace(/^|(\n)/g, '$1  '));
            }
        }
        for (const particle of this.particles) {
            result.push(particle.toString(options, nameMap).replace(/^|(\n)/g, '$1  '));
        }
        if (this.patterns.length > 0 || this.handles.find(h => h.pattern !== undefined)) {
            result.push(`  description \`${this.patterns[0]}\``);
            for (let i = 1; i < this.patterns.length; ++i) {
                result.push(`    pattern \`${this.patterns[i]}\``);
            }
            this.handles.forEach(h => {
                if (h.pattern) {
                    result.push(`    ${h.localName} \`${h.pattern}\``);
                }
            });
        }
        if (this.obligations.length > 0) {
            result.push('  obligations');
            for (const obligation of this.obligations) {
                const obligationStr = obligation.toString(nameMap).replace(/^|(\n)/g, '$1    ');
                result.push(obligationStr);
            }
        }
        return result.join('\n');
    }
}
//# sourceMappingURL=recipe.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/internal/recipe-constructor.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */





// TODO(shanestephens): This should be a RecipeBuilder
const newRecipe = (name) => new recipe_Recipe(name);
const newHandleEndPoint = (handle) => new connection_constraint_HandleEndPoint(handle);
const newParticleEndPoint = (particle, connection) => new connection_constraint_ParticleEndPoint(particle, connection);
const newTagEndPoint = (tags) => new connection_constraint_TagEndPoint(tags);
const newInstanceEndPoint = (particle, connection) => new connection_constraint_InstanceEndPoint(particle, connection);
const newSearch = (phrase, unresolvedTokens) => new search_Search(phrase, unresolvedTokens);
function constructImmediateValueHandle(connection, particleSpec, id) {
    external_assert_default()(connection.type instanceof type_InterfaceType);
    if (!(connection.type instanceof type_InterfaceType) ||
        !connection.type.interfaceInfo.restrictType(particleSpec)) {
        // Type of the connection does not match the ParticleSpec.
        return null;
    }
    // The connection type may have type variables:
    // E.g. if connection shape requires `in ~a *`
    //      and particle has `in Entity input`
    //      then type system has to ensure ~a is at least Entity.
    // The type of a handle hosting the particle literal has to be
    // concrete, so we concretize connection type with maybeEnsureResolved().
    const handleType = connection.type.clone(new Map());
    handleType.maybeEnsureResolved();
    const handle = connection.recipe.newHandle();
    handle.id = id.toString();
    handle.mappedType = handleType;
    handle.fate = 'copy';
    handle.immediateValue = particleSpec;
    return handle;
}
// Helper methods.
function getClonedSlot(recipe, selectedSlot) {
    let clonedSlot = recipe.updateToClone({ selectedSlot }).selectedSlot;
    if (clonedSlot) {
        return clonedSlot;
    }
    if (selectedSlot.id) {
        clonedSlot = recipe.findSlotByID(selectedSlot.id);
    }
    if (clonedSlot === undefined) {
        if (recipe.parent) {
            clonedSlot = recipe.parent.newSlot(selectedSlot.name);
        }
        else {
            clonedSlot = recipe.newSlot(selectedSlot.name);
        }
        clonedSlot.id = selectedSlot.id;
        return clonedSlot;
    }
    return clonedSlot;
}
// Connect the given slot connection to the selectedSlot, create the slot, if needed.
function connectSlotConnection(slotConnection, selectedSlot) {
    const recipe = slotConnection.recipe;
    if (!slotConnection.targetSlot) {
        const clonedSlot = getClonedSlot(recipe, selectedSlot);
        slotConnection.connectToSlot(clonedSlot);
    }
    if (!slotConnection.targetSlot) {
        throw new Error('missing targetSlot');
    }
    external_assert_default()(!selectedSlot.id || !slotConnection.targetSlot.id || (selectedSlot.id === slotConnection.targetSlot.id), `Cannot override slot id '${slotConnection.targetSlot.id}' with '${selectedSlot.id}'`);
    slotConnection.targetSlot.id = selectedSlot.id || slotConnection.targetSlot.id;
    // TODO: need to concat to existing tags and dedup?
    slotConnection.targetSlot.tags = [...selectedSlot.tags];
}
function replaceOldSlot(oldSlot, newSlot) {
    if (oldSlot && (!oldSlot.id || oldSlot.id !== newSlot.id)) {
        if (oldSlot.sourceConnection !== undefined) {
            if (newSlot.sourceConnection === undefined)
                return false;
            const clonedSlot = getClonedSlot(oldSlot.sourceConnection.recipe, newSlot);
            oldSlot.sourceConnection.providedSlots[oldSlot.name] = clonedSlot;
        }
        while (oldSlot.consumeConnections.length > 0) {
            const conn = oldSlot.consumeConnections[0];
            conn.disconnectFromSlot();
            connectSlotConnection(conn, newSlot);
        }
    }
    return true;
}
//# sourceMappingURL=recipe-constructor.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/internal/recipe-walker.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

class recipe_walker_RecipeWalker extends walker_Walker {
    onResult(result) {
        super.onResult(result);
        const recipe = result.result;
        if (this.onRecipe) {
            this.visit(this.onRecipe.bind(this));
        }
        if (this.onParticle) {
            for (const particle of recipe.particles) {
                this.visit(this.onParticle.bind(this), particle);
            }
        }
        if (this.onPotentialHandleConnection) {
            for (const particle of recipe.particles) {
                if (particle.spec) {
                    for (const connectionSpec of particle.spec.handleConnectionMap.values()) {
                        if (particle.connections[connectionSpec.name]) {
                            continue;
                        }
                        this.visit(this.onPotentialHandleConnection.bind(this), particle, connectionSpec);
                    }
                }
            }
        }
        if (this.onHandleConnection) {
            for (const handleConnection of recipe.handleConnections) {
                this.visit(this.onHandleConnection.bind(this), handleConnection);
            }
        }
        if (this.onHandle) {
            for (const handle of recipe.handles) {
                this.visit(this.onHandle.bind(this), handle);
            }
        }
        if (this.onPotentialSlotConnection) {
            for (const particle of recipe.particles) {
                for (const slotSpec of particle.getUnboundSlotConnections()) {
                    this.visit(this.onPotentialSlotConnection.bind(this), particle, slotSpec);
                }
            }
        }
        if (this.onSlotConnection) {
            for (const slotConnection of recipe.slotConnections) {
                this.visit(this.onSlotConnection.bind(this), slotConnection);
            }
        }
        if (this.onSlot) {
            for (const slot of recipe.slots) {
                this.visit(this.onSlot.bind(this), slot);
            }
        }
        if (this.onObligation) {
            for (const obligation of recipe.obligations) {
                this.visit(this.onObligation.bind(this), obligation);
            }
        }
        if (this.onRequiredParticle) {
            for (const require of recipe.requires) {
                for (const particle of require.particles) {
                    this.visit(this.onRequiredParticle.bind(this), particle);
                }
            }
        }
    }
    createDescendant(recipe, score) {
        const valid = recipe.normalize();
        const hash = valid ? recipe.digest() : null;
        super.createWalkerDescendant(recipe, score, hash, valid);
    }
}
//# sourceMappingURL=recipe-walker.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/internal/recipe-matching.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */



class Shape {
    constructor(recipe, particles, handles, hcs) {
        this.recipe = recipe;
        this.particles = particles;
        this.handles = handles;
        this.reverse = new Map();
        for (const p of Object.keys(particles)) {
            this.reverse.set(particles[p], p);
        }
        for (const h of handles.keys()) {
            this.reverse.set(handles.get(h), h);
        }
        for (const hc of Object.keys(hcs)) {
            this.reverse.set(hcs[hc], hc);
        }
    }
}
function makeShape(particles, handles, map, recipe) {
    recipe = recipe || new recipe_Recipe();
    const pMap = {};
    const hMap = new Map();
    const hcMap = {};
    particles.forEach(particle => pMap[particle] = recipe.newParticle(particle));
    handles.forEach(handle => hMap.set(handle, recipe.newHandle()));
    Object.keys(map).forEach(key => {
        Object.keys(map[key]).forEach(name => {
            const handle = map[key][name];
            const tags = handle.tags || [];
            if (handle.localName) {
                hMap.get(handle.handle).localName = handle.localName;
            }
            const connection = pMap[key].addConnectionName(name);
            // NOTE: for now, 'any' on the connection and shape means 'accept anything'.
            connection.direction = handle.direction || 'any';
            hMap.get(handle.handle).tags = tags;
            connection.connectToHandle(hMap.get(handle.handle));
            hcMap[key + ':' + name] = pMap[key].connections[name];
        });
    });
    return new Shape(recipe, pMap, hMap, hcMap);
}
function recipeToShape(recipe) {
    const particles = {};
    let id = 0;
    recipe.particles.forEach(particle => particles[particle.name] = particle);
    const handles = new Map();
    recipe.handles.forEach(handle => handles.set('h' + id++, handle));
    const hcs = {};
    recipe.handleConnections.forEach(hc => hcs[hc.particle.name + ':' + hc.name] = hc);
    return new Shape(recipe, particles, handles, hcs);
}
function _buildNewHCMatches(recipe, shapeHC, match, outputList) {
    const { forward, reverse, score } = match;
    let matchFound = false;
    for (const recipeParticle of recipe.particles) {
        if (!recipeParticle.spec) {
            continue;
        }
        for (const recipeConnSpec of recipeParticle.spec.handleConnections) {
            // TODO are there situations where multiple handleConnections should
            // be allowed to point to the same one in the recipe?
            if (reverse.has(recipeConnSpec)) {
                continue;
            }
            // TODO support unnamed shape particles.
            if (recipeParticle.name !== shapeHC.particle.name) {
                continue;
            }
            if (shapeHC.name && shapeHC.name !== recipeConnSpec.name) {
                continue;
            }
            if (!connectionMatchesHandleDirection(shapeHC.direction, recipeConnSpec.direction)) {
                continue;
            }
            const recipeHC = recipeParticle.connections[recipeConnSpec.name];
            if (shapeHC.handle && recipeHC && recipeHC.handle && shapeHC.handle.localName &&
                shapeHC.handle.localName !== recipeHC.handle.localName) {
                continue;
            }
            // recipeHC is a candidate for shapeHC. shapeHC references a
            // particle, so recipeHC must reference the matching particle,
            // or a particle that isn't yet mapped from shape.
            if (reverse.has(recipeParticle)) {
                if (reverse.get(recipeParticle) !== shapeHC.particle) {
                    continue;
                }
            }
            else if (forward.has(shapeHC.particle)) {
                // we've already mapped the particle referenced by shapeHC
                // and it doesn't match recipeHC's particle as recipeHC's
                // particle isn't mapped
                continue;
            }
            // shapeHC doesn't necessarily reference a handle, but if it does
            // then recipeHC needs to reference the matching handle, or one
            // that isn't yet mapped, or no handle yet.
            if (shapeHC.handle && recipeHC && recipeHC.handle) {
                if (reverse.has(recipeHC.handle)) {
                    if (reverse.get(recipeHC.handle) !== shapeHC.handle) {
                        continue;
                    }
                }
                else if (forward.has(shapeHC.handle) && forward.get(shapeHC.handle) !== null) {
                    continue;
                }
                // Check whether shapeHC and recipeHC reference the same handle.
                if (shapeHC.handle.fate !== 'create' || (recipeHC.handle.fate !== 'create' && recipeHC.handle.originalFate !== 'create')) {
                    if (Boolean(shapeHC.handle.immediateValue) !== Boolean(recipeHC.handle.immediateValue)) {
                        continue; // One is an immediate value handle and the other is not.
                    }
                    if (recipeHC.handle.immediateValue) {
                        if (!recipeHC.handle.immediateValue.equals(shapeHC.handle.immediateValue)) {
                            continue; // Immediate values are different.
                        }
                    }
                    else {
                        // Note: the id of a handle with 'copy' fate changes during recipe instantiation, hence comparing to original id too.
                        // Skip the check if handles have 'create' fate (their ids are arbitrary).
                        if (shapeHC.handle.id !== recipeHC.handle.id && shapeHC.handle.id !== recipeHC.handle.originalId) {
                            continue; // This is a different handle.
                        }
                    }
                }
            }
            // clone forward and reverse mappings and establish new components.
            const newMatch = { forward: new Map(forward), reverse: new Map(reverse), score };
            external_assert_default()(!newMatch.reverse.has(recipeParticle) || newMatch.reverse.get(recipeParticle) === shapeHC.particle);
            external_assert_default()(!newMatch.forward.has(shapeHC.particle) || newMatch.forward.get(shapeHC.particle) === recipeParticle);
            newMatch.forward.set(shapeHC.particle, recipeParticle);
            newMatch.reverse.set(recipeParticle, shapeHC.particle);
            if (shapeHC.handle) {
                if (!recipeHC || !recipeHC.handle) {
                    if (!newMatch.forward.has(shapeHC.handle)) {
                        newMatch.forward.set(shapeHC.handle, null);
                        newMatch.score -= 2;
                    }
                }
                else {
                    newMatch.forward.set(shapeHC.handle, recipeHC.handle);
                    newMatch.reverse.set(recipeHC.handle, shapeHC.handle);
                }
            }
            newMatch.forward.set(shapeHC, recipeConnSpec);
            newMatch.reverse.set(recipeConnSpec, shapeHC);
            outputList.push(newMatch);
            matchFound = true;
        }
    }
    if (matchFound === false) {
        // Non-null particle in the `forward` map means that some of the particle
        // handle connections were successful matches, but some couldn't be matched.
        // It means that this match in invalid.
        if (match.forward.get(shapeHC.particle)) {
            return;
        }
        // The current handle connection from the shape doesn't match anything
        // in the recipe. Find (or create) a particle for it.
        const newMatches = [];
        _buildNewParticleMatches(recipe, shapeHC.particle, match, newMatches);
        newMatches.forEach(newMatch => {
            // the shape references a handle, might also need to create a recipe
            // handle for it (if there isn't already one from a previous match).
            if (shapeHC.handle && !newMatch.forward.has(shapeHC.handle)) {
                newMatch.forward.set(shapeHC.handle, null);
                newMatch.score -= 2;
            }
            newMatch.forward.set(shapeHC, null);
            newMatch.score -= 1;
            outputList.push(newMatch);
        });
    }
}
function _buildNewParticleMatches(recipe, shapeParticle, match, newMatches) {
    const { forward, reverse, score } = match;
    let matchFound = false;
    for (const recipeParticle of recipe.particles) {
        if (reverse.has(recipeParticle)) {
            continue;
        }
        if (recipeParticle.name !== shapeParticle.name) {
            continue;
        }
        let handleNamesMatch = true;
        for (const connectionName of Object.keys(recipeParticle.connections)) {
            const recipeConnection = recipeParticle.connections[connectionName];
            if (!recipeConnection.handle) {
                continue;
            }
            const shapeConnection = shapeParticle.connections[connectionName];
            if (shapeConnection && shapeConnection.handle && shapeConnection.handle.localName && shapeConnection.handle.localName !== recipeConnection.handle.localName) {
                handleNamesMatch = false;
                break;
            }
        }
        if (!handleNamesMatch) {
            continue;
        }
        const newMatch = { forward: new Map(forward), reverse: new Map(reverse), score };
        external_assert_default()(!newMatch.forward.has(shapeParticle) || newMatch.forward.get(shapeParticle) === recipeParticle);
        external_assert_default()(!newMatch.reverse.has(recipeParticle) || newMatch.reverse.get(recipeParticle) === shapeParticle);
        newMatch.forward.set(shapeParticle, recipeParticle);
        newMatch.reverse.set(recipeParticle, shapeParticle);
        newMatches.push(newMatch);
        matchFound = true;
    }
    if (matchFound === false) {
        const newMatch = { forward: new Map(), reverse: new Map(), score: 0 };
        forward.forEach((value, key) => {
            external_assert_default()(!newMatch.forward.has(key) || newMatch.forward.get(key) === value);
            newMatch.forward.set(key, value);
        });
        reverse.forEach((value, key) => {
            external_assert_default()(!newMatch.reverse.has(key) || newMatch.reverse.get(key) === value);
            newMatch.reverse.set(key, value);
        });
        if (!newMatch.forward.has(shapeParticle)) {
            newMatch.forward.set(shapeParticle, null);
            newMatch.score = match.score - 1;
        }
        newMatches.push(newMatch);
    }
}
function _assignHandlesToEmptyPosition(shape, match, emptyHandles, nullHandles) {
    if (emptyHandles.length === 1) {
        const matches = [];
        const { forward, reverse, score } = match;
        for (const nullHandle of nullHandles) {
            let tagsMatch = true;
            for (const tag of nullHandle.tags) {
                if (!emptyHandles[0].tags.includes(tag)) {
                    tagsMatch = false;
                    break;
                }
            }
            if (!tagsMatch) {
                continue;
            }
            const newMatch = { forward: new Map(forward), reverse: new Map(reverse), score: score + 1 };
            newMatch.forward.set(nullHandle, emptyHandles[0]);
            newMatch.reverse.set(emptyHandles[0], nullHandle);
            matches.push(newMatch);
        }
        return matches;
    }
    const thisHandle = emptyHandles.pop();
    const matches = _assignHandlesToEmptyPosition(shape, match, emptyHandles, nullHandles);
    let newMatches = [];
    for (const match of matches) {
        const nullHandles = [...shape.handles.values()].filter(handle => match.forward.get(handle) === null);
        if (nullHandles.length > 0) {
            newMatches = newMatches.concat(_assignHandlesToEmptyPosition(shape, match, [thisHandle], nullHandles));
        }
        else {
            newMatches = newMatches.concat(match);
        }
    }
    return newMatches;
}
function recipe_matching_find(recipe, shape) {
    // Particles and Handles are initially stored by a forward map from
    // shape component to recipe component.
    // Handle connections, particles and handles are also stored by a reverse map
    // from recipe component to shape component.
    const _recipe = recipe;
    // Start with a single, empty match
    let matches = [{ forward: new Map(), reverse: new Map(), score: 0 }];
    for (const shapeHC of shape.recipe.handleConnections) {
        const newMatches = [];
        for (const match of matches) {
            // collect matching handle connections into a new matches list
            _buildNewHCMatches(_recipe, shapeHC, match, newMatches);
        }
        matches = newMatches;
    }
    for (const shapeParticle of shape.recipe.particles) {
        if (Object.keys(shapeParticle.connections).length > 0) {
            continue;
        }
        if (shapeParticle.unnamedConnections.length > 0) {
            continue;
        }
        const newMatches = [];
        for (const match of matches) {
            _buildNewParticleMatches(_recipe, shapeParticle, match, newMatches);
        }
        matches = newMatches;
    }
    const emptyHandles = _recipe.handles.filter(handle => handle.connections.length === 0);
    if (emptyHandles.length > 0) {
        let newMatches = [];
        for (const match of matches) {
            const nullHandles = [...shape.handles.values()].filter(handle => match.forward.get(handle) === null);
            if (nullHandles.length > 0) {
                newMatches = newMatches.concat(_assignHandlesToEmptyPosition(shape, match, emptyHandles, nullHandles));
            }
            else {
                newMatches = newMatches.concat(match);
            }
        }
        matches = newMatches;
    }
    return matches.map((match) => {
        const result = {};
        match.forward.forEach((value, key) => result[shape.reverse.get(key)] = value);
        return { match: result, score: match.score };
    });
}
// Returns true if `otherRecipe` matches the shape of recipe.
function matchesRecipe(recipe, otherRecipe) {
    const shape = recipeToShape(otherRecipe);
    const result = recipe_matching_find(recipe, shape);
    return result.some(r => r.score === 0);
}
//# sourceMappingURL=recipe-matching.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/internal/slot-utils.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// Returns all possible slot candidates, sorted by "quality"
function findAllSlotCandidates(particle, slotSpec, arc) {
    const slotConn = particle.getSlandleConnectionByName(slotSpec.name);
    return {
        // Note: during manfiest parsing, target slot is only set in slot connection, if the slot exists in the recipe.
        // If this slot is internal to the recipe, it has the sourceConnection set to the providing connection
        // (and hence the consuming connection is considered connected already). Otherwise, this may only be a remote slot.
        local: !slotConn || !slotConn.targetSlot ? _findSlotCandidates(particle, slotSpec, particle.recipe.slots) : [],
        remote: _findSlotCandidates(particle, slotSpec, arc.peh.slotComposer.getAvailableContexts())
    };
}
// Returns the given slot candidates, sorted by "quality".
// TODO(sjmiles): `slots` is either Slot[] or ProvidedSlotContext[] ... these types do not obviously match,
// seems like it's using only `[thing].spec`
function _findSlotCandidates(particle, slotSpec, slots) {
    const possibleSlots = slots.filter(s => slot_utils_slotMatches(particle, slotSpec, s));
    possibleSlots.sort((slot1, slot2) => {
        // TODO: implement.
        return slot1.name < slot2.name;
    });
    return possibleSlots;
}
// Returns true, if the given slot is a viable candidate for the slotConnection.
function slot_utils_slotMatches(particle, slotSpec, slot) {
    if (!slotSpec || !slot.spec || slotSpec.isSet !== slot.spec.isSet) {
        return false;
    }
    const potentialSlotConn = particle.getSlandleConnectionBySpec(slotSpec);
    if (!tagsOrNameMatch(slotSpec, slot.spec, potentialSlotConn, slot)) {
        return false;
    }
    // Match handles of the provided slot with the slot-connection particle's handles.
    if (!handlesMatch(particle, slot)) {
        return false;
    }
    return true;
}
// Returns true, if the providing slot handle restrictions are satisfied by the consuming slot connection.
// TODO: should we move some of this logic to the recipe? Or type matching?
function handlesMatch(particle, slot) {
    if (slot.handles.length === 0) {
        return true; // slot is not limited to specific handles
    }
    return !!Object.values(particle.connections).find(handleConn => {
        return slot.handles.includes(handleConn.handle) ||
            (handleConn.handle && handleConn.handle.id && slot.handles.map(sh => sh.id).includes(handleConn.handle.id));
    });
}
function tagsOrNameMatch(consumeSlotSpec, provideSlotSpec, consumeSlotConn, provideSlot) {
    const consumeTags = [].concat(consumeSlotSpec.tags || [], consumeSlotConn ? consumeSlotConn.tags : [], consumeSlotConn && consumeSlotConn.targetSlot ? consumeSlotConn.targetSlot.tags : []);
    const provideTags = [].concat(provideSlotSpec.tags || [], provideSlot ? provideSlot.tags : [], provideSlot ? provideSlot.name : (provideSlotSpec.name ? provideSlotSpec.name : []));
    if (consumeTags.length > 0 && consumeTags.some(t => provideTags.includes(t))) {
        return true;
    }
    return consumeSlotSpec.name === (provideSlot ? provideSlot.name : provideSlotSpec.name);
}
//# sourceMappingURL=slot-utils.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe/lib-recipe.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */









// TODO(shanestephens): These functions are all inappropriately polymorphic on the type of the 'slot' parameter.
// They need to be significantly refactored or removed.

// TODO(shanestephens): Find a better place for this.
function directionCounts(handle) {
    const counts = { 'reads': 0, 'writes': 0, 'reads writes': 0, 'hosts': 0, '`consumes': 0, '`provides': 0, 'any': 0 };
    for (const connection of handle.connections) {
        counts[connection.direction]++;
    }
    counts.reads += counts['reads writes'];
    counts.writes += counts['reads writes'];
    return counts;
}
// TODO(shanestephens): Find a better place for this.
function reverseDirection(direction) {
    switch (direction) {
        case 'reads':
            return 'writes';
        case 'writes':
            return 'reads';
        case 'reads writes':
            return 'reads writes';
        case '`consumes':
            return '`provides';
        case '`provides':
            return '`consumes';
        case 'any':
            return 'any';
        default:
            // Catch nulls and unsafe values from javascript.
            throw new Error(`Bad direction ${direction}`);
    }
}
//# sourceMappingURL=lib-recipe.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage-key-factory.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

class StorageKeyOptions {
    constructor(arcId, schemaHash, schemaName = null) {
        this.arcId = arcId;
        this.schemaHash = schemaHash;
        this.schemaName = schemaName;
    }
}
class ContainerStorageKeyOptions extends StorageKeyOptions {
    constructor(arcId, schemaHash, schemaName) {
        super(arcId, schemaHash, schemaName);
    }
    unique() { return ''; }
    location() { return this.arcId.toString(); }
}
class BackingStorageKeyOptions extends StorageKeyOptions {
    constructor(arcId, schemaHash, schemaName) {
        super(arcId, schemaHash, schemaName);
    }
    unique() {
        return this.schemaName && this.schemaName.length > 0
            ? this.schemaName : this.schemaHash;
    }
    location() {
        return this.unique();
    }
}
class StorageKeyFactory {
    // Returns true, if the current storage key class can support the given set of Capabilities.
    supports(capabilities) {
        return this.capabilities().containsAll(capabilities);
    }
}
// An implementation of a FactorySelector choosing a factory with a least
// restrictive max capabilities set.
class storage_key_factory_SimpleCapabilitiesSelector {
    constructor(sortedProtocols = ['volatile', 'ramdisk', 'memdb', 'db']) {
        this.sortedProtocols = sortedProtocols;
    }
    select(factories) {
        external_assert_default()(factories.length > 0);
        return factories.reduce((res, factory) => {
            if (res === null)
                return factory;
            const resIndex = this.sortedProtocols.indexOf(res.protocol);
            if (resIndex === -1 || this.sortedProtocols.indexOf(factory.protocol) < resIndex) {
                return factory;
            }
            return res;
        }, null);
    }
}
//# sourceMappingURL=storage-key-factory.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/capabilities-resolver.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */




class capabilities_resolver_CapabilitiesResolver {
    constructor(options) {
        this.options = options;
        this.factories = {};
        for (const factory of (options.factories || [])) {
            external_assert_default()(!this.factories[factory.protocol], `Duplicated factory for '${factory.protocol}'.`);
            this.factories[factory.protocol] = factory;
        }
        for (const factory of Object.values(capabilities_resolver_CapabilitiesResolver.defaultStorageKeyFactories)) {
            if (!this.factories[factory.protocol]) {
                this.factories[factory.protocol] = factory;
            }
        }
    }
    get selector() { return this.options.selector || capabilities_resolver_CapabilitiesResolver.defaultSelector; }
    async createStorageKey(capabilities, type, handleId) {
        const factory = this.selectStorageKeyFactory(capabilities, handleId);
        return this.createStorageKeyWithFactory(factory, type, handleId);
    }
    selectStorageKeyFactory(capabilities, handleId) {
        const selectedFactories = Object.values(this.factories).filter(factory => {
            return factory.supports(capabilities);
        });
        if (selectedFactories.length === 0) {
            throw new Error(`Cannot create a suitable storage key for handle '${handleId}' with capabilities ${capabilities.toDebugString()}`);
        }
        return this.selector.select(selectedFactories);
    }
    async createStorageKeyWithFactory(factory, type, handleId) {
        const schemaHash = await type.getEntitySchema().hash();
        const containerKey = factory.create(new ContainerStorageKeyOptions(this.options.arcId, schemaHash, type.getEntitySchema().name));
        const containerChildKey = containerKey.childKeyForHandle(handleId);
        if (!Flags.defaultReferenceMode) {
            return containerChildKey;
        }
        if (type.isReference ||
            (type.getContainedType() && type.getContainedType().isReference)) {
            return containerChildKey;
        }
        const backingKey = factory.create(new BackingStorageKeyOptions(this.options.arcId, schemaHash, type.getEntitySchema().name));
        // ReferenceModeStorageKeys in different drivers can cause problems with garbage collection.
        external_assert_default()(backingKey.protocol === containerKey.protocol);
        return new reference_mode_storage_key_ReferenceModeStorageKey(backingKey, containerChildKey);
    }
    static registerStorageKeyFactory(factory) {
        external_assert_default()(!capabilities_resolver_CapabilitiesResolver.defaultStorageKeyFactories[factory.protocol], `Storage key factory for '${factory.protocol}' already registered`);
        capabilities_resolver_CapabilitiesResolver.defaultStorageKeyFactories[factory.protocol] = factory;
    }
    static reset() {
        capabilities_resolver_CapabilitiesResolver.defaultStorageKeyFactories = {};
    }
}
capabilities_resolver_CapabilitiesResolver.defaultStorageKeyFactories = {};
capabilities_resolver_CapabilitiesResolver.defaultSelector = new storage_key_factory_SimpleCapabilitiesSelector();
//# sourceMappingURL=capabilities-resolver.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/drivers/volatile.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */









class volatile_VolatileStorageKey extends StorageKey {
    constructor(arcId, unique, path = '') {
        super(volatile_VolatileStorageKey.protocol);
        this.arcId = arcId;
        this.unique = unique;
        this.path = path;
    }
    toString() {
        return `${this.protocol}://${this.arcId}/${this.unique}@${this.path}`;
    }
    childWithComponent(component) {
        return new volatile_VolatileStorageKey(this.arcId, this.unique, `${this.path}/${component}`);
    }
    // Note that subKeys lose path information.
    subKeyWithComponent(component) {
        return new volatile_VolatileStorageKey(this.arcId, `${this.unique}/${component}`);
    }
    static fromString(key) {
        const match = key.match(/^volatile:\/\/([^/]+)\/([^@]*)@(.*)$/);
        if (!match) {
            throw new Error(`Not a valid VolatileStorageKey: ${key}.`);
        }
        const [_, arcId, unique, path] = match;
        return new volatile_VolatileStorageKey(ArcId.fromString(arcId), unique, path);
    }
    static register() {
        capabilities_resolver_CapabilitiesResolver.registerStorageKeyFactory(new volatile_VolatileStorageKeyFactory());
    }
}
volatile_VolatileStorageKey.protocol = 'volatile';
class volatile_VolatileStorageKeyFactory extends StorageKeyFactory {
    get protocol() { return volatile_VolatileStorageKey.protocol; }
    capabilities() {
        return capabilities_Capabilities.create([capabilities_Persistence.inMemory(), new capabilities_Shareable(false)]);
    }
    create(options) {
        return new volatile_VolatileStorageKey(options.arcId, options.unique(), '');
    }
}
class volatile_VolatileMemory {
    constructor() {
        this.entries = new Map();
        // Tokens can't just be an incrementing number as VolatileMemory is the basis for RamDiskMemory too;
        // if we were to use numbers here then a RamDisk could be reaped, restarted, and end up with the
        // same token as a previous iteration.
        // When we want to support RamDisk fast-forwarding (e.g. by keeping a rotating window of recent
        // operations) then we'll need tokens to be a combination of a per-instance random value and a
        // per-operation updating number. For now, just a random value that is updated with each write
        // is sufficient.
        this.token = Math.random() + '';
    }
    deserialize(data, unique) {
        external_assert_default()(!this.entries.has(unique));
        const entry = { root: null, locations: {} };
        entry.root = { data: data.root, version: 0, drivers: [] };
        if (data.locations) {
            for (const [key, value] of Object.entries(data.locations)) {
                entry.locations[key] = { data: value, version: 0, drivers: [] };
            }
        }
        this.entries.set(unique, entry);
    }
}
class SimpleVolatileMemoryProvider {
    constructor() {
        this.memory = new volatile_VolatileMemory();
    }
    getVolatileMemory() {
        return this.memory;
    }
}
let volatile_id = 0;
class volatile_VolatileDriver extends Driver {
    constructor(storageKey, exists, memory) {
        super(storageKey, exists);
        this.pendingVersion = 0;
        this.pendingModel = null;
        this.id = volatile_id++;
        this.memory = memory;
        this.path = null;
        if (storageKey instanceof volatile_VolatileStorageKey && storageKey.path !== '') {
            this.path = storageKey.path;
        }
        switch (exists) {
            case Exists.ShouldCreate:
                if (this.memory.entries.has(storageKey.unique)) {
                    throw new Error(`requested creation of memory location ${storageKey} can't proceed as location already exists`);
                }
                this.data = { root: null, locations: {} };
                this.memory.entries.set(storageKey.unique, this.data);
                break;
            case Exists.ShouldExist:
                if (!this.memory.entries.has(storageKey.unique)) {
                    throw new Error(`requested connection to memory location ${storageKey} can't proceed as location doesn't exist`);
                }
            /* falls through */
            case Exists.MayExist:
                {
                    const data = this.memory.entries.get(storageKey.unique);
                    if (data) {
                        this.data = data;
                        this.pendingModel = this.localData();
                        this.pendingVersion = this.localVersion();
                    }
                    else {
                        this.data = { locations: {}, root: null };
                        this.memory.entries.set(storageKey.unique, this.data);
                        this.memory.token = Math.random() + '';
                    }
                    break;
                }
            default:
                throw new Error(`unknown Exists code ${exists}`);
        }
        this.pushLocalDriver(this);
    }
    getOrCreateEntry() {
        if (this.path) {
            if (!this.data.locations[this.path]) {
                this.data.locations[this.path] = { data: null, version: 0, drivers: [] };
            }
            return this.data.locations[this.path];
        }
        if (!this.data.root) {
            this.data.root = { data: null, version: 0, drivers: [] };
        }
        return this.data.root;
    }
    localData() {
        return this.getOrCreateEntry().data;
    }
    localVersion() {
        return this.getOrCreateEntry().version;
    }
    setLocalData(data) {
        this.getOrCreateEntry().data = data;
    }
    incrementLocalVersion() {
        this.getOrCreateEntry().version += 1;
    }
    pushLocalDriver(driver) {
        this.getOrCreateEntry().drivers.push(driver);
    }
    registerReceiver(receiver, token) {
        this.receiver = receiver;
        if (this.pendingModel && token !== this.memory.token) {
            receiver(this.pendingModel, this.pendingVersion);
        }
        this.pendingModel = null;
    }
    getToken() { return this.memory.token; }
    async send(model, version) {
        // This needs to contain an "empty" await, otherwise there's
        // a synchronous send / onReceive loop that can be established
        // between multiple Stores/Drivers writing to the same location.
        await 0;
        if (this.localVersion() !== version - 1) {
            return false;
        }
        this.setLocalData(model);
        this.incrementLocalVersion();
        this.getOrCreateEntry().drivers.forEach(driver => {
            if (driver === this) {
                return;
            }
            if (driver.receiver) {
                driver.receiver(model, this.localVersion());
            }
        });
        return true;
    }
    async write(key, value) {
        throw new Error('Method not implemented.');
    }
    async read(key) {
        throw new Error('Method not implemented.');
    }
}
/**
 * Provides Volatile storage drivers. Volatile storage is local to an individual
 * running Arc. It lives for as long as that Arc instance, and then gets
 * deleted when the Arc is stopped.
 */
class volatile_VolatileStorageDriverProvider {
    constructor(arc) {
        this.arc = arc;
    }
    willSupport(storageKey) {
        return storageKey.protocol === volatile_VolatileStorageKey.protocol
            && storageKey.arcId.equal(this.arc.id);
    }
    async driver(storageKey, exists) {
        if (!this.willSupport(storageKey)) {
            throw new Error(`This provider does not support storageKey ${storageKey.toString()}`);
        }
        return new volatile_VolatileDriver(storageKey, exists, this.arc.volatileMemory);
    }
    // QUESTION: This method is never being called, is it needed?
    static register(arc) {
        DriverFactory.register(new volatile_VolatileStorageDriverProvider(arc));
    }
}
StorageKeyParser.addDefaultParser(volatile_VolatileStorageKey.protocol, volatile_VolatileStorageKey.fromString);
//# sourceMappingURL=volatile.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/drivers/ramdisk.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */







class ramdisk_RamDiskStorageKey extends StorageKey {
    constructor(unique) {
        super(ramdisk_RamDiskStorageKey.protocol);
        this.unique = unique;
    }
    toString() {
        return `${this.protocol}://${this.unique}`;
    }
    childWithComponent(component) {
        return new ramdisk_RamDiskStorageKey(`${this.unique}/${component}`);
    }
    static fromString(key) {
        const match = key.match(/^ramdisk:\/\/(.*)$/);
        if (!match) {
            throw new Error(`Not a valid RamDiskStorageKey: ${key}.`);
        }
        const unique = match[1];
        return new ramdisk_RamDiskStorageKey(unique);
    }
}
ramdisk_RamDiskStorageKey.protocol = 'ramdisk';
class ramdisk_RamDiskStorageKeyFactory extends StorageKeyFactory {
    get protocol() { return ramdisk_RamDiskStorageKey.protocol; }
    capabilities() {
        return capabilities_Capabilities.create([capabilities_Persistence.inMemory(), capabilities_Shareable.any()]);
    }
    create(options) {
        return new ramdisk_RamDiskStorageKey(options.location());
    }
}
/**
 * Provides RamDisk storage drivers. RamDisk storage is shared amongst all Arcs,
 * and will persist for as long as the Arcs Runtime does.
 *
 * This works in the exact same way as Volatile storage, but the memory is not
 * tied to a specific running Arc.
 */
class ramdisk_RamDiskStorageDriverProvider {
    constructor(memoryProvider) {
        this.memoryProvider = memoryProvider;
    }
    willSupport(storageKey) {
        return storageKey.protocol === ramdisk_RamDiskStorageKey.protocol;
    }
    async driver(storageKey, exists) {
        if (!this.willSupport(storageKey)) {
            throw new Error(`This provider does not support storageKey ${storageKey.toString()}`);
        }
        const memory = this.memoryProvider.getVolatileMemory();
        return new volatile_VolatileDriver(storageKey, exists, memory);
    }
    static register(memoryProvider) {
        DriverFactory.register(new ramdisk_RamDiskStorageDriverProvider(memoryProvider));
        StorageKeyParser.addParser(ramdisk_RamDiskStorageKey.protocol, ramdisk_RamDiskStorageKey.fromString);
        capabilities_resolver_CapabilitiesResolver.registerStorageKeyFactory(new ramdisk_RamDiskStorageKeyFactory());
    }
}
//# sourceMappingURL=ramdisk.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/arcs-types/annotation.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


class annotation_Annotation {
    constructor(name, params, targets, retention, allowMultiple, doc) {
        this.name = name;
        this.params = params;
        this.targets = targets;
        this.retention = retention;
        this.allowMultiple = allowMultiple;
        this.doc = doc;
    }
    _compareTo(other) {
        let cmp;
        if ((cmp = compareStrings(this.name, other.name)) !== 0)
            return cmp;
        if ((cmp = compareArrays(this.targets, other.targets, compareStrings)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this.retention, other.retention)) !== 0)
            return cmp;
        if ((cmp = compareBools(this.allowMultiple, other.allowMultiple)) !== 0)
            return cmp;
        if ((cmp = compareStrings(this.doc, other.doc)) !== 0)
            return cmp;
        return 0;
    }
    toManifestString(builder = new IndentingStringBuilder()) {
        let paramStr = '';
        if (Object.keys(this.params).length > 0) {
            paramStr = `(${Object.keys(this.params).map(name => `${name}: ${this.params[name]}`).join(', ')})`;
        }
        builder.push(`annotation ${this.name}${paramStr}`);
        builder.withIndent(builder => {
            if (this.targets.length > 0) {
                builder.push(`targets: [${this.targets.join(', ')}]`);
            }
            builder.push(`retention: ${this.retention}`);
            if (this.allowMultiple) {
                builder.push(`allowMultiple: ${this.allowMultiple}`);
            }
            if (this.doc) {
                builder.push(`doc: '${this.doc}'`);
            }
        });
        return builder.toString();
    }
}
class annotation_AnnotationRef {
    constructor(annotation, params) {
        this.annotation = annotation;
        this.params = params;
        this._validateParams();
    }
    get name() { return this.annotation.name; }
    _validateParams() {
        for (const name of Object.keys(this.params)) {
            const type = this.annotation.params[name];
            const value = this.params[name];
            switch (type) {
                case 'Text':
                    external_assert_default()(typeof value === 'string', `expected '${type}' for param '${name}', instead got ${value}`);
                    break;
                case 'Number':
                    external_assert_default()(typeof value === 'number', `expected '${type}' for param '${name}', instead got ${value}`);
                    break;
                case 'Boolean':
                    external_assert_default()(typeof value === 'boolean', `expected '${type}' for param '${name}', instead got ${value}`);
                    break;
                default:
                    throw new Error(`Unsupported type: '${type}' for annotation '${name}'`);
            }
        }
    }
    isValidForTarget(target) {
        return this.annotation.targets.length === 0 || this.annotation.targets.includes(target);
    }
    clone() {
        return new annotation_AnnotationRef(this.annotation, { ...this.params });
    }
    toString() {
        let paramStr = '';
        if (Object.keys(this.params).length > 0) {
            const params = [];
            for (const [name, value] of Object.entries(this.params)) {
                const valueStr = this.annotation.params[name] === 'Text' ? `'${value}'` : value;
                params.push(`${name}: ${valueStr}`);
            }
            paramStr = `(${params.join(', ')})`;
        }
        return `@${this.name}${paramStr}`;
    }
}
//# sourceMappingURL=annotation.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/policy/canonical-policy-annotations.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/** Canonical definitions of annotations used for defining policies. */
const canonicalPolicyAnnotations = `
annotation intendedPurpose(description: Text)
  targets: [Policy]
  retention: Source
  doc: 'Description of a policy.'

annotation egressType(type: Text)
  targets: [Policy]
  retention: Source
  doc: 'Type of egress permitted by a policy.'

annotation allowedRetention(medium: Text, encryption: Boolean)
  targets: [PolicyTarget]
  retention: Source
  allowMultiple: true
  doc: 'Indicates the conditions under which the target data can be retained. Valid values for the medium are: Ram, Disk. Encryption is not supported yet.'

annotation maxAge(age: Text)
  targets: [PolicyTarget]
  retention: Source
  doc: 'Indicates the maximum age the target data can be in order to be used. Age is a string like "2d". Supported units are minutes ("m"), hours ("h"), days ("d").'

// TODO(b/157961278): Support varargs or dictionaries, and then convert this to
// be: @allowedUsages(raw: [join], someLabel: [egress]).
annotation allowedUsage(label: Text, usageType: Text)
  targets: [PolicyField]
  retention: Source
  allowMultiple: true
  doc: 'Indicates the conditions under which a field can be used. Valid values for usageType are: egress, join, *. "raw" is a special value for label meaning that no redaction is required. The default if no @allowedUsage annotation is supplied is for all usages to be valid.'
`;
//# sourceMappingURL=canonical-policy-annotations.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/canonical-manifest.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

const canonicalManifest = `
annotation active
  targets: [Recipe]
  retention: Source
  doc: 'active recipe in arc'

annotation arcId(id: Text)
  targets: [Recipe]
  retention: Source
  doc: 'predefined ID of a long running arc'

annotation ttl(value: Text)
  // Atm TTL is only supported for recipes handles.
  targets: [Handle]
  retention: Runtime
  doc: 'data time-to-live'

annotation persistent
  targets: [Handle, Store, HandleConnection]
  retention: Runtime
  doc: 'storage capability: persistency'

annotation queryable
  targets: [Handle, Store, HandleConnection]
  retention: Runtime
  doc: 'storage capability: queryable'

annotation encrypted
  targets: [Handle, Store, HandleConnection]
  retention: Runtime
  doc: 'storage capability: encrypted'

annotation shareable
  targets: [Handle, Store, HandleConnection]
  retention: Runtime
  doc: 'storage capability: shareable'

annotation inMemory
  targets: [Handle]
  retention: Runtime
  doc: 'storage capability mapped to in-memory persistence'

annotation tiedToArc
  targets: [Handle]
  retention: Runtime
  doc: 'DEPRECATED storage capability mapped to volatile storage'

annotation tiedToRuntime
  targets: [Handle]
  retention: Runtime
  doc: 'DEPRECATED storage capability mapped to ramdisk storage'

annotation isolated
  targets: [Particle]
  retention: Source
  doc: 'Indicates that the given particle is an isolated particle, and does not egress data.'

annotation egress(type: Text)
  targets: [Particle]
  retention: Source
  doc: 'Indicates that the given particle can egress data out of the system (i.e. is not isolated). Optionally supply an egress type.'

annotation ingress
  targets: [Particle]
  retention: Source
  doc: 'Indicates that the given particle can ingress data into of the system (i.e. is not isolated).'

annotation policy(name: Text)
  targets: [Recipe]
  retention: Source
  doc: 'Indicates that the target recipe should comply with the policy of the given name.'

annotation hardRef
  targets: [SchemaField]
  retention: Source
  doc: 'It can be used on reference fields: a hard reference indicates that the entity with that field should be deleted when the referenced entity is deleted.'

${canonicalPolicyAnnotations}
`;
//# sourceMappingURL=canonical-manifest.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/policy/policy.js





var PolicyRetentionMedium;
(function (PolicyRetentionMedium) {
    PolicyRetentionMedium["Ram"] = "Ram";
    PolicyRetentionMedium["Disk"] = "Disk";
})(PolicyRetentionMedium || (PolicyRetentionMedium = {}));
var PolicyAllowedUsageType;
(function (PolicyAllowedUsageType) {
    PolicyAllowedUsageType["Any"] = "*";
    PolicyAllowedUsageType["Egress"] = "egress";
    PolicyAllowedUsageType["Join"] = "join";
})(PolicyAllowedUsageType || (PolicyAllowedUsageType = {}));
const intendedPurposeAnnotationName = 'intendedPurpose';
const egressTypeAnnotationName = 'egressType';
const allowedRetentionAnnotationName = 'allowedRetention';
const allowedUsageAnnotationName = 'allowedUsage';
const maxAgeAnnotationName = 'maxAge';
/**
 * Definition of a dataflow policy.
 *
 * This class is just a thin wrapper around the Policy AST node. There's no
 * actual functionality other than validating the input is correct.
 */
class policy_Policy {
    constructor(name, targets, configs, description, egressType, customAnnotations, allAnnotations) {
        this.name = name;
        this.targets = targets;
        this.configs = configs;
        this.description = description;
        this.egressType = egressType;
        this.customAnnotations = customAnnotations;
        this.allAnnotations = allAnnotations;
    }
    toManifestString(builder = new IndentingStringBuilder()) {
        builder.push(...this.allAnnotations.map(annotation => annotation.toString()));
        builder.push(`policy ${this.name} {`);
        builder.withIndent(builder => {
            this.targets.forEach(target => target.toManifestString(builder));
            this.configs.forEach(config => config.toManifestString(builder));
        });
        builder.push('}');
        return builder.toString();
    }
    static fromAstNode(node, buildAnnotationRefs, findTypeByName) {
        checkNamesAreUnique(node.targets.map(target => ({ name: target.schemaName })));
        const targets = node.targets.map(target => policy_PolicyTarget.fromAstNode(target, buildAnnotationRefs, findTypeByName));
        checkNamesAreUnique(node.configs);
        const configs = node.configs.map(config => policy_PolicyConfig.fromAstNode(config));
        // Process annotations.
        const allAnnotations = buildAnnotationRefs(node.annotationRefs);
        let description = null;
        let egressType = null;
        const customAnnotations = [];
        for (const annotation of allAnnotations) {
            switch (annotation.name) {
                case intendedPurposeAnnotationName:
                    description = this.toDescription(annotation);
                    break;
                case egressTypeAnnotationName:
                    egressType = this.toEgressType(annotation);
                    break;
                default:
                    customAnnotations.push(annotation);
                    break;
            }
        }
        return new policy_Policy(node.name, targets, configs, description, egressType, customAnnotations, allAnnotations);
    }
    static toDescription(annotation) {
        external_assert_default()(annotation.name === intendedPurposeAnnotationName);
        return annotation.params['description'];
    }
    static toEgressType(annotation) {
        external_assert_default()(annotation.name === egressTypeAnnotationName);
        return annotation.params['type'];
    }
}
class policy_PolicyTarget {
    constructor(schemaName, type, fields, retentions, maxAge, customAnnotations, allAnnotations) {
        this.schemaName = schemaName;
        this.type = type;
        this.fields = fields;
        this.retentions = retentions;
        this.maxAge = maxAge;
        this.customAnnotations = customAnnotations;
        this.allAnnotations = allAnnotations;
    }
    toManifestString(builder = new IndentingStringBuilder()) {
        builder.push(...this.allAnnotations.map(annotation => annotation.toString()));
        builder.push(`from ${this.schemaName} access {`);
        this.fields.forEach(field => field.toManifestString(builder.withIndent()));
        builder.push('}');
        return builder.toString();
    }
    static fromAstNode(node, buildAnnotationRefs, findTypeByName) {
        // Check type.
        const type = findTypeByName(node.schemaName);
        if (!type) {
            throw new Error(`Unknown type name: ${node.schemaName}.`);
        }
        // Convert fields.
        checkNamesAreUnique(node.fields);
        const fields = node.fields.map(field => policy_PolicyField.fromAstNode(field, type, buildAnnotationRefs));
        // Process annotations.
        const allAnnotations = buildAnnotationRefs(node.annotationRefs);
        let maxAge = capabilities_Ttl.zero();
        const retentionMediums = new Set();
        const retentions = [];
        const customAnnotations = [];
        for (const annotation of allAnnotations) {
            switch (annotation.name) {
                case allowedRetentionAnnotationName: {
                    const retention = this.toRetention(annotation);
                    if (retentionMediums.has(retention.medium)) {
                        throw new Error(`@${allowedRetentionAnnotationName} has already been defined for ${retention.medium}.`);
                    }
                    retentionMediums.add(retention.medium);
                    retentions.push(retention);
                    break;
                }
                case maxAgeAnnotationName:
                    maxAge = this.toMaxAge(annotation);
                    break;
                default:
                    customAnnotations.push(annotation);
                    break;
            }
        }
        return new policy_PolicyTarget(node.schemaName, type, fields, retentions, maxAge, customAnnotations, allAnnotations);
    }
    static toRetention(annotation) {
        external_assert_default()(annotation.name === allowedRetentionAnnotationName);
        const medium = annotation.params['medium'];
        checkValueInEnum(medium, PolicyRetentionMedium);
        return {
            medium: medium,
            encryptionRequired: annotation.params['encryption'],
        };
    }
    static toMaxAge(annotation) {
        external_assert_default()(annotation.name === maxAgeAnnotationName);
        const maxAge = annotation.params['age'];
        return capabilities_Ttl.fromString(maxAge);
    }
    toCapabilities() {
        return this.retentions.map(retention => {
            const ranges = [];
            switch (retention.medium) {
                case PolicyRetentionMedium.Disk:
                    ranges.push(capabilities_Persistence.onDisk());
                    break;
                case PolicyRetentionMedium.Ram:
                    ranges.push(capabilities_Persistence.inMemory());
                    break;
                default:
                    throw new Error(`Unsupported retention medium ${retention.medium}`);
            }
            ranges.push(new capabilities_Encryption(retention.encryptionRequired));
            ranges.push(this.maxAge);
            return capabilities_Capabilities.create(ranges);
        });
    }
    // Returns policy fields in the format of Schema fields.
    toSchemaFields() {
        return this.fields.map(f => f.toSchemaFields(this.type))
            .reduce((fields, { name, field }) => ({ ...fields, [name]: field }), {});
    }
    // Return the max readable schema according to this policy.
    getMaxReadSchema() {
        return new schema_Schema(this.type.getEntitySchema().names, this.toSchemaFields());
    }
}
class policy_PolicyField {
    constructor(name, type, subfields, 
    /**
     * The acceptable usages this field. Each (label, usage) pair defines a
     * usage type that is acceptable for a given redaction label. The empty
     * string label describes the usage for the raw data, given no redaction.
     */
    allowedUsages, customAnnotations, allAnnotations) {
        this.name = name;
        this.type = type;
        this.subfields = subfields;
        this.allowedUsages = allowedUsages;
        this.customAnnotations = customAnnotations;
        this.allAnnotations = allAnnotations;
    }
    toManifestString(builder = new IndentingStringBuilder()) {
        builder.push(...this.allAnnotations.map(annotation => annotation.toString()));
        if (this.subfields.length) {
            builder.push(`${this.name} {`);
            this.subfields.forEach(field => field.toManifestString(builder.withIndent()));
            builder.push('},');
        }
        else {
            builder.push(`${this.name},`);
        }
        return builder.toString();
    }
    static fromAstNode(node, parentType, buildAnnotationRefs) {
        // Validate field name against type.
        const type = resolveFieldPathType([node.name], parentType);
        // Convert subfields.
        checkNamesAreUnique(node.subfields);
        const subfields = node.subfields.map(field => policy_PolicyField.fromAstNode(field, type, buildAnnotationRefs));
        // Process annotations.
        const allAnnotations = buildAnnotationRefs(node.annotationRefs);
        const usages = new Map();
        const allowedUsages = [];
        const customAnnotations = [];
        for (const annotation of allAnnotations) {
            switch (annotation.name) {
                case allowedUsageAnnotationName: {
                    const allowedUsage = this.toAllowedUsage(annotation);
                    if (!usages.has(allowedUsage.label)) {
                        usages.set(allowedUsage.label, new Set());
                    }
                    const usageTypes = usages.get(allowedUsage.label);
                    if (usageTypes.has(allowedUsage.usage)) {
                        throw new Error(`Usage of label '${allowedUsage.label}' for usage type '${allowedUsage.usage}' has already been allowed.`);
                    }
                    usageTypes.add(allowedUsage.usage);
                    allowedUsages.push(allowedUsage);
                    break;
                }
                default:
                    customAnnotations.push(annotation);
                    break;
            }
        }
        if (allowedUsages.length === 0) {
            allowedUsages.push({ label: '', usage: PolicyAllowedUsageType.Any });
        }
        return new policy_PolicyField(node.name, type, subfields, allowedUsages, customAnnotations, allAnnotations);
    }
    static toAllowedUsage(annotation) {
        external_assert_default()(annotation.name === allowedUsageAnnotationName);
        const usageType = annotation.params['usageType'];
        checkValueInEnum(usageType, PolicyAllowedUsageType);
        const label = annotation.params['label'];
        return {
            usage: usageType,
            label: label === 'raw' ? '' : label,
        };
    }
    // Returns policy fields in the format of Schema fields.
    toSchemaFields(parentType) {
        const field = parentType.getEntitySchema().fields[this.name];
        return { name: this.name, field: this.toSchemaField(field) };
    }
    toSchemaField(field) {
        switch (field.kind) {
            case 'kotlin-primitive':
            case 'schema-primitive': {
                external_assert_default()(this.subfields.length === 0);
                return field;
            }
            case 'schema-collection':
            case 'schema-ordered-list':
            case 'schema-nested': {
                return schema_field_FieldType.create({ kind: field.kind, schema: this.toSchemaField(field.schema) });
            }
            case 'schema-reference': {
                return new schema_field_ReferenceField(new schema_field_InlineField(this.restrictedEntityType(field.getEntityType())));
            }
            case 'type-name':
            case 'schema-inline': {
                const entityType = field.getEntityType();
                if (entityType == null)
                    return this;
                return new schema_field_InlineField(this.restrictedEntityType(entityType));
            }
            // TODO(bgogul): `field-path` does not support these types yet.
            // case 'schema-union':
            // case 'schema-tuple':
            //   return FieldType.create({
            //     ...field,
            //     types: field.getFieldTypes().map(t => this.toSchemaField(t))
            //   });
            default: {
                external_assert_default()(`Unsupported field kind: ${field.kind}`);
            }
        }
    }
    restrictedEntityType(entityType) {
        external_assert_default()(entityType != null);
        const restrictedFields = {};
        const schema = entityType.entitySchema;
        for (const subfield of this.subfields) {
            restrictedFields[subfield.name] =
                subfield.toSchemaField(schema.fields[subfield.name]);
        }
        return type_EntityType.make(schema.names, restrictedFields, schema);
    }
}
class policy_PolicyConfig {
    constructor(name, metadata) {
        this.name = name;
        this.metadata = metadata;
    }
    toManifestString(builder = new IndentingStringBuilder()) {
        builder.push(`config ${this.name} {`);
        builder.withIndent(builder => {
            for (const [k, v] of this.metadata) {
                builder.push(`${k}: '${v}'`);
            }
        });
        builder.push('}');
        return builder.toString();
    }
    static fromAstNode(node) {
        return new policy_PolicyConfig(node.name, node.metadata);
    }
}
/** Checks that the given value is an element in the given enum. Throws otherwise. */
function checkValueInEnum(value, enumDef) {
    const keys = Object.keys(enumDef).filter(key => typeof key === 'string');
    const values = keys.map(key => enumDef[key]);
    if (!(values.includes(value))) {
        throw new Error(`Expected one of: ${values.join(', ')}. Found: ${value}.`);
    }
}
/** Checks that the given AST nodes have unique names. Throws otherwise. */
function checkNamesAreUnique(nodes) {
    const names = new Set();
    for (const node of nodes) {
        if (names.has(node.name)) {
            throw new Error(`A definition for '${node.name}' already exists.`);
        }
        names.add(node.name);
    }
}
//# sourceMappingURL=policy.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/manifest.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
























var ErrorSeverity;
(function (ErrorSeverity) {
    ErrorSeverity["Error"] = "error";
    ErrorSeverity["Warning"] = "warning";
})(ErrorSeverity || (ErrorSeverity = {}));
class ManifestError extends Error {
    constructor(location, message) {
        super(message);
        this.severity = ErrorSeverity.Error;
        this.location = location;
    }
}
class ManifestWarning extends ManifestError {
    constructor(location, message) {
        super(location, message);
        this.severity = ErrorSeverity.Warning;
    }
}
/**
 * Calls `this.visit()` for each node in a manfest AST, parents before children.
 */
class manifest_ManifestVisitor {
    traverse(ast) {
        if (['string', 'number', 'bigint', 'boolean'].includes(typeof ast) || ast === null) {
            return;
        }
        if (ast instanceof Array) {
            for (const item of ast) {
                this.traverse(item);
            }
            return;
        }
        if (ast instanceof Map) {
            for (const value of ast.values()) {
                this.traverse(value);
            }
            return;
        }
        external_assert_default()(ast.location, 'expected manifest node to have `location`');
        external_assert_default()(ast.kind, 'expected manifest node to have `kind`');
        if (ast.kind === 'entity-inline') {
            // This node holds an inline entity and will be handled by _processStore().
            return;
        }
        let childrenVisited = false;
        const visitChildren = () => {
            if (childrenVisited) {
                return;
            }
            childrenVisited = true;
            for (const key of Object.keys(ast)) {
                if (['location', 'kind', 'model'].includes(key)) {
                    continue;
                }
                this.traverse(ast[key]);
            }
        };
        this.visit(ast, visitChildren);
        visitChildren();
    }
    // Parents are visited before children, but an implementation can force
    // children to be visited by calling `visitChildren()`.
    visit(node, visitChildren) {
    }
}
const globalWarningKeys = new Set();
class manifest_Manifest {
    constructor({ id }) {
        this._recipes = [];
        this._imports = [];
        this._canonicalImports = [];
        // TODO: These should be lists, possibly with a separate flattened map.
        this._particles = {};
        this._schemas = {};
        this.storeInfoById = {};
        // Map from each store ID to a set of tags. public for debug access
        this.storeTagsById = {};
        this._interfaces = [];
        this._policies = [];
        this._fileName = null;
        // TODO(csilvestrini): Inject an IdGenerator instance instead of creating a new one.
        this.idGenerator = id_IdGenerator.newSession();
        this._meta = new ManifestMeta();
        this._resources = {};
        this.storeManifestUrls = new Map();
        this.errors = [];
        this._annotations = {};
        // TODO: Cleanup usage of strings as Ids.
        external_assert_default()(id instanceof Id || typeof id === 'string');
        if (id instanceof Id) {
            this._id = id;
        }
        else {
            // We use the first component of an ID as a session ID, for manifests parsed
            // from the file, this is the 'manifest' phrase.
            // TODO: Figure out if this is ok, and stop using internal Id APIs.
            const components = id.split(':');
            this._id = Id._newIdInternal(components[0], components.slice(1));
        }
        this.generateID = (subcomponent) => this.idGenerator.newChildId(this.id, subcomponent);
    }
    get id() {
        if (this._meta.name) {
            return Id.fromString(this._meta.name);
        }
        return this._id;
    }
    get recipes() {
        return this._recipes;
    }
    get allRecipes() {
        return [...new Set(this._findAll(manifest => manifest._recipes))];
    }
    get activeRecipe() {
        return this._recipes.find(recipe => recipe.getAnnotation('active'));
    }
    get particles() {
        return Object.values(this._particles);
    }
    get allParticles() {
        return [...new Set(this._findAll(manifest => Object.values(manifest._particles)))];
    }
    get imports() {
        return this._imports;
    }
    get canonicalImports() {
        return this._canonicalImports;
    }
    get schemas() {
        return this._schemas;
    }
    get allSchemas() {
        return [...new Set(this._findAll(manifest => Object.values(manifest._schemas)))];
    }
    get fileName() {
        return this._fileName;
    }
    get stores() {
        return Object.values(this.storeInfoById);
    }
    get allStores() {
        return [...this._findAll(manifest => manifest.stores)];
    }
    get interfaces() {
        return this._interfaces;
    }
    get policies() {
        return this._policies;
    }
    get allPolicies() {
        return [...new Set(this._findAll(manifest => manifest._policies))];
    }
    get meta() {
        return this._meta;
    }
    get resources() {
        return this._resources;
    }
    get allResources() {
        return [...new Set(this._findAll(manifest => Object.entries(manifest.resources).map(([name, resource]) => ({ name, resource }))))];
    }
    get annotations() {
        return this._annotations;
    }
    get allAnnotations() {
        return [...new Set(this._findAll(manifest => Object.values(manifest.annotations)))];
    }
    findAnnotationByName(name) {
        return this.allAnnotations.find(a => a.name === name);
    }
    applyMeta(section) {
        this._meta.apply(section);
    }
    // TODO: newParticle, Schema, etc.
    // TODO: simplify() / isValid().
    _addStore(store, tags) {
        this.storeInfoById[store.id] = store;
        this.storeTagsById[store.id] = new Set(tags ? tags : []);
        return store;
    }
    newStore(opts) {
        if (opts.source) {
            this.storeManifestUrls.set(opts.id, this.fileName);
        }
        let storageKey = opts.storageKey;
        if (typeof storageKey === 'string') {
            storageKey = StorageKeyParser.parse(storageKey);
        }
        const store = new store_info_StoreInfo({ ...opts, storageKey, exists: Exists.MayExist });
        return this._addStore(store, opts.tags);
    }
    _find(manifestFinder) {
        let result = manifestFinder(this);
        if (!result) {
            for (const importedManifest of this._imports) {
                result = importedManifest._find(manifestFinder);
                if (result) {
                    break;
                }
            }
        }
        return result;
    }
    *_findAll(manifestFinder) {
        yield* manifestFinder(this);
        for (const importedManifest of [...this._imports, ...this._canonicalImports]) {
            yield* importedManifest._findAll(manifestFinder);
        }
    }
    findSchemaByName(name) {
        return this._find(manifest => manifest._schemas[name]);
    }
    findTypeByName(name) {
        const schema = this.findSchemaByName(name);
        if (schema) {
            return new type_EntityType(schema);
        }
        const iface = this.findInterfaceByName(name);
        if (iface) {
            return new type_InterfaceType(iface);
        }
        return undefined;
    }
    findParticleByName(name) {
        return this._find(manifest => manifest._particles[name]);
    }
    findParticlesByVerb(verb) {
        return [...this._findAll(manifest => Object.values(manifest._particles).filter(particle => particle.primaryVerb === verb))];
    }
    findStoreByName(name) {
        return this._find(manifest => manifest.stores.find(store => store.name === name));
    }
    findStoreById(id) {
        return this._find(manifest => manifest.stores.find(store => store.id === id));
    }
    findStoreTags(storeInfo) {
        return new Set(this._find(manifest => manifest.storeTagsById[storeInfo.id]));
    }
    findManifestUrlForHandleId(id) {
        return this._find(manifest => manifest.storeManifestUrls.get(id));
    }
    findStoresByType(type, options = { tags: [], subtype: false }) {
        const tags = options.tags || [];
        const subtype = options.subtype || false;
        function tagPredicate(manifest, store) {
            return tags.filter(tag => !manifest.storeTagsById[store.id].has(tag)).length === 0;
        }
        const stores = [...this._findAll(manifest => manifest.stores.filter(store => this.typesMatch(store, type, subtype) && tagPredicate(manifest, store)))];
        // Quick check that a new handle can fulfill the type contract.
        // Rewrite of this method tracked by https://github.com/PolymerLabs/arcs/issues/1636.
        return stores.filter(s => !!effectiveTypeForHandle(type, [{ type: s.type, direction: (s.type instanceof type_InterfaceType) ? 'hosts' : 'reads writes' }]));
    }
    findHandlesByType(type, options = { tags: [], fates: [], subtype: false }) {
        const tags = options.tags || [];
        const subtype = options.subtype || false;
        const fates = options.fates || [];
        function hasAllTags(handle) {
            return tags.every(tag => handle.tags.includes(tag));
        }
        function matchesFate(handle) {
            return fates === [] || fates.includes(handle.fate);
        }
        // TODO(#4820) Update `reduce` to use flatMap
        return [...this.allRecipes
                .reduce((acc, r) => acc.concat(r.handles), [])
                .filter(h => this.typesMatch(h, type, subtype) && hasAllTags(h) && matchesFate(h))];
    }
    findInterfaceByName(name) {
        return this._find(manifest => manifest._interfaces.find(iface => iface.name === name));
    }
    findPolicyByName(name) {
        return this._find(manifest => manifest._policies.find(policy => policy.name === name));
    }
    findRecipesByVerb(verb) {
        return [...this._findAll(manifest => manifest._recipes.filter(recipe => recipe.verbs.includes(verb)))];
    }
    typesMatch(candidate, type, checkSubtype) {
        const resolvedType = type.resolvedType();
        if (!resolvedType.isResolved()) {
            return (type instanceof type_CollectionType) === (candidate.type instanceof type_CollectionType) &&
                (type instanceof type_BigCollectionType) === (candidate.type instanceof type_BigCollectionType);
        }
        if (checkSubtype) {
            const [left, right] = type_Type.unwrapPair(candidate.type, resolvedType);
            if (left instanceof type_EntityType && right instanceof type_EntityType) {
                return left.entitySchema.isAtLeastAsSpecificAs(right.entitySchema);
            }
            return false;
        }
        return type_checker_TypeChecker.compareTypes({ type: candidate.type }, { type });
    }
    static async load(fileName, loader, options = {}) {
        let { registry, memoryProvider } = options;
        registry = registry || {};
        if (registry && registry[fileName]) {
            return registry[fileName];
        }
        registry[fileName] = (async () => {
            const content = await loader.loadResource(fileName);
            // TODO: When does this happen? The loader should probably throw an exception here.
            external_assert_default()(content !== undefined, `${fileName} unable to be loaded by Manifest parser`);
            return manifest_Manifest.parse(content, { fileName, loader, registry, memoryProvider });
        })();
        return registry[fileName];
    }
    static getErrors(manifest) {
        return manifest.errors;
    }
    static async parse(content, options = {}) {
        // allow `context` for including an existing manifest in the import list
        let { fileName, loader, registry, context, memoryProvider } = options;
        registry = registry || {};
        const id = `manifest:${fileName}:`;
        function dumpErrors(manifest) {
            for (const error of manifest.errors) {
                // TODO: make a decision as to whether we should be logging these here, or if it should
                //       be a responsibility of the caller.
                // TODO: figure out how to have node print the correct message and stack trace
                if (error.key) {
                    if (globalWarningKeys.has(error.key)) {
                        continue;
                    }
                    globalWarningKeys.add(error.key);
                }
                console.warn(processError(error).message);
            }
        }
        // tslint:disable-next-line: no-any
        function processError(e, parseError) {
            if (!((e instanceof ManifestError) || e.location)) {
                return e;
            }
            return processManifestError(e, parseError);
        }
        function processManifestError(e, parseError) {
            const lines = content.split('\n');
            const line = lines[e.location.start.line - 1];
            // TODO(sjmiles): see https://github.com/PolymerLabs/arcs/issues/2570
            let message = e.message || '';
            if (line) {
                let span = 1;
                if (e.location.end.line === e.location.start.line) {
                    span = e.location.end.column - e.location.start.column;
                }
                else {
                    span = line.length - e.location.start.column;
                }
                span = Math.max(1, span);
                let highlight = '';
                for (let i = 0; i < e.location.start.column - 1; i++) {
                    highlight += ' ';
                }
                for (let i = 0; i < span; i++) {
                    highlight += '^';
                }
                let preamble;
                // Peg Parsing Errors don't have severity attached.
                const severity = e.severity || ErrorSeverity.Error;
                if (parseError) {
                    preamble = `Parse ${severity} in`;
                }
                else {
                    preamble = `Post-parse processing ${severity} caused by`;
                }
                const fileNameStr = fileName ? `'${fileName}'` : '<no filename>';
                message = `${preamble} ${fileNameStr} line ${e.location.start.line}.
${e.message}
  ${line}
  ${highlight}`;
            }
            const err = new ManifestError(e.location, message);
            if (!parseError) {
                err.stack = e.stack;
            }
            return err;
        } // end processManifestError
        let items = [];
        try {
            items = manifest_parser_parse(content, { filename: fileName });
        }
        catch (e) {
            throw processError(e, true);
        }
        const manifest = new manifest_Manifest({ id });
        manifest._fileName = fileName;
        // include (optional) pre-existing context
        if (context) {
            manifest._imports.push(context);
        }
        try {
            if (content !== canonicalManifest) {
                try {
                    manifest._canonicalImports.push(await manifest_Manifest.parse(canonicalManifest, options));
                }
                catch (e) {
                    manifest.errors.push(e);
                }
            }
            // Loading of imported manifests is triggered in parallel to avoid a serial loading
            // of resources over the network.
            await Promise.all(items.map(async (item) => {
                if (item.kind === 'import') {
                    if (!loader) {
                        throw new Error('loader required to parse import statements');
                    }
                    // item is an AstNode.Import
                    const path = loader.path(manifest.fileName);
                    const target = loader.join(path, item.path);
                    try {
                        manifest._imports.push(await manifest_Manifest.load(target, loader, { registry, memoryProvider }));
                    }
                    catch (e) {
                        manifest.errors.push(e);
                        manifest.errors.push(new ManifestError(item.location, `Error importing '${target}'`));
                    }
                }
            }));
            // The items to process may refer to items defined later on. We should do a pass over all
            // definitions first, and then resolve all the references to external definitions, but that
            // would require serious refactoring. As a short term fix we're doing multiple passes over
            // the list as long as we see progress.
            // TODO(b/156427820): Improve this with 2 pass schema resolution and support cycles.
            const processItems = async (kind, f, options = { augmentAst: true }) => {
                const itemsToProcess = items.filter(i => i.kind === kind);
                for (const item of itemsToProcess) {
                    if (options.augmentAst) {
                        manifest_Manifest._augmentAstWithTypes(manifest, item);
                    }
                    await f(item);
                }
            };
            await processItems('schema', item => manifest_Manifest._discoverSchema(manifest, item), { augmentAst: false });
            // processing meta sections should come first as this contains identifying
            // information that might need to be used in other sections. For example,
            // the meta.name, if present, becomes the manifest id which is relevant
            // when constructing manifest stores.
            await processItems('meta', meta => manifest.applyMeta(meta.items));
            // similarly, resources may be referenced from other parts of the manifest.
            await processItems('resource', item => manifest_Manifest._processResource(manifest, item));
            await processItems('annotation-node', item => manifest_Manifest._processAnnotation(manifest, item));
            await processItems('schema', item => manifest_Manifest._processSchema(manifest, item));
            await processItems('interface', item => manifest_Manifest._processInterface(manifest, item));
            await processItems('particle', item => manifest_Manifest._processParticle(manifest, item, loader));
            await processItems('store', item => manifest_Manifest._processStore(manifest, item, loader, memoryProvider));
            await processItems('policy', item => manifest_Manifest._processPolicy(manifest, item));
            await processItems('recipe', item => manifest_Manifest._processRecipe(manifest, item));
            manifest_Manifest._checkValidityOfRecursiveSchemas(manifest);
        }
        catch (e) {
            dumpErrors(manifest);
            throw processError(e, false);
        }
        dumpErrors(manifest);
        if (options.throwImportErrors) {
            const error = manifest.errors.find(e => e.severity === ErrorSeverity.Error);
            if (error) {
                throw error;
            }
        }
        return manifest;
    }
    static _augmentAstWithTypes(manifest, items) {
        const visitor = new class extends manifest_ManifestVisitor {
            constructor() {
                super();
            }
            visit(node, visitChildren) {
                // TODO(dstockwell): set up a scope and merge type variables here, so that
                //     errors relating to failed merges can reference the manifest source.
                visitChildren();
                this._checkStarFields(node);
                switch (node.kind) {
                    case 'schema-inline': {
                        const starCount = node.fields.filter(f => f.name === '*').length;
                        // Warn user if there are multiple '*'s.
                        if (starCount > 1) {
                            const warning = new ManifestWarning(node.location, `Only one '*' is needed.`);
                            warning.key = 'multiStarFields';
                            manifest.errors.push(warning);
                        }
                        // Flag used to determine if type variables should resolve to max type
                        if (starCount > 0) {
                            node.allFields = true;
                            node.fields = node.fields.filter(f => f.name !== '*');
                            // Avoid creating an empty schema in response to `{*}`.
                            if (node.fields.length === 0) {
                                return;
                            }
                        }
                        const schemas = [];
                        const aliases = [];
                        const names = [];
                        for (const name of node.names) {
                            const resolved = manifest.resolveTypeName(name);
                            if (resolved && resolved.schema && resolved.schema.isAlias) {
                                aliases.push(resolved.schema);
                            }
                            else {
                                names.push(name);
                            }
                            if (resolved && resolved.schema) {
                                schemas.push(resolved.schema);
                            }
                        }
                        // tslint:disable-next-line: no-any
                        const fields = {};
                        const typeData = {};
                        for (let { name, type } of node.fields) {
                            if (type && type.refinement) {
                                try {
                                    type.refinement = refiner_Refinement.fromAst(type.refinement, { [name]: type.type });
                                }
                                catch (e) {
                                    throw new ManifestError(node.location, e.message);
                                }
                            }
                            for (const schema of schemas) {
                                if (!type) {
                                    // If we don't have a type, try to infer one from the schema.
                                    type = schema.fields[name];
                                }
                                else {
                                    // Validate that the specified or inferred type matches the schema.
                                    const externalType = schema.fields[name];
                                    type = schema_field_FieldType.create(type);
                                    if (externalType && !externalType.isAtLeastAsSpecificAs(type)) {
                                        throw new ManifestError(node.location, `Type of '${name}' does not match schema (${type} vs ${externalType})`);
                                    }
                                }
                            }
                            if (!type) {
                                throw new ManifestError(node.location, `Could not infer type of '${name}' field`);
                            }
                            fields[name] = type;
                            typeData[name] = type.type;
                        }
                        const refinement = node.refinement && refiner_Refinement.fromAst(node.refinement, typeData);
                        let schema = new schema_Schema(names, fields, { refinement });
                        for (const alias of aliases) {
                            schema = schema_Schema.union(alias, schema);
                            if (!schema) {
                                throw new ManifestError(node.location, `Could not merge schema aliases`);
                            }
                        }
                        node.model = new type_EntityType(schema);
                        delete node.fields;
                        return;
                    }
                    case 'variable-type': {
                        const constraint = node.constraint && node.constraint.model;
                        // If true, type variable should resolve to max type (i.e. `~a with {*}` syntax support)
                        const toMaxType = node.constraint && node.constraint.kind === 'schema-inline' && !!node.constraint.allFields;
                        node.model = type_TypeVariable.make(node.name, constraint, null, toMaxType);
                        return;
                    }
                    case 'slot-type': {
                        const fields = {};
                        for (const fieldIndex of Object.keys(node.fields)) {
                            const field = node.fields[fieldIndex];
                            fields[field.name] = field.value;
                        }
                        node.model = type_SlotType.make(fields['formFactor'], fields['handle']);
                        return;
                    }
                    case 'type-name': {
                        const resolved = manifest.resolveTypeName(node.name);
                        if (!resolved) {
                            throw new ManifestError(node.location, `Could not resolve type reference to type name '${node.name}'`);
                        }
                        if (resolved.schema) {
                            node.model = new type_EntityType(resolved.schema);
                        }
                        else if (resolved.iface) {
                            node.model = new type_InterfaceType(resolved.iface);
                        }
                        else {
                            throw new ManifestError(node.location, 'Expected {iface} or {schema}');
                        }
                        return;
                    }
                    case 'collection-type':
                        node.model = new type_CollectionType(node.type.model);
                        return;
                    case 'big-collection-type':
                        node.model = new type_BigCollectionType(node.type.model);
                        return;
                    case 'reference-type':
                        node.model = new type_ReferenceType(node.type.model);
                        return;
                    case 'mux-type':
                        node.model = new type_MuxType(node.type.model);
                        return;
                    case 'singleton-type':
                        node.model = new type_SingletonType(node.type.model);
                        return;
                    case 'tuple-type':
                        node.types.forEach(this._checkStarFields);
                        node.model = new type_TupleType(node.types.map(t => t.model));
                        return;
                    default:
                        return;
                }
            }
            // Asserts that '*' inline fields can only appear on type variable constraints.
            _checkStarFields(node) {
                if (node.kind === 'variable-type')
                    return;
                if (node.type && node.type.kind === 'schema-inline' && node.type.allFields) {
                    throw new ManifestError(node.type.location, `Only type variables may have '*' fields.`);
                }
            }
        }();
        visitor.traverse(items);
    }
    static _checkValidityOfRecursiveSchemas(manifest) {
        if (Flags.recursiveSchemasAllowed) {
            return; // No further checking needed
        }
        for (const schema of Object.values(manifest.schemas)) {
            const referenced = new Set();
            const visit = (schema) => {
                // visit fields
                for (const field of Object.values(schema.fields)) {
                    const entityType = field.getEntityType();
                    if (entityType == null) {
                        // ignore Primitive types
                        continue;
                    }
                    const fieldType = entityType.getEntitySchema();
                    if (referenced.has(fieldType.name)) {
                        return; // already visited
                    }
                    referenced.add(fieldType.name);
                    visit(fieldType);
                }
            };
            visit(schema);
            if (referenced.has(schema.name)) {
                throw new ManifestError(schema.location, `Recursive schemas are unsuported, unstable support can be enabled via the 'recursiveSchemasAllowed' flag: ${schema.name}`);
            }
        }
    }
    static _discoverSchema(manifest, schemaItem) {
        const names = [...schemaItem.names];
        const name = schemaItem.alias || names[0];
        if (!name) {
            throw new ManifestError(schemaItem.location, `Schema defined without name or alias`);
        }
        const schema = new schema_Schema(names, {}, {});
        schema.location = schemaItem.location;
        manifest._schemas[name] = schema;
    }
    static _processSchema(manifest, schemaItem) {
        let description;
        const fields = {};
        let names = [...schemaItem.names];
        const name = schemaItem.alias || names[0]; // Don't use the parent names.
        const schema = manifest._schemas[name];
        if (!name) {
            throw new ManifestError(schemaItem.location, `Schema defined without name or alias`);
        }
        for (const item of schemaItem.items) {
            switch (item.kind) {
                case 'schema-field': {
                    const field = item;
                    if (fields[field.name]) {
                        throw new ManifestError(field.location, `Duplicate definition of field '${field.name}'`);
                    }
                    fields[field.name] = field.type;
                    if (fields[field.name].refinement) {
                        fields[field.name].refinement = refiner_Refinement.fromAst(fields[field.name].refinement, { [field.name]: field.type.type });
                    }
                    if (fields[field.name].annotations) {
                        fields[field.name].annotations = manifest_Manifest._buildAnnotationRefs(manifest, fields[field.name].annotations);
                    }
                    break;
                }
                case 'description': {
                    if (description) {
                        throw new ManifestError(item.location, `Duplicate schema description`);
                    }
                    description = item;
                    break;
                }
                default:
                    throw new ManifestError(item.location, `unknown parser artifact ${item.kind} while processing schema`);
            }
        }
        for (const parent of schemaItem.parents) {
            const result = manifest.findSchemaByName(parent);
            if (!result) {
                throw new ManifestError(schemaItem.location, `Could not find parent schema '${parent}'`);
            }
            for (const [name, type] of Object.entries(result.fields)) {
                if (fields[name] && !fields[name].equals(type)) {
                    throw new ManifestError(schemaItem.location, `'${parent}' defines incompatible type for field '${name}'`);
                }
            }
            Object.assign(fields, result.fields);
            names.push(...result.names);
        }
        names = [...new Set([...names])]; // Sort and de-duplicate the names
        const annotations = manifest_Manifest._buildAnnotationRefs(manifest, schemaItem.annotationRefs);
        manifest._schemas[name] = schema;
        const updatedSchema = new schema_Schema(names, fields, { description, annotations });
        updatedSchema.location = schemaItem.location;
        if (schemaItem.alias) {
            updatedSchema.isAlias = true;
        }
        // In place, update the fields of schema.
        Object.assign(schema, updatedSchema);
    }
    static _processResource(manifest, schemaItem) {
        manifest._resources[schemaItem.name] = schemaItem.data;
    }
    static _processAnnotation(manifest, annotationItem) {
        const params = {};
        for (const param of annotationItem.params) {
            params[param.name] = param.type;
        }
        manifest._annotations[annotationItem.name] = new annotation_Annotation(annotationItem.name, params, annotationItem.targets, annotationItem.retention, annotationItem.allowMultiple, annotationItem.doc);
    }
    static _processParticle(manifest, particleItem, loader) {
        // TODO: we should be producing a new particleSpec, not mutating
        //       particleItem directly.
        // TODO: we should require both of these and update failing tests...
        external_assert_default()(particleItem.implFile == null || particleItem.args !== null, 'no valid body defined for this particle');
        if (!particleItem.args) {
            particleItem.args = [];
        }
        if (particleItem.hasParticleArgument) {
            const warning = new ManifestWarning(particleItem.location, `Particle uses deprecated argument body`);
            warning.key = 'hasParticleArgument';
            manifest.errors.push(warning);
        }
        if (particleItem.implFile
            && particleItem.implFile.startsWith('.')
            && manifest.meta.namespace) {
            const classpath = manifest.meta.namespace + particleItem.implFile;
            if (loader_node_Loader.isJvmClasspath(classpath)) {
                particleItem.implFile = classpath;
            }
        }
        // TODO: loader should not be optional.
        if (particleItem.implFile /*&& loader*/) {
            if (!loader_node_Loader.isJvmClasspath(particleItem.implFile)) {
                particleItem.implFile = (loader || loader_node_Loader).join(manifest.fileName, particleItem.implFile);
            }
        }
        const processArgTypes = args => {
            for (const arg of args) {
                // TOOD(sjmiles): extremely noisy warning here, since many canonical schemas
                // still use deprecated syntax.
                if (arg.type && arg.type.kind === 'type-name'
                    // For now let's focus on entities, we should do interfaces next.
                    && arg.type.model && arg.type.model.tag === 'Entity') {
                    const warning = new ManifestWarning(arg.location, `Particle uses deprecated external schema`);
                    warning.key = 'externalSchemas';
                    manifest.errors.push(warning);
                }
                arg.type = arg.type.model;
                if (arg.type.getEntitySchema()) {
                    const manifestSchema = manifest.findSchemaByName(arg.type.getEntitySchema().name);
                    const fields = arg.type.getEntitySchema().fields;
                    for (const name of Object.keys(fields)) {
                        // If we have an external schema, annotations were already converted.
                        if (!manifestSchema || !manifestSchema.fields[name]) {
                            fields[name].annotations = manifest_Manifest._buildAnnotationRefs(manifest, fields[name].annotations);
                        }
                    }
                }
                processArgTypes(arg.dependentConnections);
                arg.annotations = manifest_Manifest._buildAnnotationRefs(manifest, arg.annotations);
                // TODO: Validate that the type of the expression matches the declared type.
                arg.expression = arg.expression && arg.expression.unparsedPaxelExpression;
            }
        };
        if (particleItem.implFile && particleItem.args.some(arg => !!arg.expression)) {
            const arg = particleItem.args.find(arg => !!arg.expression);
            throw new ManifestError(arg.expression.location, `A particle with implementation cannot use result expressions.`);
        }
        processArgTypes(particleItem.args);
        particleItem.annotations = manifest_Manifest._buildAnnotationRefs(manifest, particleItem.annotationRefs);
        particleItem.manifestNamespace = manifest.meta.namespace;
        manifest._particles[particleItem.name] = new particle_spec_ParticleSpec(particleItem);
    }
    // TODO: Move this to a generic pass over the AST and merge with resolveTypeName.
    static _processInterface(manifest, interfaceItem) {
        const handles = [];
        for (const arg of interfaceItem.args) {
            const handle = { name: undefined, type: undefined, direction: arg.direction };
            if (arg.name !== '*') {
                handle.name = arg.name;
            }
            if (arg.type) {
                handle.type = arg.type.model;
            }
            handles.push(handle);
        }
        const slots = [];
        for (const slotItem of interfaceItem.slots) {
            slots.push({
                direction: slotItem.direction,
                name: slotItem.name,
                isRequired: slotItem.isRequired,
                isSet: slotItem.isSet
            });
        }
        // TODO: move interface to recipe/ and add interface builder?
        const ifaceInfo = type_InterfaceInfo.make(interfaceItem.name, handles, slots);
        manifest._interfaces.push(ifaceInfo);
    }
    static _processPolicy(manifest, policyItem) {
        const buildAnnotationRefs = (refs) => manifest_Manifest._buildAnnotationRefs(manifest, refs);
        const findTypeByName = (name) => manifest.findTypeByName(name);
        const policy = policy_Policy.fromAstNode(policyItem, buildAnnotationRefs, findTypeByName);
        if (manifest._policies.some(p => p.name === policy.name)) {
            throw new ManifestError(policyItem.location, `A policy named ${policy.name} already exists.`);
        }
        manifest._policies.push(policy);
    }
    static _processRecipe(manifest, recipeItem) {
        const recipe = manifest._newRecipe(recipeItem.name);
        recipe.annotations = manifest_Manifest._buildAnnotationRefs(manifest, recipeItem.annotationRefs);
        if (recipeItem.verbs) {
            recipe.verbs = recipeItem.verbs;
        }
        manifest_Manifest._buildRecipe(manifest, recipe, recipeItem.items, recipeItem.location);
    }
    static _buildRecipe(manifest, recipe, recipeItems, location) {
        const items = {
            require: recipeItems.filter(item => item.kind === 'require'),
            handles: recipeItems.filter(item => item.kind === 'handle'),
            syntheticHandles: recipeItems.filter(item => item.kind === 'synthetic-handle'),
            byHandle: new Map(),
            // requireHandles are handles constructed by the 'handle' keyword. This is intended to replace handles.
            requireHandles: recipeItems.filter(item => item.kind === 'require-handle'),
            particles: recipeItems.filter(item => item.kind === 'recipe-particle'),
            byParticle: new Map(),
            slots: recipeItems.filter(item => item.kind === 'slot'),
            bySlot: new Map(),
            // tslint:disable-next-line: no-any
            byName: new Map(),
            connections: recipeItems.filter(item => item.kind === 'connection'),
            search: recipeItems.find(item => item.kind === 'search'),
            description: recipeItems.find(item => item.kind === 'description')
        };
        // A recipe should either source handles by the 'handle' keyword (requireHandle item) or use fates (handle item).
        // A recipe should not use both methods.
        external_assert_default()(!(items.handles.length > 0 && items.requireHandles.length > 0), `Inconsistent handle definitions`);
        const itemHandles = (items.handles.length > 0 ? items.handles : items.requireHandles);
        for (const item of itemHandles) {
            const handle = recipe.newHandle();
            const ref = item.ref;
            if (ref.id) {
                handle.id = ref.id;
                const targetStore = manifest.findStoreById(handle.id);
                if (targetStore) {
                    handle.mapToStorage(targetStore);
                }
            }
            else if (ref.name) {
                const targetStore = manifest.findStoreByName(ref.name);
                // TODO: Error handling.
                external_assert_default()(targetStore, `Could not find handle ${ref.name}`);
                handle.mapToStorage(targetStore);
            }
            handle.tags = ref.tags;
            if (item.name) {
                external_assert_default()(!items.byName.has(item.name), `duplicate handle name: ${item.name}`);
                handle.localName = item.name;
                items.byName.set(item.name, { item, handle });
            }
            handle.fate = item.kind === 'handle' && item.fate ? item.fate : null;
            if (item.kind === 'handle') {
                if (item.annotations) {
                    handle.annotations = manifest_Manifest._buildAnnotationRefs(manifest, item.annotations);
                }
            }
            items.byHandle.set(handle, item);
        }
        for (const item of items.syntheticHandles) {
            const handle = recipe.newHandle();
            handle.fate = 'join';
            if (item.name) {
                external_assert_default()(!items.byName.has(item.name), `duplicate handle name: ${item.name}`);
                handle.localName = item.name;
                items.byName.set(item.name, { item, handle });
            }
            for (const association of item.associations) {
                const associatedItem = items.byName.get(association);
                external_assert_default()(associatedItem, `unrecognized name: ${association}`);
                const associatedHandle = associatedItem && associatedItem.handle;
                external_assert_default()(associatedHandle, `only handles allowed to be joined: "${association}" is not a handle`);
                handle.joinDataFromHandle(associatedHandle);
            }
            items.byHandle.set(handle, item);
        }
        const prepareEndpoint = (connection, info) => {
            switch (info.targetType) {
                case 'particle': {
                    const particle = manifest.findParticleByName(info.particle);
                    if (!particle) {
                        throw new ManifestError(connection.location, `could not find particle '${info.particle}'`);
                    }
                    if (info.param !== null && !particle.handleConnectionMap.has(info.param)) {
                        throw new ManifestError(connection.location, `param '${info.param}' is not defined by '${info.particle}'`);
                    }
                    return newParticleEndPoint(particle, info.param);
                }
                case 'localName': {
                    if (!items.byName.has(info.name)) {
                        throw new ManifestError(connection.location, `local name '${info.name}' does not exist in recipe`);
                    }
                    if (info.param == null && info.tags.length === 0 &&
                        items.byName.get(info.name).handle) {
                        return newHandleEndPoint(items.byName.get(info.name).handle);
                    }
                    throw new ManifestError(connection.location, `references to particles by local name not yet supported`);
                }
                case 'tag': {
                    return newTagEndPoint(info.tags);
                }
                default:
                    throw new ManifestError(connection.location, `endpoint ${info.targetType} not supported`);
            }
        };
        for (const connection of items.connections) {
            const from = prepareEndpoint(connection, connection.from);
            const to = prepareEndpoint(connection, connection.to);
            recipe.newConnectionConstraint(from, to, connection.direction, connection.relaxed);
        }
        if (items.search) {
            recipe.search = newSearch(items.search.phrase, items.search.tokens);
        }
        for (const item of items.slots) {
            // TODO(mmandlis): newSlot requires a name. What should the name be here?
            const slot = recipe.newSlot(undefined);
            if (item.ref.id) {
                slot.id = item.ref.id;
            }
            if (item.ref.tags) {
                slot.tags = item.ref.tags;
            }
            if (item.name) {
                external_assert_default()(!items.byName.has(item.name), `Duplicate slot local name ${item.name}`);
                slot.localName = item.name;
                items.byName.set(item.name, slot);
            }
            items.bySlot.set(slot, item);
        }
        // TODO: disambiguate.
        for (const item of items.particles) {
            const particle = recipe.newParticle(item.ref.name);
            particle.verbs = item.ref.verbs;
            if (!(recipe.isRequireSection)) {
                if (item.ref.name) {
                    const spec = manifest.findParticleByName(item.ref.name);
                    if (!spec) {
                        throw new ManifestError(item.location, `could not find particle ${item.ref.name}`);
                    }
                    particle.spec = spec.clone();
                }
            }
            if (item.name) {
                // TODO: errors.
                external_assert_default()(!items.byName.has(item.name));
                particle.localName = item.name;
                items.byName.set(item.name, { item, particle });
            }
            items.byParticle.set(particle, item);
            for (const slotConnectionItem of item.slotConnections) {
                if (slotConnectionItem.direction === 'provides') {
                    throw new ManifestError(item.location, `invalid slot connection: provide slot must be dependent`);
                }
                let slotConn = particle.getSlotConnectionByName(slotConnectionItem.param);
                if (!slotConn) {
                    // particles that reference verbs should store slot connection information as constraints to be used
                    // during verb matching. However, if there's a spec then the slots need to be validated against it
                    // instead.
                    if (particle.spec !== undefined) {
                        // Validate consumed and provided slots names are according to spec.
                        if (!particle.spec.slotConnections.has(slotConnectionItem.param)) {
                            throw new ManifestError(slotConnectionItem.location, `Consumed slot '${slotConnectionItem.param}' is not defined by '${particle.name}'`);
                        }
                        slotConnectionItem.dependentSlotConnections.forEach(ps => {
                            if (!particle.spec.hasSlotConnectionName(ps.param)) {
                                throw new ManifestError(ps.location, `Provided slot '${ps.param}' is not defined by '${particle.name}'`);
                            }
                        });
                    }
                    slotConn = particle.addSlotConnection(slotConnectionItem.param);
                }
                slotConn.tags = slotConnectionItem.target.tags;
                slotConnectionItem.dependentSlotConnections.forEach(ps => {
                    if (ps.direction === 'consumes') {
                        throw new ManifestError(item.location, `invalid slot connection: consume slot must not be dependent`);
                    }
                    if (ps.dependentSlotConnections.length !== 0) {
                        throw new ManifestError(item.location, `invalid slot connection: provide slot must not have dependencies`);
                    }
                    if (recipe.isRequireSection) {
                        // replace provided slot if it already exist in recipe.
                        const existingSlot = recipe.parent.slots.find(rslot => rslot.localName === ps.target.name);
                        if (existingSlot !== undefined) {
                            slotConn.providedSlots[ps.param] = existingSlot;
                            existingSlot.sourceConnection = slotConn;
                            existingSlot.name = ps.param;
                        }
                    }
                    let providedSlot = slotConn.providedSlots[ps.param];
                    if (providedSlot) {
                        if (ps.target.name) {
                            if (items.byName.has(ps.target.name)) {
                                // The slot was added to the recipe twice - once as part of the
                                // slots in the manifest, then as part of particle spec.
                                // Unifying both slots, updating name and source slot connection.
                                const theSlot = items.byName.get(ps.target.name);
                                external_assert_default()(theSlot !== providedSlot);
                                external_assert_default()(!theSlot.name && providedSlot);
                                external_assert_default()(!theSlot.sourceConnection && providedSlot.sourceConnection);
                                providedSlot.id = theSlot.id;
                                providedSlot.tags = theSlot.tags;
                                items.byName.set(ps.target.name, providedSlot);
                                recipe.removeSlot(theSlot);
                            }
                            else {
                                items.byName.set(ps.target.name, providedSlot);
                            }
                        }
                        items.bySlot.set(providedSlot, ps);
                    }
                    else {
                        providedSlot = items.byName.get(ps.target.name);
                    }
                    if (!providedSlot) {
                        providedSlot = recipe.newSlot(ps.param);
                        providedSlot.localName = ps.target.name;
                        providedSlot.sourceConnection = slotConn;
                        if (ps.target.name) {
                            external_assert_default()(!items.byName.has(ps.target.name));
                            items.byName.set(ps.target.name, providedSlot);
                        }
                        items.bySlot.set(providedSlot, ps);
                    }
                    if (!slotConn.providedSlots[ps.param]) {
                        slotConn.providedSlots[ps.param] = providedSlot;
                    }
                    providedSlot.localName = ps.target.name;
                });
            }
        }
        const newConnection = (particle, connectionItem) => {
            let connection;
            // Find or create the connection.
            if (connectionItem.param === '*') {
                connection = particle.addUnnamedConnection();
            }
            else {
                connection = particle.connections[connectionItem.param];
                if (!connection) {
                    connection = particle.addConnectionName(connectionItem.param);
                }
                // TODO: else, merge tags? merge directions?
            }
            connection.tags = connectionItem.target ? connectionItem.target.tags : [];
            const direction = connectionItem.direction;
            if (!connectionMatchesHandleDirection(direction, connection.direction)) {
                throw new ManifestError(connectionItem.location, `'${direction}' not compatible with '${connection.direction}' param of '${particle.name}'`);
            }
            else if (connection.direction === 'any') {
                if (connectionItem.param !== '*' && particle.spec !== undefined) {
                    throw new ManifestError(connectionItem.location, `param '${connectionItem.param}' is not defined by '${particle.name}'`);
                }
                connection.direction = direction;
            }
            // TODO(cypher1): If particle handle connections are able to be relaxed this will need to be expanded to
            // perform relaxation matching.
            connection.relaxed = connectionItem.relaxed;
            let targetHandle;
            let targetParticle;
            if (connectionItem.target && connectionItem.target.name) {
                let entry = items.byName.get(connectionItem.target.name);
                if (!entry) {
                    const handle = recipe.newHandle();
                    handle.tags = [];
                    handle.localName = connectionItem.target.name;
                    if (connection.direction === '`consumes' || connection.direction === '`provides') {
                        // TODO(jopra): This is something of a hack to catch users who have not forward-declared their slandles.
                        handle.fate = '`slot';
                    }
                    else {
                        handle.fate = 'create';
                    }
                    // TODO: item does not exist on handle.
                    handle['item'] = { kind: 'handle' };
                    entry = { item: handle['item'], handle };
                    items.byName.set(handle.localName, entry);
                    items.byHandle.set(handle, handle['item']);
                }
                else if (!entry.item) {
                    throw new ManifestError(connectionItem.location, `did not expect '${entry}' expected handle or particle`);
                }
                if (entry.item.kind === 'handle'
                    || entry.item.kind === 'synthetic-handle'
                    || entry.item.kind === 'require-handle') {
                    targetHandle = entry.handle;
                }
                else if (entry.item.kind === 'particle') {
                    targetParticle = entry.particle;
                }
                else {
                    throw new ManifestError(connectionItem.location, `did not expect ${entry.item.kind}`);
                }
            }
            // Handle implicit handle connections in the form `param = SomeParticle`
            if (connectionItem.target && connectionItem.target.particle) {
                const hostedParticle = manifest.findParticleByName(connectionItem.target.particle);
                if (!hostedParticle) {
                    throw new ManifestError(connectionItem.target.location, `Could not find hosted particle '${connectionItem.target.particle}'`);
                }
                targetHandle = constructImmediateValueHandle(connection, hostedParticle, manifest.generateID());
                if (!targetHandle) {
                    throw new ManifestError(connectionItem.target.location, `Hosted particle '${hostedParticle.name}' does not match interface '${connection.name}'`);
                }
            }
            if (targetParticle) {
                let targetConnection;
                // TODO(lindner): replaced param with name since param is not defined, but name/particle are...
                if (connectionItem.target.name) {
                    targetConnection = targetParticle.connections[connectionItem.target.name];
                    if (!targetConnection) {
                        targetConnection = targetParticle.addConnectionName(connectionItem.target.name);
                        // TODO: direction?
                    }
                }
                else {
                    targetConnection = targetParticle.addUnnamedConnection();
                    // TODO: direction?
                }
                targetHandle = targetConnection.handle;
                if (!targetHandle) {
                    // TODO: tags?
                    targetHandle = recipe.newHandle();
                    targetConnection.connectToHandle(targetHandle);
                }
            }
            if (targetHandle) {
                connection.connectToHandle(targetHandle);
            }
            connectionItem.dependentConnections.forEach(item => newConnection(particle, item));
        };
        const newSlotConnection = (particle, slotConnectionItem) => {
            let targetSlot = items.byName.get(slotConnectionItem.target.name);
            // Note: Support for 'target' (instead of name + tags) is new, and likely buggy.
            // TODO(cypher1): target.particle should not be ignored (but currently is).
            if (targetSlot) {
                external_assert_default()(items.bySlot.has(targetSlot));
                if (!targetSlot.name) {
                    targetSlot.name = slotConnectionItem.param;
                }
                external_assert_default()(targetSlot === items.byName.get(slotConnectionItem.target.name), `Target slot ${targetSlot.name} doesn't match slot connection ${slotConnectionItem.param}`);
            }
            else if (slotConnectionItem.target.name) {
                // if this is a require section, check if slot exists in recipe.
                if (recipe.isRequireSection) {
                    targetSlot = recipe.parent.slots.find(slot => slot.localName === slotConnectionItem.target.name);
                    if (targetSlot !== undefined) {
                        items.bySlot.set(targetSlot, slotConnectionItem);
                        if (slotConnectionItem.target.name) {
                            items.byName.set(slotConnectionItem.target.name, targetSlot);
                        }
                    }
                }
                if (targetSlot == undefined) {
                    targetSlot = recipe.newSlot(slotConnectionItem.param);
                    targetSlot.localName = slotConnectionItem.target.name;
                    items.byName.set(slotConnectionItem.target.name, targetSlot);
                    items.bySlot.set(targetSlot, slotConnectionItem);
                }
            }
            if (targetSlot) {
                particle.getSlotConnectionByName(slotConnectionItem.param).connectToSlot(targetSlot);
            }
        };
        for (const [particle, item] of items.byParticle) {
            for (const connectionItem of item.connections) {
                newConnection(particle, connectionItem);
            }
            for (const slotConnectionItem of item.slotConnections) {
                newSlotConnection(particle, slotConnectionItem);
            }
        }
        if (items.description && items.description.description) {
            recipe.description = items.description.description;
        }
        if (items.require) {
            for (const item of items.require) {
                const requireSection = recipe.newRequireSection();
                manifest_Manifest._buildRecipe(manifest, requireSection, item.items, item.location);
            }
        }
        const policyName = recipe.policyName;
        if (policyName != null) {
            const policy = manifest.allPolicies.find(p => p.name === policyName);
            if (policy == null) {
                const warning = new ManifestWarning(location, `No policy named '${policyName}' was found in the manifest.`);
                warning.key = 'unknownPolicyName';
                manifest.errors.push(warning);
            }
            else {
                recipe.policy = policy;
            }
        }
    }
    resolveTypeName(name) {
        const schema = this.findSchemaByName(name);
        if (schema) {
            return { schema };
        }
        const iface = this.findInterfaceByName(name);
        if (iface) {
            return { iface };
        }
        return null;
    }
    /**
     * Creates a new storage key for data local to the manifest itself (e.g.
     * from embedded JSON data, or an external JSON file).
     */
    createLocalDataStorageKey() {
        return new ramdisk_RamDiskStorageKey(this.generateID('local-data').toString());
    }
    static _buildAnnotationRefs(manifest, annotationRefItems) {
        const annotationRefs = [];
        for (const aRefItem of annotationRefItems) {
            const annotation = manifest.findAnnotationByName(aRefItem.name);
            if (!annotation) {
                throw new ManifestError(aRefItem.location, `annotation not found: '${aRefItem.name}'`);
            }
            if (!annotation.allowMultiple) {
                if (annotationRefs.some(a => a.name === aRefItem.name)) {
                    throw new ManifestError(aRefItem.location, `annotation '${aRefItem.name}' already exists.`);
                }
            }
            const params = {};
            for (const param of aRefItem.params) {
                if (param.kind === 'annotation-named-param') {
                    if (params[param.name]) {
                        throw new ManifestError(aRefItem.location, `annotation '${annotation.name}' can only have one value for: '${param.name}'`);
                    }
                    const aParam = annotation.params[param.name];
                    if (!aParam) {
                        throw new ManifestError(aRefItem.location, `unexpected annotation param: '${param.name}'`);
                    }
                    params[param.name] = param.value;
                }
                else {
                    if (Object.keys(annotation.params).length !== 1) {
                        throw new ManifestError(aRefItem.location, `annotation '${annotation.name}' has unexpected unnamed param '${param.value}'`);
                    }
                    params[Object.keys(annotation.params)[0]] = param.value;
                }
            }
            annotationRefs.push(new annotation_AnnotationRef(annotation, params));
        }
        return annotationRefs;
    }
    static async _processStore(manifest, item, loader, memoryProvider) {
        const { name, originalId, description, version, origin } = item;
        let id = item.id;
        let type = item.type['model']; // Model added in _augmentAstWithTypes.
        if (id == null) {
            id = `${manifest._id}store${manifest.stores.length}`;
        }
        let tags = item.tags;
        if (tags == null) {
            tags = [];
        }
        const claims = new Map();
        item.claims.forEach(claim => {
            resolveFieldPathType(claim.fieldPath, type);
            const target = claim.fieldPath.join('.');
            if (claims.has(target)) {
                throw new ManifestError(claim.location, `A claim for target ${target} already exists in store ${name}`);
            }
            const tags = claim.tags.map(tag => new claim_ClaimIsTag(/* isNot= */ false, tag));
            claims.set(target, tags);
        });
        // Instead of creating links to remote firebase during manifest parsing,
        // we generate storage stubs that contain the relevant information.
        if (item.origin === 'storage') {
            return manifest.newStore({
                type, name, id, storageKey: item.source, tags,
                originalId, claims, description, version, origin
            });
        }
        let json;
        let entities;
        if (item.origin === 'file') {
            if (!loader) {
                throw new ManifestError(item.location, 'No loader available for file');
            }
            item.source = loader.join(manifest.fileName, item.source);
            json = await loader.loadResource(item.source);
            entities = this.parseJson(json, item, manifest);
        }
        else if (item.origin === 'resource') {
            json = manifest.resources[item.source];
            if (json == undefined) {
                throw new ManifestError(item.location, `Resource '${item.source}' referenced by store '${id}' is not defined in this manifest`);
            }
            entities = this.parseJson(json, item, manifest);
        }
        else if (item.origin === 'inline') {
            entities = this.inlineEntitiesToSerialisedFormat(manifest, item.entities);
        }
        const storageKey = item['storageKey'] || manifest.createLocalDataStorageKey();
        if (storageKey instanceof ramdisk_RamDiskStorageKey) {
            if (!memoryProvider) {
                throw new ManifestError(item.location, `Creating ram disk stores requires having a memory provider.`);
            }
            memoryProvider.getVolatileMemory().deserialize(entities, storageKey.unique);
        }
        // Note that we used to use a singleton entity ID (if present) instead of the hash. It seems
        // cleaner not to rely on that.
        if (!item.id) {
            const entityHash = await digest(json || JSON.stringify(entities));
            id = `${id}:${entityHash}`;
        }
        if (!type.isSingleton && !type.isCollectionType()) {
            type = new type_SingletonType(type);
        }
        return manifest.newStore({
            type, name, id, storageKey, tags, originalId, claims, description, version,
            source: item.source, origin, referenceMode: false, model: entities,
            annotations: manifest_Manifest._buildAnnotationRefs(manifest, item.annotationRefs)
        });
    }
    static parseJson(json, item, manifest) {
        try {
            const parsed = JSON.parse(json);
            if (!Array.isArray(parsed)) {
                return parsed;
            }
            const entities = [];
            for (const item of parsed) {
                external_assert_default()(typeof item === 'object');
                const fields = {};
                for (const key of Object.keys(item)) {
                    fields[key] = { value: item[key] };
                }
                entities.push({ fields });
            }
            return this.inlineEntitiesToSerialisedFormat(manifest, entities);
        }
        catch (e) {
            throw new ManifestError(item.location, `Error parsing JSON from '${item.source}' (${e.message})'`);
        }
    }
    static inlineEntitiesToSerialisedFormat(manifest, entities) {
        const values = {};
        const version = { inline: 1 };
        for (const entityAst of entities) {
            const rawData = {};
            for (const [name, descriptor] of Object.entries(entityAst.fields)) {
                rawData[name] = descriptor.value;
            }
            const id = manifest.generateID('inline').toString();
            values[id] = {
                value: { id, creationTimestamp: 0, rawData },
                version
            };
        }
        return { root: { values, version }, locations: {} };
    }
    _newRecipe(name) {
        const recipe = newRecipe(name);
        this._recipes.push(recipe);
        return recipe;
    }
    // TODO: This is a temporary method to allow sharing stores with other Arcs.
    registerStore(store, tags) {
        // Only register stores that have non-volatile storage key and don't have a
        // #volatile tag.
        if (!this.findStoreById(store.id) && !this.isVolatileStore(store, tags)) {
            this._addStore(store, tags);
        }
    }
    isVolatileStore(store, tags) {
        if (store.storageKey.protocol === volatile_VolatileStorageKey.protocol)
            return true;
        if (store.storageKey.protocol === reference_mode_storage_key_ReferenceModeStorageKey.protocol &&
            store.storageKey.backingKey.protocol === volatile_VolatileStorageKey.protocol &&
            store.storageKey.storageKey.protocol === volatile_VolatileStorageKey.protocol) {
            return true;
        }
        if (tags.includes('volatile'))
            return true;
        return false;
    }
    /**
     * Verifies that all definitions in the manifest (including all other
     * manifests that it imports) have unique names.
     */
    validateUniqueDefinitions() {
        function checkUnique(type, items) {
            const names = new Set();
            for (const item of items) {
                if (names.has(item.name)) {
                    throw new Error(`Duplicate definition of ${type} named '${item.name}'.`);
                }
                names.add(item.name);
            }
        }
        // TODO: Validate annotations as well. They're tricky because of canonical
        // annotations.
        checkUnique('particle', this.allParticles);
        checkUnique('policy', this.allPolicies);
        checkUnique('recipe', this.allRecipes);
        checkUnique('resource', this.allResources);
        checkUnique('schema', this.allSchemas);
        checkUnique('store', this.allStores);
    }
    toString(options = {}) {
        // TODO: sort?
        const results = [];
        this._imports.forEach(i => {
            if (options.recursive) {
                results.push(`// import '${i.fileName}'`);
                const importStr = i.toString(options);
                results.push(`${i.toString(options)}`);
            }
            else {
                results.push(`import '${i.fileName}'`);
            }
        });
        Object.values(this._annotations).forEach(a => {
            results.push(a.toManifestString());
        });
        Object.values(this._schemas).forEach(s => {
            results.push(s.toManifestString());
        });
        Object.values(this._particles).forEach(p => {
            results.push(p.toString());
        });
        this._recipes.forEach(r => {
            results.push(r.toString(options));
        });
        const storeInfos = Object.values(this.storeInfoById).sort(compareComparables);
        storeInfos.forEach(storeInfo => {
            results.push(storeInfo.toManifestString({ handleTags: [...this.storeTagsById[storeInfo.id]] }));
        });
        this._policies.forEach(policy => {
            results.push(policy.toManifestString());
        });
        return results.join('\n');
    }
}
//# sourceMappingURL=manifest.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/message-channel.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class MessagePort {
    constructor(channel, id, other) {
        this._channel = channel;
        this._id = id;
        this._other = other;
        this._onmessage = undefined;
    }
    // TODO appears to be {messageType, messageBody}
    async postMessage(message) {
        await this._channel._post(this._other, message);
    }
    set onmessage(f) {
        this._onmessage = f;
    }
    close() {
        this.postMessage = async () => { };
    }
}
class MessageEvent {
    constructor(message) {
        this.data = message;
    }
}
class message_channel_MessageChannel {
    constructor() {
        this.port1 = new MessagePort(this, 0, 1);
        this.port2 = new MessagePort(this, 1, 0);
        this._ports = [this.port1, this.port2];
    }
    async _post(id, message) {
        message = JSON.parse(JSON.stringify(message));
        if (this._ports[id]._onmessage) {
            try {
                // Yield so that we deliver the message asynchronously.
                await 0;
                await this._ports[id]._onmessage(new MessageEvent(message));
            }
            catch (e) {
                console.error('Exception in particle code\n', e);
            }
        }
    }
}
//# sourceMappingURL=message-channel.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/tracelib/systrace-helpers.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const CHANNEL_URL_PARAMETER = 'systrace';
/** Gets current global execution context */
const getGlobalScope = () => {
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    // tslint:disable-next-line:no-any
    return {};
};
/** Gets System Trace APIs i.e. android.os.Trace.* */
const getSystemTraceApis = () => {
    return getGlobalScope().SystemTraceApis || {};
};
/**
 * Delegates the location of the System Trace APIs to ${SystemTraceApis}
 * property in the current global execution context.
 *
 * In main renderer context, ${SystemTraceApis} is delegated by external
 * implementations i.e. addJavascriptInterface at Android Webview.
 * In worker context, ${SystemTraceApis} is delegated by PECInnerPort.
 *
 * The contract of ${SystemTraceApis}:
 *   asyncTraceBegin(...args): start a new asynchronous system tracing
 *   asyncTraceEnd(...args): stop the asynchronous system tracing
 *
 * @param {string} port The port/location to talk to System Trace APIs
 */
const delegateSystemTraceApis = port => {
    const gs = getGlobalScope();
    if (!gs.SystemTraceApis && port) {
        gs.SystemTraceApis = new class {
            asyncTraceBegin(...args) {
                port.SystemTraceBegin(...args);
            }
            asyncTraceEnd(...args) {
                port.SystemTraceEnd(...args);
            }
        }();
    }
};
/**
 * Gets the system tracing channel if specified.
 * The url parameter ${CHANNEL_URL_PARAMETER} is used in the main renderer
 * context while the ${systemTraceChannel} in current global execution
 * context is used at dedicated workers.
 */
const getSystemTraceChannel = () => {
    const location = getGlobalScope().location;
    let urlChannel;
    if (location) {
        const params = new URLSearchParams(location.search);
        urlChannel = params.get(CHANNEL_URL_PARAMETER);
    }
    return urlChannel || getGlobalScope().systemTraceChannel || '';
};
//# sourceMappingURL=systrace-helpers.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/tracelib/systrace-clients.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/** Outputs trace messages to JS console */
const CONSOLE_CLIENT_NAME = 'console';
/** Outputs trace messages to [android.os.Trace]{@link https://developer.android.com/reference/android/os/Trace} */
const ANDROID_CLIENT_NAME = 'android';
/** Outputs trace messages to DevTools timeline */
const DEVTOOLS_TIMELINE_CLIENT_NAME = 'devtools_timeline';
/** Abstraction of System Trace Client */
class Client {
    asyncTraceBegin(tag, cookie) { }
    asyncTraceEnd(tag, cookie) { }
}
/**
 * Client: JS Console Logging
 *
 * This client implements more precise performance/latency measurement
 * at both of the main renderer and dedicated workers.
 */
class ConsoleClient extends Client {
    asyncTraceBegin(tag, cookie) {
        console.log(`${Date.now()}: S|${tag}|${cookie}`);
    }
    asyncTraceEnd(tag, cookie) {
        console.log(`${Date.now()}: F|${tag}|${cookie}`);
    }
}
/**
 * Client: DevTools Timeline marking
 *
 * This client implements more precise performance/latency measurement
 * at both of the main renderer and dedicated workers.
 */
class DevToolsTimelineClient extends Client {
    asyncTraceBegin(tag, cookie) {
        console.timeStamp(`S|${tag}`);
    }
    asyncTraceEnd(tag, cookie) {
        console.timeStamp(`F|${tag}`);
    }
}
/**
 * Client: Android Arcs Tracing
 *
 * This client implement more vague performance/latency measurement
 * at dedicated workers due to the overhead of passing messages from workers
 * to the main renderer and also at the main renderer as there is only single
 * JavaBridge thread handling all trace messages in a fifo queue at the browser
 * process.
 */
class systrace_clients_AndroidClient extends Client {
    asyncTraceBegin(tag, cookie) {
        // Don't assign getSystemTraceApis().XXX to a local object due to the error:
        // java bridge method can't be invoked on a non injected object
        if (getSystemTraceApis().asyncTraceBegin) {
            ((...args) => getSystemTraceApis().asyncTraceBegin(...args))(tag, cookie);
        }
    }
    asyncTraceEnd(tag, cookie) {
        if (getSystemTraceApis().asyncTraceEnd) {
            ((...args) => getSystemTraceApis().asyncTraceEnd(...args))(tag, cookie);
        }
    }
}
/**
 * System Trace Client Selector
 * Options:
 *   ${CONSOLE_CLIENT_NAME}: using console.log
 *   ${ANDROID_CLIENT_NAME}: using Android Arcs Tracing APIs
 */
const getClientClass = () => {
    let clientClass = undefined;
    switch (getSystemTraceChannel()) {
        case CONSOLE_CLIENT_NAME:
            clientClass = ConsoleClient;
            break;
        case DEVTOOLS_TIMELINE_CLIENT_NAME:
            clientClass = DevToolsTimelineClient;
            break;
        case ANDROID_CLIENT_NAME:
            clientClass = systrace_clients_AndroidClient;
            break;
        default:
            break;
    }
    // Allows overriding client for testing if specified.
    return getGlobalScope().systemTraceClientClassOverride || clientClass;
};
//# sourceMappingURL=systrace-clients.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/tracelib/systrace.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

// Identifies whether a class has already been traced in its
// inheritance hierarchies.
const SYSTEM_TRACED_PROPERTY = '_systemTraced';
// Specifies the functions of a prototype/constructor not being traced.
const NO_TRACE_PROPERTY = '_noTrace';
// Don't trace these [class]: properties
//
// Works jointly with @NoTrace{WithReason} which is used when modifying source
// codes is allowed, whereas using this blacklist when modifying source codes in
// i.e. third-party libraries is forbidden. The list is usually used to shut up
// chatty trace messages on third-party class methods.
const PROPERTY_BLACKLIST = new Map(
// [['Foo', ['bar', 'xyz']],]
);
// Generates unique ids and cookies to identify tracing sessions or function
// calls among execution contexts (main runtime, dedicated workers and etc).
const systrace_idGenerator = new class {
    constructor() {
        this.cookie = Date.now() & 0x7FFFFFFF;
        this.id = Math.random().toString(36).substr(2, 9);
    }
    /**
     * An id is used to identify execution context.
     *
     * Relies on v8 pseudo-random number generator (PRNG).
     * The random number is derived from an internal state, which is altered by
     * a fixed algorithm for every new random number.
     */
    getUniqueId() {
        return this.id;
    }
    /**
     * A cookie is a rolling sequence being used to identify an unique
     * asynchronous tracing session or function call.
     */
    getCookie() {
        const cookie = this.cookie++;
        this.cookie &= 0x7FFFFFFF;
        return cookie;
    }
}();
/**
 * Method decorator for specifying that don't harness system trace
 * to this method with a reason.
 */
function NoTraceWithReason(reason = '') {
    return function _(target, property, descriptor) {
        if (!target.hasOwnProperty(NO_TRACE_PROPERTY)) {
            Object.defineProperty(target, NO_TRACE_PROPERTY, { value: [property] });
        }
        else {
            target[NO_TRACE_PROPERTY].push(property);
        }
    };
}
/**
 * Method decorator for specifying that don't harness system trace
 * to this method.
 */
// tslint:disable-next-line: variable-name
const NoTrace = NoTraceWithReason();
/**
 * Class decorator for installing system tracing capability
 * to a class and its subclasses.
 */
// tslint:disable-next-line:enforce-name-casing
function SystemTrace(ctor) {
    return class extends ctor {
        constructor(...args) {
            super(...args);
            const clientClass = getClientClass();
            // Don't harness system tracing when any of:
            // a) clientClass is undefined, namely system tracing is not requested
            //    via url parameter.
            // b) re-entrance is detected.
            if (clientClass &&
                !this.constructor.hasOwnProperty(SYSTEM_TRACED_PROPERTY)) {
                harnessSystemTracing(this, new clientClass());
            }
        }
    };
}
/**
 * Used at sources that cannot decorate class by @SystemTrace.
 * Extends SystemTraceable to declare your class system-traceable,
 * e.g. class Foo extends SystemTraceable {...}
 */
// tslint:disable-next-line: variable-name
const SystemTraceable = SystemTrace(class {
});
/**
 * Used at sources that cannot decorate class by @SystemTrace.
 * Extends makeSystemTraceable(Base) to inherit from a system-traceable Base,
 * e.g. class Foo extends makeSystemTraceable(Base) {...}
 */
function makeSystemTraceable(cls) {
    return SystemTrace(cls);
}
function isFunction(target, property) {
    const desc = Object.getOwnPropertyDescriptor(target, property);
    // Type Function and non-getter/setter
    return (!desc.get && !desc.set && typeof desc.value === 'function');
}
function harnessSystemTracing(obj, client) {
    const that = obj;
    const contextId = systrace_idGenerator.getUniqueId();
    let boundSymbols = [];
    // Collects all functions at the object's prototype chain.
    while (obj = Object.getPrototypeOf(obj)) {
        // Stops at the root of the prototype chain.
        if (obj.constructor.name === 'Object') {
            break;
        }
        // Don't harness system tracing to the harnessed classes.
        // Class inheritance hierarchy might has the partial of super-classes
        // that have already been harnessed.
        if (obj.constructor.hasOwnProperty(SYSTEM_TRACED_PROPERTY)) {
            continue;
        }
        Object.defineProperty(obj.constructor, SYSTEM_TRACED_PROPERTY, { value: true, writable: false });
        const classTagName = obj.constructor.name || 'anon';
        // Collects and binds instance functions
        boundSymbols = boundSymbols.concat(Object.getOwnPropertyNames(obj)
            .filter((element, index, array) => {
            return isFunction(obj, element);
        })
            .map(element => ({
            className: obj.constructor.name,
            prototype: obj,
            property: element,
            // Places contextId first to group visual results in catapult.
            tag: contextId + '::' + classTagName + '::' + element,
        })));
        // Collects and binds class static functions
        boundSymbols = boundSymbols.concat(Object.getOwnPropertyNames(obj.constructor)
            .filter((element, index, array) => {
            return isFunction(obj.constructor, element);
        })
            .map(element => ({
            className: obj.constructor.name,
            prototype: obj.constructor,
            property: element,
            tag: contextId + '::' + classTagName + '::' + element,
        })));
    }
    // Property filters (determine if harnessing system tracing to properties):
    boundSymbols = boundSymbols.filter((element, index, array) => {
        const desc = Object.getOwnPropertyDescriptor(element.prototype, element.property);
        // Not interested in properties that can not be changed.
        if (!desc.writable) {
            return false;
        }
        // Not interested in constructors at this moment.
        if (element.property === 'constructor') {
            return false;
        }
        // Skips tracing when a function is decorated with @NoTrace.
        const props = element.prototype[NO_TRACE_PROPERTY];
        if (props && props.indexOf(element.property) !== -1) {
            return false;
        }
        // Skips tracing on blacklisted properties.
        const cls = PROPERTY_BLACKLIST.get(element.className);
        if (cls && cls.indexOf(element.property) !== -1) {
            return false;
        }
        return true;
    });
    // Harnesses system tracing to all property candidates.
    boundSymbols.forEach((element) => {
        const tracedFunction = element.prototype[element.property];
        element.prototype[element.property] =
            function (...args) {
                const cookie = systrace_idGenerator.getCookie();
                client.asyncTraceBegin(element.tag, cookie);
                const ret = tracedFunction.call(this, ...args);
                client.asyncTraceEnd(element.tag, cookie);
                return ret;
            };
    });
}
//# sourceMappingURL=systrace.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/worker-pool-sizing-policies.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// The interaction model between worker pool manager and sizing policies:
// The pool manager sends a wish of "demand" pool size to a policy, then the
// policy answers with an "approval" pool size after arbitration.
// Sizing policies could start arbitration only if the number of total
// workers is less than the cap or there is still free worker in the
// pool for shrinking; otherwise sizing policies skips arbitration at once.
const APPROVAL_SIZE_CAP = 16;
/** Sizing policy apis and helpers */
class SizingPolicy {
    /**
     * Determines whether to skip arbitration in accordance with the current
     * state of worker pool size.
     *
     * @param sizeState represents the current state of worker pool size
     * @returns true to skip arbitration; otherwise, return false
     */
    skip(sizeState) {
        const { demand, free, inUse } = sizeState;
        // Skips as there is no chance of shrinking.
        if ((free + inUse) >= APPROVAL_SIZE_CAP && free === 0) {
            // Hint: lots of workers breathing! Forgot to kill?!
            console.warn(`${inUse} workers. Any zombies?!`);
            return true;
        }
        return false;
    }
    /**
     * Caps an approval into an allowed range.
     *
     * @param approval the arbitrated approval
     * @returns a capped approval in an allowed range
     */
    cap(approval) {
        return Math.max(Math.min(approval, APPROVAL_SIZE_CAP), 0);
    }
}
/**
 * [Aggressive Policy]
 * It's eager to maintain a bigger pool with more free room if available.
 *
 * Algorithm:
 * approval = Min(
 *   1.5 * Max(max_historical_inUse, demand),
 *   APPROVAL_SIZE_CAP
 * );
 */
const aggressive = new (class extends SizingPolicy {
    constructor() {
        super(...arguments);
        this.maxInUse = 0;
        this.scale = (n) => Math.floor(n * 3 / 2);
    }
    arbitrate(sizeState) {
        try {
            if (this.skip(sizeState)) {
                return 0;
            }
            const { demand, free, inUse } = sizeState;
            if (inUse > this.maxInUse) {
                this.maxInUse = inUse;
            }
            const total = free + inUse;
            const approval = this.cap(this.scale(Math.max(this.maxInUse, demand)));
            return approval - total;
        }
        catch {
            return 0;
        }
    }
})();
/**
 * [Conservative Policy]
 * It's passive to just fulfill requested demand of pool size.
 *
 * Algorithm:
 * approval = Min(demand, APPROVAL_SIZE_CAP);
 */
const conservative = new (class extends SizingPolicy {
    arbitrate(sizeState) {
        try {
            if (this.skip(sizeState)) {
                return 0;
            }
            const { demand: approval, free, inUse } = sizeState;
            return this.cap(approval) - free - inUse;
        }
        catch {
            return 0;
        }
    }
})();
/**
 * [Predictive Policy]
 * It forecasts target pool size via [Exponential Weighted Moving Average]
 * {@link https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average}
 *
 * Algorithm:
 * Let EWMA(t) := moving average pool size prediction at the time t
 * Let I := the number of current in-use workers
 * Let w := weight shift bits
 * Let c := coefficient = 1 / (1 << w)
 * Let DIFF(t) := the difference at time t = I - EWMA(t-1)
 *
 * EWMA(t)
 *   = c * (I) + (1 - c) * EWMA(t-1)
 *   = c * (I - EWMA(t-1)) + EWMA(t-1)
 *   = c * DIFF(t) + EWMA(t-1)
 *   = c * (EWMA(t-1) / c + DIFF(t))
 *   = 1 / (1 << w) * (EWMA(t - 1) * (1 << w) + DIFF(t))
 *   = ((EWMA(t - 1) << w) + DIFF(t)) >> w
 *
 * Algorithm:
 * approval = Min(Max(EWMA(t), demand), APPROVAL_SIZE_CAP);
 */
const predictive = new (class extends SizingPolicy {
    constructor() {
        super(...arguments);
        this.weight = 1;
        this.ewma = 0;
    }
    arbitrate(sizeState) {
        try {
            if (this.skip(sizeState)) {
                return 0;
            }
            const { demand, free, inUse } = sizeState;
            const total = free + inUse;
            const diff = inUse - this.ewma;
            this.ewma = ((this.ewma << this.weight) + diff) >> this.weight;
            const approval = this.cap(Math.max(this.ewma, demand));
            return approval - total;
        }
        catch {
            return 0;
        }
    }
})();
/** All available pool sizing policies to be determined at run-time. */
const worker_pool_sizing_policies_policies = {
    aggressive,
    conservative,
    predictive,
    // The default policy is taken when either no policy is specified or an
    // unknown policy is specified via a corresponding url parameter.
    default: conservative,
};
//# sourceMappingURL=worker-pool-sizing-policies.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/worker-pool.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

// Enables the worker pool management via this url parameter.
// The value of parameter represents boolean options applied to a worker pool.
// Options are separated by comma.
const USE_WORKER_POOL_PARAMETER = 'use-worker-pool';
// Chooses worker pool sizing policy via this url parameter.
// @see {@link policies} for all available sizing policies.
const SIZING_POLICY_PARAMETER = 'sizing-policy';
// Wants to keep the pool size at least at this watermark.
const POOL_SIZE_DEMAND = 3;
class PoolOptions {
    constructor() {
        // Don't suspend workers but destroy them directly.
        // The option forbids resurrecting workers at all contexts; in other
        // words, the pool can be replenished only by spinning up new workers.
        this.nosuspend = false;
    }
}
/** Arcs Worker Pool Management */
const workerPool = new (class {
    constructor() {
        // Suspended (aka free) workers.
        this.suspended = [];
        // In-use workers (indexed by the port allocated for the main renderer).
        this.inUse = new Map();
        // The additional boolean configurations are applied to the worker pool.
        this.options = new PoolOptions();
        // Whether the worker pool management is ON.
        this.active = false;
        // Worker APIs
        this.factory = {};
        // A pool sizing policy can be reassigned via {@link SIZING_POLICY_PARAMETER}
        // only when the worker pool management is active.
        this.policy = worker_pool_sizing_policies_policies.default;
        // Tracks policy state
        this.policyState = 0 /* NOT_DESIGNATED */;
        if (typeof window !== 'undefined') {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has(USE_WORKER_POOL_PARAMETER)) {
                this.active = true;
                // Resolves supplied boolean options.
                (urlParams.get(USE_WORKER_POOL_PARAMETER) || '')
                    .split(',')
                    .filter(Boolean)
                    .forEach(e => {
                    if (e in this.options) {
                        this.options[e] = true;
                    }
                });
                // Designates the requested sizing policy if any to manage pool sizing.
                const p = urlParams.get(SIZING_POLICY_PARAMETER);
                if (p && worker_pool_sizing_policies_policies[p]) {
                    this.policy = worker_pool_sizing_policies_policies[p];
                }
                this.policyState = 1 /* STANDBY */;
            }
        }
    }
    /**
     * Checks if a worker associating with the host port is in-use.
     *
     * @param port the host port being used to talk to its associated worker
     */
    exist(port) {
        return this.active && !!this.inUse.get(port);
    }
    /**
     * Emplaces a new worker and its messaging channel into the target collection.
     *
     * @param worker the new spun-up worker
     * @param channel the new established channel associating with the worker
     * @param toInUse where to emplace worker/channel to. If this parameter is
     *                true, the worker/channel is emplaced into a hash map
     *                collecting all in-use workers for the time being and being
     *                indexed by the host port; else the worker/channel is emplaced
     *                emplaced into an array representing all suspended (aka free)
     *                workers waiting for being resumed to serve new PECs.
     */
    emplace(worker, channel, toInUse = true) {
        if (toInUse) {
            // The path is for resurrecting workers spun up by the PEC factory.
            this.inUse.set(channel.port2, { worker, channel, usage: 1 });
        }
        else {
            // The path is for spawning workers ahead-of-time.
            this.suspended.push({ worker, channel, usage: 0 });
        }
    }
    /**
     * Closes a host port and destroys the worker associating with it.
     *
     * @param port the host port being used to talk to its associated worker
     */
    destroy(port) {
        const entry = this.inUse.get(port);
        if (entry) {
            this.inUse.delete(port);
            entry.worker.terminate();
        }
    }
    /**
     * Suspends the worker associating with the given port.
     *
     * @param port the host port being used to talk to its associated worker
     */
    suspend(port) {
        // Don't resurrect workers at all but spawn new workers as possible.
        // The suspend should be treated exactly as a destroy.
        if (this.options.nosuspend) {
            this.destroy(port);
            return;
        }
        const entry = this.inUse.get(port);
        if (entry) {
            this.inUse.delete(port);
            this.suspended.push(entry);
        }
    }
    /**
     * Resumes a worker from the suspended list if there is any.
     *
     * @return a PoolEntry specifying a resumed worker and its messaging channel
     */
    resume() {
        const entry = this.suspended.pop();
        if (entry) {
            // Assigns a new message channel to avoid wrong messages being passed to
            // this worker unexpectedly i.e. [#4475 unregister zombie handle listeners]
            // {@link https://github.com/PolymerLabs/arcs/issues/4475}
            //
            // {@link PoolEntry#usage} counts how many times this worker is reused.
            // Thus a zero value represents this worker was just spun up ahead of time.
            if (entry.usage > 0) {
                entry.channel = new MessageChannel();
            }
            // Keeps tracking this worker's usage and stats.
            entry.usage++;
            this.inUse.set(entry.channel.port2, entry);
        }
        return entry;
    }
    /** Cleans up all managed workers. */
    clear() {
        this.inUse.forEach(entry => {
            entry.worker.terminate();
        });
        this.inUse.clear();
        this.suspended.forEach(entry => {
            entry.worker.terminate();
        });
        this.suspended.length = 0;
    }
    /**
     * Shrinks or grows the worker pool on demand.
     *
     * @param demand a demand that wishes to keep the worker pool size
     *               at least at this value.
     */
    shrinkOrGrow(demand = POOL_SIZE_DEMAND) {
        setTimeout(async () => {
            // Only allows single executor at a time.
            if (this.policyState !== 1 /* STANDBY */) {
                return;
            }
            this.policyState = 2 /* PROCESSING */;
            // The actual shrink/grow process can be hanged up to the end of event
            // loop to yield more computing resources with higher parallelism to other
            // Arcs runtime/shell routines via relaxed 'await <reason>' calls.
            await 'relax_in_general';
            let numShrinkOrGrow = this.policy.arbitrate({
                demand: POOL_SIZE_DEMAND,
                free: this.suspended.length,
                inUse: this.inUse.size,
            });
            if (numShrinkOrGrow > 0 && !!this.factory.create) {
                // Grows the number of free workers by numShrinkOrGrow
                for (; numShrinkOrGrow > 0; numShrinkOrGrow--) {
                    const { worker, channel } = this.factory.create();
                    this.emplace(worker, channel, /*toInUse=*/ false);
                    await 'relax_growth';
                }
            }
            else if (numShrinkOrGrow < 0) {
                // Shrinks the number of free workers by numShrinkOrGrow
                for (; numShrinkOrGrow < 0; numShrinkOrGrow++) {
                    if (this.suspended.length === 0) {
                        // There are no spare free workers to terminate.
                        break;
                    }
                    const { worker, channel } = this.suspended.pop();
                    worker.terminate();
                    await 'relax_shrink';
                }
            }
            this.policyState = 1 /* STANDBY */;
        }, 100);
    }
    /**
     * Delegates worker APIs.
     *
     * This allows delegations of single or multiple APIs to the internal
     * worker factory.
     *
     * Note:
     * If one API has already existed, it would be overwritten.
     */
    set apis(f) {
        // tslint:disable-next-line:forin
        for (const m in f) {
            this.factory[m] = f[m];
        }
    }
})();
//# sourceMappingURL=worker-pool.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/api-channel.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};









var MappingType;
(function (MappingType) {
    MappingType[MappingType["Mapped"] = 0] = "Mapped";
    MappingType[MappingType["LocalMapped"] = 1] = "LocalMapped";
    MappingType[MappingType["RemoteMapped"] = 2] = "RemoteMapped";
    MappingType[MappingType["Direct"] = 3] = "Direct";
    MappingType[MappingType["ObjectMap"] = 4] = "ObjectMap";
    MappingType[MappingType["List"] = 5] = "List";
    MappingType[MappingType["ByLiteral"] = 6] = "ByLiteral";
})(MappingType || (MappingType = {}));
const targets = new Map();
function setPropertyKey(target, propertyKey) {
    let map = targets.get(target);
    if (map == undefined) {
        map = new Map();
        targets.set(target, map);
    }
    let list = map.get(propertyKey);
    if (list == undefined) {
        list = [];
        map.set(propertyKey, list);
    }
    return list;
}
function getPropertyKey(target, propertyKey, parameterIndex) {
    const map = targets.get(target);
    if (map) {
        const list = map.get(propertyKey);
        if (list) {
            const result = list[parameterIndex];
            if (result) {
                return result;
            }
        }
    }
    throw new Error(`the target ${target}, propertyKey ${propertyKey} and parameterIndex ${parameterIndex} provided did not exist`);
}
function set(target, propertyKey, parameterIndex, info) {
    const list = setPropertyKey(target, propertyKey);
    list[parameterIndex] = info;
}
function Direct(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct });
}
function Mapped(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Mapped });
}
function ByLiteral(constructor) {
    return (target, propertyKey, parameterIndex) => {
        const info = { type: MappingType.ByLiteral, converter: constructor };
        set(target.constructor, propertyKey, parameterIndex, info);
    };
}
function ObjectMap(key, value) {
    return (target, propertyKey, parameterIndex) => {
        const info = { type: MappingType.ObjectMap, key: { type: key }, value: { type: value } };
        set(target.constructor, propertyKey, parameterIndex, info);
    };
}
function List(value) {
    return (target, propertyKey, parameterIndex) => {
        const info = { type: MappingType.List, value: { type: value } };
        set(target.constructor, propertyKey, parameterIndex, info);
    };
}
function LocalMapped(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.LocalMapped });
}
function RemoteMapped(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.RemoteMapped });
}
function NoArgs(target, propertyKey) {
    setPropertyKey(target.constructor, propertyKey);
}
function RedundantInitializer(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct, initializer: true, redundant: true });
}
function OverridingInitializer(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct, initializer: true, overriding: true });
}
function Initializer(target, propertyKey, parameterIndex) {
    set(target.constructor, propertyKey, parameterIndex, { type: MappingType.Direct, initializer: true });
}
function Identifier(target, propertyKey, parameterIndex) {
    getPropertyKey(target.constructor, propertyKey, parameterIndex).identifier = true;
}
function RemoteIgnore(target, propertyKey, parameterIndex) {
    getPropertyKey(target.constructor, propertyKey, parameterIndex).ignore = true;
}
class api_channel_ThingMapper {
    constructor(prefix) {
        this._prefix = prefix;
        this._nextIdentifier = 0;
        this._idMap = new Map();
        this._reverseIdMap = new Map();
    }
    _newIdentifier() {
        return this._prefix + (this._nextIdentifier++);
    }
    createMappingForThing(thing, requestedId = undefined) {
        external_assert_default()(!this._reverseIdMap.has(thing));
        let id;
        if (requestedId) {
            id = requestedId;
        }
        else if (thing.apiChannelMappingId) {
            id = thing.apiChannelMappingId;
        }
        else {
            id = this._newIdentifier();
        }
        external_assert_default()(!this._idMap.has(id), `${requestedId ? 'requestedId' : (thing.apiChannelMappingId ? 'apiChannelMappingId' : 'newIdentifier()')} ${id} already in use`);
        // TODO: Awaiting this promise causes tests to fail...
        floatingPromiseToAudit(this.establishThingMapping(id, thing));
        return id;
    }
    recreateMappingForThing(things) {
        const ids = [];
        things.forEach(thing => {
            external_assert_default()(this._reverseIdMap.has(thing));
            const id = this._reverseIdMap.get(thing);
            floatingPromiseToAudit(this.establishThingMapping(id, thing));
            ids.push(id);
        });
        return ids;
    }
    maybeCreateMappingForThing(thing) {
        if (this.hasMappingForThing(thing)) {
            return this.identifierForThing(thing);
        }
        return this.createMappingForThing(thing);
    }
    async establishThingMapping(id, thing) {
        let continuation;
        if (!Array.isArray(id)) {
            if (Array.isArray(thing)) {
                [thing, continuation] = thing;
            }
            this._idMap.set(id, thing);
        }
        if (thing instanceof Promise) {
            external_assert_default()(continuation == null);
            await this.establishThingMapping(id, await thing);
        }
        else if (Array.isArray(id)) {
            external_assert_default()(id.length === thing.length);
            for (let i = 0; i < id.length; i++) {
                await this.establishThingMapping(id[i], thing[i]);
            }
        }
        else {
            this._reverseIdMap.set(thing, id);
            if (continuation) {
                await continuation();
            }
        }
    }
    hasMappingForThing(thing) {
        return this._reverseIdMap.has(thing);
    }
    hasMappingForId(id) {
        return this._idMap.has(id);
    }
    identifierForThing(thing) {
        external_assert_default()(this._reverseIdMap.has(thing), `Missing thing [${thing}]`);
        return this._reverseIdMap.get(thing);
    }
    thingForIdentifier(id) {
        external_assert_default()(this._idMap.has(id), `Missing id: ${id}`);
        return this._idMap.get(id);
    }
}
let api_channel_APIPort = class APIPort {
    constructor(messagePort, prefix, onError) {
        this.onError = onError;
        this._port = messagePort;
        this._mapper = new api_channel_ThingMapper(prefix);
        this._port.onmessage = async (e) => this._processMessage(e);
        this.inspector = null;
        this.attachStack = false;
        this.messageCount = 0;
        this._testingHook();
    }
    // Overridden by unit tests.
    _testingHook() {
    }
    // Clear resources bound to this port prior to closing.
    // Overridden by inner, outer and any derived port implementations.
    clear() {
    }
    close() {
        if (workerPool.exist(this._port)) {
            // The worker associated with this port is put into the suspended list
            // rather than being destroyed immediately when this PEH/PEC APIPort
            // is closed.
            workerPool.suspend(this._port);
        }
        this.clear();
        this._port.close();
    }
    async _processMessage(e) {
        external_assert_default()(this['before' + e.data.messageType] !== undefined);
        const count = this.messageCount++;
        if (this.inspector) {
            this.inspector.pecMessage('on' + e.data.messageType, e.data.messageBody, count, this.supportsExternalParticle() ? /* android */ 'a' : /* web */ 'w', this._port['pecId'], e.data.stack);
        }
        try {
            await this['before' + e.data.messageType](e.data.messageBody);
        }
        catch (err) {
            this.onError(err);
        }
    }
    async send(name, args) {
        const call = { messageType: name, messageBody: args, stack: this.attachStack ? new Error().stack : undefined };
        const count = this.messageCount++;
        if (this.inspector) {
            this.inspector.pecMessage(name, args, count, this.supportsExternalParticle() ? /* android */ 'a' : /* web */ 'w', this._port['pecId'] || '', new Error().stack || '');
        }
        await this._port.postMessage(call);
    }
    supportsExternalParticle() {
        // TODO: improve heuristics.
        return Object.getPrototypeOf(this._port.constructor).name === 'MessagePort';
    }
};
__decorate([
    NoTraceWithReason('Chatty')
], api_channel_APIPort.prototype, "_processMessage", null);
__decorate([
    NoTraceWithReason('Recursion on sending trace messages inner->outer')
], api_channel_APIPort.prototype, "send", null);
__decorate([
    NoTraceWithReason('Chatty')
], api_channel_APIPort.prototype, "supportsExternalParticle", null);
api_channel_APIPort = __decorate([
    SystemTrace
], api_channel_APIPort);

// The horror. From https://davidwalsh.name/javascript-arguments
function getArgs(func) {
    // First match everything inside the function argument parens.
    const args = func.toString().match(/.*?\(([^)]*)\)/)[1];
    // Split the arguments string into an array comma delimited.
    return args.split(',').map((arg) => {
        // Ensure no inline comments are parsed and trim the whitespace.
        return arg.replace(/\/\*.*\*\//, '').trim();
        // Ensure no undefined values are added.
    }).filter((arg) => arg);
}
// value is covariant with info, and errors will be found
// at start of runtime.
// tslint:disable-next-line: no-any
function api_channel_convert(info, value, mapper) {
    if (info === undefined) {
        return;
    }
    if (value === null) {
        return null;
    }
    switch (info.type) {
        case MappingType.Mapped:
            return mapper.identifierForThing(value);
        case MappingType.LocalMapped:
            return mapper.maybeCreateMappingForThing(value);
        case MappingType.RemoteMapped:
            // This is on the local side, so we don't do anything here.
            return value;
        case MappingType.Direct:
            return value;
        case MappingType.ObjectMap: {
            const r = {};
            value.forEach((childvalue, key) => r[api_channel_convert(info.key, key, mapper)] = api_channel_convert(info.value, childvalue, mapper));
            return r;
        }
        case MappingType.List:
            return value.map(v => api_channel_convert(info.value, v, mapper));
        case MappingType.ByLiteral:
            return value.toLiteral();
        default:
            throw new Error(`Can't yet send MappingType ${info.type}`);
    }
}
// value is covariant with info, and errors will be found
// at start of runtime.
// tslint:disable-next-line: no-any
function unconvert(info, value, mapper) {
    if (info === undefined) {
        return;
    }
    if (value === null) {
        return null;
    }
    switch (info.type) {
        case MappingType.Mapped:
            return mapper.thingForIdentifier(value);
        case MappingType.LocalMapped:
            // This is on the remote side, so we don't do anything here.
            return value;
        case MappingType.RemoteMapped:
            return mapper.thingForIdentifier(value);
        case MappingType.Direct:
            return value;
        case MappingType.ObjectMap: {
            const r = new Map();
            for (const key of Object.keys(value)) {
                r.set(unconvert(info.key, key, mapper), unconvert(info.value, value[key], mapper));
            }
            return r;
        }
        case MappingType.List:
            return value.map(v => unconvert(info.value, v, mapper));
        case MappingType.ByLiteral:
            if (!info.converter) {
                throw new Error(`Expected ${info.type} to have a converter but it doesn't`);
            }
            return info.converter.fromLiteral(value);
        default:
            throw new Error(`Can't yet recieve MappingType ${info.type}`);
    }
}
function AutoConstruct(target) {
    return (constructor) => {
        const doConstruct = (me, other) => {
            const functions = targets.get(me) || new Map();
            for (const f of functions.keys()) {
                const argNames = getArgs(me.prototype[f]);
                const descriptor = functions.get(f) || [];
                // If this descriptor is for an initializer, record that fact and we'll process it after
                // the rest of the arguments.
                const initializer = descriptor.findIndex(d => d.initializer || false);
                // If this descriptor records that this argument is the identifier, record it
                // as the requestedId for mapping below.
                const requestedId = descriptor.findIndex(d => d.identifier || false);
                /** @this APIPort */
                const impl = async function (...args) {
                    const messageBody = {};
                    for (let i = 0; i < descriptor.length; i++) {
                        if (i === initializer) {
                            continue;
                        }
                        // Process this argument.
                        messageBody[argNames[i]] = api_channel_convert(descriptor[i], args[i], this._mapper);
                    }
                    // Process the initializer if present.
                    if (initializer !== -1) {
                        if (descriptor[initializer].redundant) {
                            external_assert_default()(requestedId === -1);
                            messageBody['identifier'] = this._mapper.maybeCreateMappingForThing(args[initializer]);
                        }
                        else if (descriptor[initializer].overriding) {
                            messageBody['identifier'] = this._mapper.recreateMappingForThing(args[initializer]);
                        }
                        else {
                            messageBody['identifier'] = this._mapper.createMappingForThing(args[initializer], args[requestedId]);
                        }
                    }
                    await this.send(f, messageBody);
                };
                /** @this APIPort */
                const before = async function before(messageBody) {
                    const args = [];
                    const promises = [];
                    for (let i = 0; i < descriptor.length; i++) {
                        // If there's a requestedId then the receiving end won't expect to
                        // see the identifier as well.
                        if (i === initializer && (requestedId !== -1 || descriptor[i].ignore)) {
                            continue;
                        }
                        const argName = i === initializer ? 'identifier' : argNames[i];
                        const result = unconvert(descriptor[i], messageBody[argName], this._mapper);
                        if (result instanceof Promise) {
                            promises.push({ promise: result, position: args.length });
                            args.push(() => unconvert(descriptor[i], messageBody[argName], this._mapper));
                        }
                        else {
                            args.push(result);
                        }
                    }
                    if (promises.length > 0) {
                        await Promise.all(promises.map(async (a) => a.promise));
                        promises.forEach(a => {
                            args[a.position] = args[a.position]();
                        });
                    }
                    // For redundant initializers, we first check if we already have a
                    // mapping for that ID.
                    if (initializer !== -1 && descriptor[initializer].redundant) {
                        if (this._mapper.hasMappingForId(messageBody['identifier'])) {
                            // No need to process again.
                            return;
                        }
                    }
                    const result = this['on' + f](...args);
                    // If this message is an initializer, need to establish a mapping
                    // with the result of processing the message.
                    if (initializer > -1) {
                        external_assert_default()(messageBody['identifier']);
                        await this._mapper.establishThingMapping(messageBody['identifier'], result);
                    }
                };
                Object.defineProperty(me.prototype, f, {
                    get() {
                        return impl;
                    }
                });
                Object.defineProperty(other.prototype, 'before' + f, {
                    get() {
                        return before;
                    }
                });
            }
        };
        doConstruct(constructor, target);
        doConstruct(target, constructor);
    };
}
class api_channel_PECOuterPort extends api_channel_APIPort {
    constructor(messagePort, arc) {
        super(messagePort, 'o', (error) => { reportGlobalException(arc, error); });
        this.inspector = arc.inspector;
        if (this.inspector) {
            this.inspector.onceActive.then(() => this.DevToolsConnected(), e => console.error(e));
        }
    }
    async _processMessage(e) {
        // Modifying pec messages on the host side is a problem as they can be transmited to DevTools
        // with a delay. If the object representing a message is modified, it appears as if a different
        // messages travelled across the pec. We could have made a deep copy of the message object, but
        // agreed that these objects should not be modified as a matter of principle. We are freezing
        // them as a defensive measure. This has some performance penalty, so it could potentially be
        // disabled in the future for production builds.
        deepFreeze(e.data);
        await super._processMessage(e);
    }
    Stop() { }
    DefineHandle(store, storeInfo, name, ttl) { }
    DefineHandleFactory(store, storeInfo, name, ttl) { }
    InstantiateParticle(particle, id, spec, stores, storeMuxers, reinstantiate) { }
    ReloadParticles(particles, ids) { }
    UIEvent(particle, slotName, event) { }
    SimpleCallback(callback, data) { }
    AwaitIdle(version) { }
    GetDirectStoreMuxerCallback(store, storeInfo, callback, name, id) { }
    ConstructArcCallback(callback, arc) { }
    CreateHandleCallback(handle, storeInfo, callback, name, id) { }
    MapHandleCallback(newHandle, callback, id) { }
    CreateSlotCallback(slot, callback, hostedSlotId) { }
    // We need an API call to tell the context side that DevTools has been connected, so it can start sending
    // stack traces attached to the API calls made from that side.
    DevToolsConnected() { }
}
__decorate([
    NoTraceWithReason('Chatty')
], api_channel_PECOuterPort.prototype, "_processMessage", null);
__decorate([
    NoArgs
], api_channel_PECOuterPort.prototype, "Stop", null);
__decorate([
    __param(0, RedundantInitializer), __param(1, ByLiteral(store_info_StoreInfo)), __param(2, Direct), __param(3, ByLiteral(capabilities_Ttl))
], api_channel_PECOuterPort.prototype, "DefineHandle", null);
__decorate([
    __param(0, RedundantInitializer), __param(1, ByLiteral(store_info_StoreInfo)), __param(2, Direct), __param(3, ByLiteral(capabilities_Ttl))
], api_channel_PECOuterPort.prototype, "DefineHandleFactory", null);
__decorate([
    __param(0, Initializer), __param(1, Identifier), __param(1, Direct), __param(2, ByLiteral(particle_spec_ParticleSpec)), __param(3, ObjectMap(MappingType.Direct, MappingType.Mapped)), __param(4, ObjectMap(MappingType.Direct, MappingType.Mapped)), __param(5, Direct)
], api_channel_PECOuterPort.prototype, "InstantiateParticle", null);
__decorate([
    __param(0, OverridingInitializer), __param(1, List(MappingType.Direct))
], api_channel_PECOuterPort.prototype, "ReloadParticles", null);
__decorate([
    __param(0, Mapped), __param(1, Direct), __param(2, Direct)
], api_channel_PECOuterPort.prototype, "UIEvent", null);
__decorate([
    __param(0, RemoteMapped), __param(1, Direct)
], api_channel_PECOuterPort.prototype, "SimpleCallback", null);
__decorate([
    __param(0, Direct)
], api_channel_PECOuterPort.prototype, "AwaitIdle", null);
__decorate([
    __param(0, Initializer), __param(1, ByLiteral(store_info_StoreInfo)), __param(2, RemoteMapped), __param(3, Direct), __param(4, Identifier), __param(4, Direct)
], api_channel_PECOuterPort.prototype, "GetDirectStoreMuxerCallback", null);
__decorate([
    __param(0, RemoteMapped), __param(1, LocalMapped)
], api_channel_PECOuterPort.prototype, "ConstructArcCallback", null);
__decorate([
    __param(0, Initializer), __param(1, ByLiteral(store_info_StoreInfo)), __param(2, RemoteMapped), __param(3, Direct), __param(4, Identifier), __param(4, Direct)
], api_channel_PECOuterPort.prototype, "CreateHandleCallback", null);
__decorate([
    __param(0, RemoteIgnore), __param(0, Initializer), __param(1, RemoteMapped), __param(2, Direct)
], api_channel_PECOuterPort.prototype, "MapHandleCallback", null);
__decorate([
    __param(0, RemoteIgnore), __param(0, Initializer), __param(1, RemoteMapped), __param(2, Direct)
], api_channel_PECOuterPort.prototype, "CreateSlotCallback", null);
__decorate([
    NoArgs
], api_channel_PECOuterPort.prototype, "DevToolsConnected", null);
let api_channel_PECInnerPort = class PECInnerPort extends api_channel_APIPort {
    constructor(messagePort) {
        // TODO(shanestephens): Try to feed some more information through to PropagatedException - can perhaps
        // recover the method invoked and (sometimes) the particle.
        super(messagePort, 'i', err => this.ReportExceptionInHost(new PropagatedException(err)));
    }
    Output(particle, content) { }
    Register(handle, messagesCallback, idCallback) { }
    DirectStoreMuxerRegister(handle, messagesCallback, idCallback) { }
    ProxyMessage(handle, message) { }
    StorageProxyMuxerMessage(handle, message) { }
    Idle(version, relevance) { }
    GetDirectStoreMuxer(callback, storageKey, type) { }
    ConstructInnerArc(callback, particle) { }
    ArcCreateHandle(callback, arc, type, name) { }
    ArcMapHandle(callback, arc, handle) { }
    ServiceRequest(particle, content, callback) { }
    SystemTraceBegin(tag, cookie) { }
    SystemTraceEnd(tag, cookie) { }
    ArcCreateSlot(callback, arc, transformationParticle, transformationSlotName, handleId) { }
    ArcLoadRecipe(arc, recipe, callback) { }
    ReportExceptionInHost(exception) { }
    // To show stack traces for calls made inside the context, we need to capture the trace at the call point and
    // send it along with the message. We only want to do this after a DevTools connection has been detected, which
    // we can't directly detect inside a worker context, so the PECOuterPort will send an API message instead.
    onDevToolsConnected() {
        this.attachStack = true;
    }
};
__decorate([
    __param(0, Mapped), __param(1, Direct)
], api_channel_PECInnerPort.prototype, "Output", null);
__decorate([
    __param(0, Mapped),
    __param(1, LocalMapped),
    __param(2, LocalMapped)
], api_channel_PECInnerPort.prototype, "Register", null);
__decorate([
    __param(0, Mapped),
    __param(1, LocalMapped),
    __param(2, LocalMapped)
], api_channel_PECInnerPort.prototype, "DirectStoreMuxerRegister", null);
__decorate([
    __param(0, Mapped), __param(1, Direct)
], api_channel_PECInnerPort.prototype, "ProxyMessage", null);
__decorate([
    __param(0, Mapped), __param(1, Direct)
], api_channel_PECInnerPort.prototype, "StorageProxyMuxerMessage", null);
__decorate([
    __param(0, Direct), __param(1, ObjectMap(MappingType.Mapped, MappingType.Direct))
], api_channel_PECInnerPort.prototype, "Idle", null);
__decorate([
    __param(0, LocalMapped), __param(1, Direct), __param(2, ByLiteral(type_Type))
], api_channel_PECInnerPort.prototype, "GetDirectStoreMuxer", null);
__decorate([
    __param(0, LocalMapped), __param(1, Mapped)
], api_channel_PECInnerPort.prototype, "ConstructInnerArc", null);
__decorate([
    __param(0, LocalMapped), __param(1, RemoteMapped), __param(2, ByLiteral(type_Type)), __param(3, Direct)
], api_channel_PECInnerPort.prototype, "ArcCreateHandle", null);
__decorate([
    __param(0, LocalMapped), __param(1, RemoteMapped), __param(2, Mapped)
], api_channel_PECInnerPort.prototype, "ArcMapHandle", null);
__decorate([
    __param(0, Mapped), __param(1, Direct), __param(2, LocalMapped)
], api_channel_PECInnerPort.prototype, "ServiceRequest", null);
__decorate([
    __param(0, Direct), __param(1, Direct)
], api_channel_PECInnerPort.prototype, "SystemTraceBegin", null);
__decorate([
    __param(0, Direct), __param(1, Direct)
], api_channel_PECInnerPort.prototype, "SystemTraceEnd", null);
__decorate([
    __param(0, LocalMapped), __param(1, RemoteMapped), __param(2, Mapped), __param(3, Direct), __param(4, Direct)
], api_channel_PECInnerPort.prototype, "ArcCreateSlot", null);
__decorate([
    __param(0, RemoteMapped), __param(1, Direct), __param(2, LocalMapped)
], api_channel_PECInnerPort.prototype, "ArcLoadRecipe", null);
__decorate([
    __param(0, ByLiteral(PropagatedException))
], api_channel_PECInnerPort.prototype, "ReportExceptionInHost", null);
api_channel_PECInnerPort = __decorate([
    AutoConstruct(api_channel_PECOuterPort)
], api_channel_PECInnerPort);

function deepFreeze(object) {
    for (const name of Object.getOwnPropertyNames(object)) {
        const value = object[name];
        if (value && typeof value === 'object') {
            deepFreeze(value);
        }
    }
    Object.freeze(object);
}
//# sourceMappingURL=api-channel.js.map
// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(12);

// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/text-encoder-node.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


//# sourceMappingURL=text-encoder-node.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/wasm.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */









// Wraps a Uint8Array buffer which is automatically resized as more space is needed.
class wasm_DynamicBuffer {
    constructor(initialSize = 100) {
        this.size = 0;
        this.data = new Uint8Array(initialSize);
    }
    // Returns a view of the populated region of the underlying Uint8Array.
    view() {
        return this.data.subarray(0, this.size);
    }
    // Adds "plain text" strings, which should not contain any non-ascii characters.
    addAscii(...strs) {
        for (const str of strs) {
            this.ensureSpace(str.length);
            for (let i = 0; i < str.length; i++) {
                this.data[this.size++] = str.charCodeAt(i);
            }
        }
    }
    // Adds UTF8 strings, prefixed with their byte length: '<len>:<string>'.
    addUnicode(str) {
        if (!str) {
            this.addAscii('0:');
        }
        else {
            const bytes = new external_util_["TextEncoder"]().encode(str);
            this.addAscii(bytes.length + ':');
            this.ensureSpace(bytes.length);
            this.data.set(bytes, this.size);
            this.size += bytes.length;
        }
    }
    // Adds raw bytes from another DynamicBuffer, prefixed with the length: '<len>:<bytes>'.
    addBytes(buf) {
        this.addAscii(buf.size + ':');
        this.ensureSpace(buf.size);
        this.data.set(buf.view(), this.size);
        this.size += buf.size;
    }
    ensureSpace(required) {
        let newSize = this.data.length;
        while (newSize - this.size < required) {
            newSize *= 2;
        }
        if (newSize !== this.data.length) {
            // ArrayBuffer.transfer() would make this more efficient, but it's not implemented yet.
            const old = this.data;
            this.data = new Uint8Array(newSize);
            this.data.set(old);
        }
    }
}
// Encoders/decoders for the wire format for transferring entities over the wasm boundary.
// Note that entities must have an id before serializing for use in a wasm particle.
//
//  <singleton> = <id-length>:<id>|<field-name>:<value>|<field-name>:<value>| ... |
//  <value> depends on the field type:
//    Text         T<length>:<text>
//    URL          U<length>:<text>
//    Number       N<number>:
//    Boolean      B<zero-or-one>
//    Reference    R<length>:<id>|<length>:<storage-key>|<schema-hash>:
//    Dictionary   D<length>:<dictionary format>
//    Array        A<length>:<array format>
//
//  <collection> = <num-entities>:<length>:<encoded><length>:<encoded> ...
//
// The encoder classes also supports two "Dictionary" formats of key:value string pairs.
//
// The first format supports only string-type values:
//   <size>:<key-len>:<key><value-len>:<value><key-len>:<key><value-len>:<value>...
// alternate format supports typed-values using <value> syntax defined above
//   <size>:<key-len>:<key><value><key-len>:<key><value>...
//
// Examples:
//   Singleton:   4:id05|txt:T3:abc|lnk:U10:http://def|num:N37:|flg:B1|
//   Collection:  3:29:4:id12|txt:T4:qwer|num:N9.2:|18:6:id2670|num:N-7:|15:5:id501|flg:B0|
class wasm_StringEncoder {
    constructor(schema) {
        this.schema = schema;
    }
    static create(type) {
        if (type instanceof type_CollectionType || type instanceof type_SingletonType) {
            type = type.getContainedType();
        }
        if (type instanceof type_EntityType) {
            return new wasm_EntityEncoder(type.getEntitySchema());
        }
        if (type instanceof type_ReferenceType) {
            return new wasm_ReferenceEncoder(type.getEntitySchema());
        }
        throw new Error(`Unsupported type for StringEncoder: ${type}`);
    }
    async encodeSingleton(storable) {
        const buf = new wasm_DynamicBuffer();
        await this.encodeStorable(buf, storable);
        return buf;
    }
    async encodeCollection(entities) {
        const bufs = [];
        let len = 10; // for 'num-entities:' prefix
        for (const entity of entities) {
            const buf = await this.encodeSingleton(entity);
            bufs.push(buf);
            len += 10 + buf.size; // +10 for 'length:' prefix
        }
        const collection = new wasm_DynamicBuffer(len);
        collection.addAscii(entities.length + ':');
        for (const buf of bufs) {
            collection.addBytes(buf);
        }
        return collection;
    }
    static encodeDictionary(dict) {
        const buf = new wasm_DynamicBuffer();
        const entries = Object.entries(dict);
        buf.addAscii(entries.length + ':');
        for (const [key, value] of entries) {
            buf.addUnicode(key);
            buf.addUnicode(value);
        }
        return buf;
    }
    async encodeField(buf, field, name, value) {
        // TODO: support unicode field names
        switch (field.kind) {
            case 'schema-primitive':
                buf.addAscii(name, ':', field.type.substr(0, 1));
                this.encodeValue(buf, field.type, value);
                buf.addAscii('|');
                break;
            case 'schema-reference':
                buf.addAscii(name, ':R');
                await this.encodeReference(buf, value);
                buf.addAscii('|');
                break;
            case 'schema-collection':
            case 'schema-union':
            case 'schema-tuple':
                throw new Error(`'${field.kind}' not yet supported for entity packaging`);
            default:
                throw new Error(`Unknown field kind '${field.kind}' in schema`);
        }
    }
    async encodeReference(buf, ref) {
        const entityType = ref.type.referredType;
        external_assert_default()(entityType instanceof type_EntityType);
        const { id, entityStorageKey: storageKey } = ref.dataClone();
        const hash = await entityType.getEntitySchema().hash();
        buf.addUnicode(id);
        buf.addAscii('|');
        buf.addUnicode(storageKey);
        buf.addAscii('|', hash + ':');
    }
    encodeValue(buf, type, value) {
        switch (type) {
            case 'Text':
            case 'URL':
                buf.addUnicode(value);
                break;
            case 'Number':
                buf.addAscii(value + ':');
                break;
            case 'Boolean':
                buf.addAscii(value ? '1' : '0');
                break;
            case 'Bytes':
            case 'Object':
                throw new Error(`'${type}' not yet supported for entity packaging`);
            default:
                throw new Error(`Unknown primitive value type '${type}' in schema`);
        }
    }
}
class wasm_EntityEncoder extends wasm_StringEncoder {
    async encodeStorable(buf, entity) {
        if (!(entity instanceof entity_Entity)) {
            throw new Error(`non-Entity passed to EntityEncoder: ${entity}`);
        }
        buf.addUnicode(entity_Entity.id(entity));
        buf.addAscii('|');
        for (const [name, value] of Object.entries(entity)) {
            await this.encodeField(buf, this.schema.fields[name], name, value);
        }
    }
}
class wasm_ReferenceEncoder extends wasm_StringEncoder {
    async encodeStorable(buf, ref) {
        if (!(ref instanceof reference_Reference)) {
            throw new Error(`non-Reference passed to EntityEncoder: ${ref}`);
        }
        await this.encodeReference(buf, ref);
        buf.addAscii('|');
    }
}
class wasm_StringDecoder {
    constructor(schema, typeMap, storageFrontend) {
        this.schema = schema;
        this.typeMap = typeMap;
        this.storageFrontend = storageFrontend;
        this.textDecoder = new external_util_["TextDecoder"]();
    }
    static create(type, typeMap, storageFrontend) {
        if (type instanceof type_CollectionType || type instanceof type_SingletonType) {
            type = type.getContainedType();
        }
        if (type instanceof type_EntityType) {
            return new wasm_EntityDecoder(type.getEntitySchema(), typeMap, storageFrontend);
        }
        if (type instanceof type_ReferenceType) {
            return new ReferenceDecoder(type.getEntitySchema(), typeMap, storageFrontend);
        }
        throw new Error(`Unsupported type for StringDecoder: ${type}`);
    }
    init(bytes) {
        this.bytes = bytes;
        this.pos = 0;
    }
    static decodeDictionary(bytes) {
        const decoder = new wasm_EntityDecoder(null, null, null);
        decoder.init(bytes);
        const dict = {};
        let num = Number(decoder.upTo(':'));
        while (num--) {
            const klen = Number(decoder.upTo(':'));
            const key = decoder.chomp(klen);
            // be backward compatible with encoders that only encode string values
            const typeChar = decoder.chomp(1);
            // if typeChar is a digit, it's part of a length specifier
            if (typeChar >= '0' && typeChar <= '9') {
                const vlen = Number(`${typeChar}${decoder.upTo(':')}`);
                dict[key] = decoder.chomp(vlen);
            }
            else {
                // otherwise typeChar is value-type specifier
                dict[key] = decoder.decodeValue(typeChar);
            }
        }
        return dict;
    }
    // TODO: make work in the new world.
    static decodeArray(bytes) {
        const decoder = new wasm_EntityDecoder(null, null, null);
        decoder.init(bytes);
        const arr = [];
        let num = Number(decoder.upTo(':'));
        while (num--) {
            // be backward compatible with encoders that only encode string values
            const typeChar = decoder.chomp(1);
            // if typeChar is a digit, it's part of a length specifier
            if (typeChar >= '0' && typeChar <= '9') {
                const len = Number(`${typeChar}${decoder.upTo(':')}`);
                arr.push(decoder.chomp(len));
            }
            else {
                // otherwise typeChar is value-type specifier
                arr.push(decoder.decodeValue(typeChar));
            }
        }
        return arr;
    }
    upTo(char) {
        external_assert_default()(char.length === 1);
        const i = this.bytes.indexOf(char.charCodeAt(0), this.pos);
        if (i < 0) {
            throw new Error(`Packaged entity decoding fail: could not find '${char}'`);
        }
        const token = this.textDecoder.decode(this.bytes.subarray(this.pos, i));
        this.pos = i + 1;
        return token;
    }
    chomp(len) {
        return this.textDecoder.decode(this.chompBytes(len));
    }
    chompBytes(len) {
        if (this.pos + len > this.bytes.length) {
            throw new Error(`Packaged entity decoding fail: expected ${len} chars to remain ` +
                `but only had ${this.bytes.length - this.pos}`);
        }
        const start = this.pos;
        this.pos += len;
        return this.bytes.subarray(start, this.pos);
    }
    validate(token) {
        if (this.chomp(token.length) !== token) {
            throw new Error(`Packaged entity decoding fail: expected '${token}'`);
        }
    }
    decodeValue(typeChar) {
        switch (typeChar) {
            case 'T':
            case 'U': {
                const len = Number(this.upTo(':'));
                return this.chomp(len);
            }
            case 'N':
                return Number(this.upTo(':'));
            case 'B':
                return Boolean(this.chomp(1) === '1');
            case 'R':
                return this.decodeReference();
            case 'D': {
                const len = Number(this.upTo(':'));
                const dictionary = this.chompBytes(len);
                return wasm_StringDecoder.decodeDictionary(dictionary);
            }
            case 'A': {
                const len = Number(this.upTo(':'));
                const array = this.chompBytes(len);
                return wasm_StringDecoder.decodeArray(array);
            }
            default:
                throw new Error(`Packaged entity decoding fail: unknown primitive value type '${typeChar}'`);
        }
    }
    decodeReference() {
        const ilen = Number(this.upTo(':'));
        const id = this.chomp(ilen);
        this.validate('|');
        const klen = Number(this.upTo(':'));
        const storageKey = this.chomp(klen);
        this.validate('|');
        const schemaHash = this.upTo(':');
        const entityType = this.typeMap.getL(schemaHash);
        if (!entityType) {
            throw new Error(`Packaged entity decoding fail: invalid schema hash '${schemaHash}' for reference '${id}|${storageKey}'`);
        }
        return new reference_Reference({ id, entityStorageKey: storageKey }, new type_ReferenceType(entityType), this.storageFrontend);
    }
}
class wasm_EntityDecoder extends wasm_StringDecoder {
    decodeSingleton(bytes) {
        this.init(bytes);
        const len = Number(this.upTo(':'));
        const id = this.chomp(len);
        this.validate('|');
        const data = {};
        while (this.pos < this.bytes.length) {
            const name = this.upTo(':');
            const typeChar = this.chomp(1);
            data[name] = this.decodeValue(typeChar);
            this.validate('|');
        }
        const entity = new (entity_Entity.createEntityClass(this.schema, null))(data);
        if (id !== '') {
            entity_Entity.identify(entity, id, null);
        }
        return entity;
    }
}
class ReferenceDecoder extends wasm_StringDecoder {
    decodeSingleton(bytes) {
        this.init(bytes);
        return this.decodeReference();
    }
}
class wasm_EmscriptenWasmDriver {
    constructor(customSection) {
        // Records file and line for console logging in C++. This is set by the console/error macros in
        // arcs.h and used immediately in the following printf call (implemented by sysWritev() below).
        this.logInfo = null;
        // Wasm modules built by emscripten require some external memory configuration by the caller,
        // which is usually built into the glue code generated alongside the module. We're not using
        // the glue code, but if we set the EMIT_EMSCRIPTEN_METADATA flag when building, emscripten
        // will provide a custom section in the module itself with the required values.
        const METADATA_SIZE = 11;
        const METADATA_MAJOR = 0;
        const METADATA_MINOR = 2;
        const ABI_MAJOR = 0;
        const ABI_MINOR = 4;
        // The logic for reading metadata values here was copied from the emscripten source.
        const buffer = new Uint8Array(customSection);
        const metadata = [];
        let offset = 0;
        while (offset < buffer.byteLength) {
            let result = 0;
            let shift = 0;
            while (1) {
                const byte = buffer[offset++];
                result |= (byte & 0x7f) << shift;
                if (!(byte & 0x80)) {
                    break;
                }
                shift += 7;
            }
            metadata.push(result);
        }
        // The specifics of the section are not published anywhere official (yet). The values here
        // correspond to emscripten version 1.38.42:
        //   https://github.com/emscripten-core/emscripten/blob/1.38.42/tools/shared.py#L3051
        if (metadata.length < 4) {
            throw new Error(`emscripten metadata section should have at least 4 values; ` +
                `got ${metadata.length}`);
        }
        if (metadata[0] !== METADATA_MAJOR || metadata[1] !== METADATA_MINOR) {
            throw new Error(`emscripten metadata version should be ${METADATA_MAJOR}.${METADATA_MINOR}; ` +
                `got ${metadata[0]}.${metadata[1]}`);
        }
        if (metadata[2] !== ABI_MAJOR || metadata[3] !== ABI_MINOR) {
            throw new Error(`emscripten ABI version should be ${ABI_MAJOR}.${ABI_MINOR}; ` +
                `got ${metadata[2]}.${metadata[3]}`);
        }
        if (metadata.length !== METADATA_SIZE) {
            throw new Error(`emscripten metadata section should have ${METADATA_SIZE} values; ` +
                `got ${metadata.length}`);
        }
        // metadata[4] is 'Settings.WASM_BACKEND'; whether the binary is from wasm backend or fastcomp.
        // metadata[10] is 'tempdoublePtr'; appears to be related to pthreads and is not used here.
        this.cfg = {
            memSize: metadata[5],
            tableSize: metadata[6],
            globalBase: metadata[7],
            dynamicBase: metadata[8],
            dynamictopPtr: metadata[9],
        };
    }
    configureEnvironment(module, container, env) {
        container.memory = new WebAssembly.Memory({ initial: this.cfg.memSize, maximum: this.cfg.memSize });
        container.heapU8 = new Uint8Array(container.memory.buffer);
        container.heap32 = new Int32Array(container.memory.buffer);
        // We need to poke the address of the heap base into the memory buffer prior to instantiating.
        container.heap32[this.cfg.dynamictopPtr >> 2] = this.cfg.dynamicBase;
        Object.assign(env, {
            // Memory setup
            memory: container.memory,
            __memory_base: this.cfg.globalBase,
            table: new WebAssembly.Table({ initial: this.cfg.tableSize, maximum: this.cfg.tableSize, element: 'anyfunc' }),
            __table_base: 0,
            DYNAMICTOP_PTR: this.cfg.dynamictopPtr,
            // Heap management
            _emscripten_get_heap_size: () => container.heapU8.length,
            _emscripten_resize_heap: (size) => false,
            _emscripten_memcpy_big: (dst, src, num) => container.heapU8.set(container.heapU8.subarray(src, src + num), dst),
            // Error handling
            _systemError: (msg) => { throw new Error(container.readStr(msg)); },
            abortOnCannotGrowMemory: (size) => { throw new Error(`abortOnCannotGrowMemory(${size})`); },
            // Logging
            _setLogInfo: (file, line) => this.logInfo = [container.readStr(file).split(/[/\\]/).pop(), line],
            ___syscall146: (which, varargs) => this.sysWritev(container, which, varargs),
        });
    }
    initializeInstance(container, instance) {
        // Emscripten doesn't need main() invoked
    }
    // C++ printf support cribbed from emscripten glue js.
    sysWritev(container, which, varargs) {
        const get = () => {
            varargs += 4;
            return container.heap32[(((varargs) - (4)) >> 2)];
        };
        const output = (get() === 1) ? console.log : console.error;
        const iov = get();
        const iovcnt = get();
        const decoder = new external_util_["TextDecoder"]();
        let info = '';
        if (this.logInfo) {
            info = `[${this.logInfo[0]}:${this.logInfo[1]}] `;
            this.logInfo = null;
        }
        let bytes = [];
        let ret = 0;
        for (let i = 0; i < iovcnt; i++) {
            const ptr = container.heap32[(((iov) + (i * 8)) >> 2)];
            const len = container.heap32[(((iov) + (i * 8 + 4)) >> 2)];
            for (let j = 0; j < len; j++) {
                const curr = container.heapU8[ptr + j];
                if (curr === 0 || curr === 10) { // NUL or \n
                    output(info + decoder.decode(Uint8Array.from(bytes)));
                    info = '';
                    bytes = [];
                }
                else {
                    bytes.push(curr);
                }
            }
            ret += len;
        }
        return ret;
    }
}
class KotlinWasmDriver {
    configureEnvironment(module, container, env) {
        Object.assign(env, {
            // These two are used by launcher.cpp
            Konan_js_arg_size: (index) => 1,
            Konan_js_fetch_arg: (index, ptr) => 'dummyArg',
            // These two are imported, but never used
            Konan_js_allocateArena: (array) => { },
            Konan_js_freeArena: (arenaIndex) => { },
            // These two are used by logging functions
            write: (ptr) => console.log(container.readStr(ptr)),
            flush: () => { },
            // Apparently used by Kotlin Memory management
            Konan_notify_memory_grow: () => this.updateMemoryViews(container),
            // Kotlin's own glue for abort and exit
            Konan_abort: (pointer) => { throw new Error('Konan_abort(' + container.readStr(pointer) + ')'); },
            Konan_exit: (status) => { },
            // Needed by some code that tries to get the current time in it's runtime
            Konan_date_now: (pointer) => {
                const now = Date.now();
                const high = Math.floor(now / 0xffffffff);
                const low = Math.floor(now % 0xffffffff);
                container.heap32[pointer] = low;
                container.heap32[pointer + 1] = high;
            },
        });
    }
    // Kotlin manages its own heap construction, as well as tables.
    initializeInstance(container, instance) {
        this.updateMemoryViews(container);
        // Kotlin main() must be invoked before everything else.
        // TODO(alxrsngtn): Work out how to give Konan_js_main a type signature.
        instance.exports.Konan_js_main(1, 0);
    }
    updateMemoryViews(container) {
        container.memory = container.exports.memory;
        container.heapU8 = new Uint8Array(container.memory.buffer);
        container.heap32 = new Int32Array(container.memory.buffer);
    }
}
// Holds an instance of a running wasm module, which may contain multiple particles.
class wasm_WasmContainer {
    constructor(storageFrontend, loader, apiPort) {
        this.particleMap = new Map();
        this.storageFrontend = storageFrontend;
        this.loader = loader;
        this.apiPort = apiPort;
    }
    async initialize(buffer) {
        // TODO: vet the imports/exports on 'module'
        // TODO: use compileStreaming? requires passing the fetch() Response, not its ArrayBuffer
        const module = await WebAssembly.compile(buffer);
        const driver = this.driverForModule(module);
        // Shared ENV between Emscripten and Kotlin
        const env = {
            abort: () => { throw new Error('Abort!'); },
            // Inner particle API
            // TODO: guard against null/empty args from the wasm side
            _singletonSet: (p, h, entity) => this.getParticle(p).singletonSet(h, entity),
            _singletonClear: (p, h) => this.getParticle(p).singletonClear(h),
            _collectionStore: (p, h, entity) => this.getParticle(p).collectionStore(h, entity),
            _collectionRemove: (p, h, entity) => this.getParticle(p).collectionRemove(h, entity),
            _collectionClear: (p, h) => this.getParticle(p).collectionClear(h),
            _onRenderOutput: (p, template, model) => this.getParticle(p).onRenderOutput(template, model),
            _dereference: (p, id, key, hash, cid) => this.getParticle(p).dereference(id, key, hash, cid),
            _serviceRequest: (p, call, args, tag) => this.getParticle(p).serviceRequest(call, args, tag),
            _resolveUrl: (url) => this.resolve(url),
        };
        driver.configureEnvironment(module, this, env);
        const global = { 'NaN': NaN, 'Infinity': Infinity };
        this.wasm = await WebAssembly.instantiate(module, { env, global });
        this.exports = this.wasm.exports;
        driver.initializeInstance(this, this.wasm);
    }
    driverForModule(module) {
        const customSections = WebAssembly.Module.customSections(module, 'emscripten_metadata');
        if (customSections.length === 1) {
            return new wasm_EmscriptenWasmDriver(customSections[0]);
        }
        return new KotlinWasmDriver();
    }
    getParticle(innerParticle) {
        return this.particleMap.get(innerParticle);
    }
    register(particle, innerParticle) {
        this.particleMap.set(innerParticle, particle);
    }
    // Allocates memory in the wasm container; the calling particle is responsible for freeing.
    resolve(urlPtr) {
        return this.storeStr(this.loader.resolve(this.readStr(urlPtr)));
    }
    // Allocates memory in the wasm container and stores a null-terminated UTF8 string.
    storeStr(str) {
        const bytes = new external_util_["TextEncoder"]().encode(str);
        const p = this.exports._malloc(bytes.length + 1);
        this.heapU8.set(bytes, p);
        this.heapU8[p + bytes.length] = 0;
        return p;
    }
    // Allocates memory in the wasm container and stores the given byte array.
    storeBytes(buf) {
        const p = this.exports._malloc(buf.size + 1);
        this.heapU8.set(buf.view(), p);
        this.heapU8[p + buf.size] = 0;
        return p;
    }
    // Convenience function for freeing one or more wasm memory allocations. Null pointers are ignored.
    free(...ptrs) {
        ptrs.forEach(p => p && this.exports._free(p));
    }
    readStr(idx) {
        return new external_util_["TextDecoder"]().decode(this.readBytes(idx));
    }
    readBytes(idx) {
        let end = idx;
        while (end < this.heapU8.length && this.heapU8[end] !== 0) {
            end++;
        }
        return this.heapU8.subarray(idx, end);
    }
}
// Creates and interfaces to a particle inside a WasmContainer's module.
class wasm_WasmParticle extends particle_Particle {
    constructor(id, container) {
        super();
        this.handleMap = new BiMap();
        this.encoders = new Map();
        this.decoders = new Map();
        // Map of schema hashes to the EntityTypes used by Reference values.
        this.typeMap = new BiMap();
        this.id = id;
        this.container = container;
        this.exports = container.exports;
        const fn = `_new${this.spec.name}`;
        if (!(fn in this.exports)) {
            throw this.reportedError(`wasm module does not export instantiator function '${fn}' for particle '${this.spec.name}'`);
        }
        this.innerParticle = this.exports[fn]();
        this.container.register(this, this.innerParticle);
        // TODO(sjmiles): probably rendering too soon: we need to render at least once, but we may have handle
        // work pending. @shans says: if the particle has readable handles, onHandleUpdate is guaranteed
        // to be called, otherwise we need `renderOutput` manually. Need to optimize this across all
        // particle bases.
        setTimeout(() => this.renderOutput(), 100);
    }
    renderOutput() {
        // not yet implemented in CPP
        if (this.exports['_renderOutput']) {
            this.exports._renderOutput(this.innerParticle);
        }
    }
    // TODO: for now we set up Handle objects with onDefineHandle and map them into the
    // wasm container through this call, which creates corresponding Handle objects in there.
    // That means entity transfer goes from the StorageProxy, deserializes at the outer Handle
    // which then notifies this class (calling onHandle*), and we then serialize into the wasm
    // transfer format. Obviously this can be improved.
    async setHandles(handles) {
        const refTypePromises = [];
        for (const [name, handle] of handles) {
            const p = this.container.storeStr(name);
            const wasmHandle = this.exports._connectHandle(this.innerParticle, p, handle.canRead, handle.canWrite);
            this.container.free(p);
            if (wasmHandle === 0) {
                throw this.reportedError(`Wasm particle failed to connect handle '${name}'`);
            }
            this.handleMap.set(handle, wasmHandle);
            refTypePromises.push(this.extractReferenceTypes(this.getEntityType(handle.type)));
        }
        await Promise.all(refTypePromises);
        this.exports._init(this.innerParticle);
    }
    getEntityType(type) {
        while (type) {
            if (type instanceof type_EntityType) {
                return type;
            }
            type = type.getContainedType();
        }
        return null;
    }
    async extractReferenceTypes(entityType) {
        if (!entityType)
            return;
        const schema = entityType.getEntitySchema();
        this.typeMap.set(await schema.hash(), entityType);
        for (const [field, descriptor] of Object.entries(schema.fields)) {
            await this.extractReferenceTypes(descriptor.getEntityType());
        }
    }
    async onHandleSync(handle, model) {
        const wasmHandle = this.handleMap.getL(handle);
        if (!model) {
            this.exports._syncHandle(this.innerParticle, wasmHandle, 0);
            return;
        }
        const encoder = this.getEncoder(handle.type);
        let p;
        if (handle instanceof handle_SingletonHandle) {
            p = this.container.storeBytes(await encoder.encodeSingleton(model));
        }
        else {
            p = this.container.storeBytes(await encoder.encodeCollection(model));
        }
        this.exports._syncHandle(this.innerParticle, wasmHandle, p);
        this.container.free(p);
    }
    // tslint:disable-next-line: no-any
    async onHandleUpdate(handle, update) {
        if (update.originator) {
            return;
        }
        const wasmHandle = this.handleMap.getL(handle);
        const encoder = this.getEncoder(handle.type);
        let p1 = 0;
        let p2 = 0;
        if (handle instanceof handle_SingletonHandle) {
            if (update.data) {
                p1 = this.container.storeBytes(await encoder.encodeSingleton(update.data));
            }
        }
        else {
            p1 = this.container.storeBytes(await encoder.encodeCollection(update.added || []));
            p2 = this.container.storeBytes(await encoder.encodeCollection(update.removed || []));
        }
        this.exports._updateHandle(this.innerParticle, wasmHandle, p1, p2);
        this.container.free(p1, p2);
    }
    // Ignored for wasm particles.
    async onHandleDesync(handle) { }
    async onFirstStart() {
        // TODO(heimlich, 4798): not yet implemented in CPP
        if (this.exports['_onFirstStart']) {
            this.exports._onFirstStart(this.innerParticle);
        }
    }
    // Store API.
    //
    // Each of these calls an async storage method, but we don't want to await them because returning
    // a Promise to wasm doesn't work, and control (surprisingly) returns to the calling wasm function
    // at the first await point anyway. However, our CRDTs make it safe to fire-and-forget the storage
    // updates, and the wasm handles already have the updated version of the stored data, so it's safe
    // to leave the promises floating.
    // If the given entity doesn't have an id, this will create one for it and return the new id
    // in allocated memory that the wasm particle must free. If the entity already has an id this
    // returns 0 (nulltpr).
    singletonSet(wasmHandle, entityPtr) {
        // tslint:disable-next-line: no-any
        const singleton = this.getHandle(wasmHandle);
        const decoder = this.getDecoder(singleton.type);
        const entity = decoder.decodeSingleton(this.container.readBytes(entityPtr));
        const p = this.ensureIdentified(entity, singleton);
        void singleton.set(entity);
        return p;
    }
    singletonClear(wasmHandle) {
        // tslint:disable-next-line: no-any
        const singleton = this.getHandle(wasmHandle);
        void singleton.clear();
    }
    // If the given entity doesn't have an id, this will create one for it and return the new id
    // in allocated memory that the wasm particle must free. If the entity already has an id this
    // returns 0 (nulltpr).
    collectionStore(wasmHandle, entityPtr) {
        // tslint:disable-next-line: no-any
        const collection = this.getHandle(wasmHandle);
        const decoder = this.getDecoder(collection.type);
        const entity = decoder.decodeSingleton(this.container.readBytes(entityPtr));
        const p = this.ensureIdentified(entity, collection);
        void collection.add(entity);
        return p;
    }
    collectionRemove(wasmHandle, entityPtr) {
        // tslint:disable-next-line: no-any
        const collection = this.getHandle(wasmHandle);
        const decoder = this.getDecoder(collection.type);
        const entity = decoder.decodeSingleton(this.container.readBytes(entityPtr));
        void collection.remove(entity);
    }
    collectionClear(wasmHandle) {
        // tslint:disable-next-line: no-any
        const collection = this.getHandle(wasmHandle);
        void collection.clear();
    }
    // Retrieves the entity held by a reference.
    async dereference(idPtr, keyPtr, hashPtr, continuationId) {
        const id = this.container.readStr(idPtr);
        const storageKey = this.container.readStr(keyPtr);
        const hash = this.container.readStr(hashPtr);
        const entityType = this.typeMap.getL(hash);
        if (!entityType) {
            throw this.reportedError(`entity type not found for schema hash '${hash}'`);
        }
        const encoder = this.getEncoder(entityType);
        const entity = await reference_Reference.retrieve(this.container.storageFrontend, id, storageKey, entityType, this.id);
        const p = this.container.storeBytes(await encoder.encodeSingleton(entity));
        this.exports._dereferenceResponse(this.innerParticle, continuationId, p);
        this.container.free(p);
    }
    getEncoder(type) {
        let encoder = this.encoders.get(type);
        if (!encoder) {
            encoder = wasm_StringEncoder.create(type);
            this.encoders.set(type, encoder);
        }
        return encoder;
    }
    getDecoder(type) {
        let decoder = this.decoders.get(type);
        if (!decoder) {
            decoder = wasm_StringDecoder.create(type, this.typeMap, this.container.storageFrontend);
            this.decoders.set(type, decoder);
        }
        return decoder;
    }
    getHandle(wasmHandle) {
        const handle = this.handleMap.getR(wasmHandle);
        if (!handle) {
            throw this.reportedError('attempted to write to unconnected handle');
        }
        return handle;
    }
    ensureIdentified(entity, handle) {
        let p = 0;
        // TODO: rework Reference/Entity internals to avoid this instance check?
        if (entity instanceof entity_Entity && !entity_Entity.isIdentified(entity)) {
            handle.createIdentityFor(entity);
            p = this.container.storeStr(entity_Entity.id(entity));
        }
        return p;
    }
    // in TS output is provided by `capabilities`, which is not available in WASM, so just go straight to output
    output(content) {
        this.container.apiPort.Output(this, content);
    }
    // render request call-back from wasm
    onRenderOutput(templatePtr, modelPtr) {
        const content = {};
        if (templatePtr) {
            content['template'] = this.container.readStr(templatePtr);
        }
        if (modelPtr) {
            content['model'] = wasm_StringDecoder.decodeDictionary(this.container.readBytes(modelPtr));
        }
        this.output(content);
    }
    // Wasm particles can request service calls with a Dictionary of arguments and an optional string
    // tag to disambiguate different requests to the same service call.
    async serviceRequest(callPtr, argsPtr, tagPtr) {
        const call = this.container.readStr(callPtr);
        const args = wasm_StringDecoder.decodeDictionary(this.container.readBytes(argsPtr));
        const tag = this.container.readStr(tagPtr);
        // tslint:disable-next-line: no-any
        const response = await this.service({ call, ...args });
        // Convert the arbitrary response object to key:value string pairs.
        const dict = {};
        if (typeof response === 'object') {
            for (const entry of Object.entries(response)) {
                // tslint:disable-next-line: no-any
                const [key, value] = entry;
                dict[key] = (typeof value === 'object') ? JSON.stringify(value) : (value + '');
            }
        }
        else {
            // Convert a plain value response to {value: 'string'}
            dict['value'] = response + '';
        }
        // We can't re-use the string pointers passed in as args to this method, because the await
        // point above means the call to internal::serviceRequest inside the wasm module will already
        // have completed, and the memory for those args will have been freed.
        const cp = this.container.storeStr(call);
        const rp = this.container.storeBytes(wasm_StringEncoder.encodeDictionary(dict));
        const tp = this.container.storeStr(tag);
        this.exports._serviceResponse(this.innerParticle, cp, rp, tp);
        this.container.free(cp, rp, tp);
    }
    fireEvent(slotName, event) {
        const sp = this.container.storeStr(slotName);
        const hp = this.container.storeStr(event.handler);
        const data = this.container.storeBytes(wasm_StringEncoder.encodeDictionary(event.data || {}));
        this.exports._fireEvent(this.innerParticle, sp, hp, data);
        this.container.free(sp, hp, data);
    }
    reportedError(msg) {
        const err = new Error(msg);
        // 1st line = 'Error: <msg>', 2nd line = this method, 3rd line = calling method, with the form:
        //   '    at WasmParticle.<method> (<file-info>)'
        const method = err.stack.split('\n')[2].match(/ at ([a-zA-Z._]+) /)[1];
        const userException = new UserException(err, method, this.id, this.spec.name);
        this.container.apiPort.ReportExceptionInHost(userException);
        return err;
    }
}
//# sourceMappingURL=wasm.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/storage-endpoint.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


class storage_endpoint_StorageEndpointImpl {
    constructor(storeInfo) {
        this.storeInfo = storeInfo;
        this.idPromise = null;
    }
    init(storageProxy, storageFrontend) {
        external_assert_default()(!this.storageProxy, `Storage proxy already initialized`);
        external_assert_default()(!this.storageFrontend, `Storage frontend already initialized`);
        this.storageProxy = storageProxy;
        this.storageFrontend = storageFrontend;
    }
    async onProxyMessage(message) {
        external_assert_default()(this.storageProxy, `Storage proxy must be initialized`);
        if (this.idPromise == null) {
            throw new Error('onProxyMessage called without first calling setCallback!');
        }
        message.id = await this.idPromise;
        if (message.id == null) {
            throw new Error('undefined id received .. somehow');
        }
        if (this.storageProxy instanceof storage_proxy_StorageProxy) {
            this.storageFrontend.storageProxyMessage(this.storageProxy, message);
        }
        else {
            // Proxy messages sent to Direct Store Muxers require a muxId in order to redirect the message to the correct store.
            external_assert_default()(message.muxId != null);
            this.storageFrontend.storageProxyMuxerMessage(this.storageProxy, message);
        }
    }
    reportExceptionInHost(exception) {
        external_assert_default()(this.storageFrontend, `Storage frontend must be initialized`);
        this.storageFrontend.reportExceptionInHost(exception);
    }
    setCallback(callback) {
        external_assert_default()(this.storageProxy, `Storage proxy must be initialized`);
        this.idPromise = new Promise(resolve => {
            if (this.storageProxy instanceof storage_proxy_StorageProxy) {
                this.storageFrontend.registerStorageProxy(this.storageProxy, callback, resolve);
            }
            else {
                this.storageFrontend.directStorageProxyMuxerRegister(this.storageProxy, callback, resolve);
            }
        });
    }
    getStorageFrontend() {
        external_assert_default()(this.storageFrontend, `storageFrontend must be initialized`);
        return this.storageFrontend;
    }
}
//# sourceMappingURL=storage-endpoint.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/particle-execution-context.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var particle_execution_context_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};













function handleFor(key, storageProxy, idGenerator, particle, canRead, canWrite, name) {
    return new (storageProxy.type.handleConstructor())(key, storageProxy, idGenerator, particle, canRead, canWrite, name);
}
let particle_execution_context_ParticleExecutionContext = class ParticleExecutionContext {
    constructor(port, pecId, idGenerator, loader) {
        this.particles = new Map();
        this.pendingLoads = [];
        this.keyedProxies = {};
        this.keyedProxyMuxers = {};
        this.wasmContainers = {};
        const pec = this;
        this.apiPort = new class extends api_channel_PECInnerPort {
            onDefineHandle(identifier, storeInfo, name, ttl) {
                return pec.createStorageProxy(storeInfo, ttl);
            }
            onDefineHandleFactory(identifier, storeInfo, name, ttl) {
                return pec.createStorageProxyMuxer(storeInfo);
            }
            onGetDirectStoreMuxerCallback(storeInfo, callback, name, id) {
                const storageProxyMuxer = pec.createStorageProxyMuxer(storeInfo);
                return [storageProxyMuxer, () => callback(storageProxyMuxer, storeInfo.storageKey.toString())];
            }
            onCreateHandleCallback(storeInfo, callback, name, id) {
                // TODO(shanestephens): plumb storageKey through to internally created handles too.
                const proxy = pec.createStorageProxy(storeInfo);
                return [proxy, () => callback(proxy)];
            }
            onMapHandleCallback(callback, id) {
                return [id, () => callback(id)];
            }
            onCreateSlotCallback(callback, hostedSlotId) {
                return [hostedSlotId, () => callback(hostedSlotId)];
            }
            onStop() {
                if (global['close'] && !global['inWorkerPool']) {
                    global['close']();
                }
            }
            async onInstantiateParticle(id, spec, proxies, proxyMuxers, reinstantiate) {
                return pec.instantiateParticle(id, spec, proxies, proxyMuxers, reinstantiate);
            }
            async onReloadParticles(ids) {
                return pec.reloadParticles(ids);
            }
            onSimpleCallback(callback, data) {
                callback(data);
            }
            onConstructArcCallback(callback, arc) {
                callback(arc);
            }
            onAwaitIdle(version) {
                pec.idle.then(a => {
                    // TODO: ui-particle's update is async, this is a workaround to allow ui-particles to
                    // update relevance, after handles are updated. Needs better idle signal.
                    setTimeout(() => this.Idle(version, pec.relevance), 0);
                });
            }
            onUIEvent(particle, slotName, event) {
                particle.fireEvent(slotName, event);
            }
        }(port);
        this.pecId = pecId;
        this.idGenerator = idGenerator;
        this.loader = loader;
        loader.setParticleExecutionContext(this);
        // Encapsulates system trace calls in messages.
        delegateSystemTraceApis(this.apiPort);
        /*
         * This code ensures that the relevant types are known
         * in the scope object, because otherwise we can't do
         * particleSpec resolution, which is currently a necessary
         * part of particle construction.
         *
         * Possibly we should eventually consider having particle
         * specifications separated from particle classes - and
         * only keeping type information on the arc side.
         */
    }
    generateID() {
        return this.idGenerator.newChildId(this.pecId).toString();
    }
    createStorageProxy(storeInfo, ttl) {
        const endpoint = new storage_endpoint_StorageEndpointImpl(storeInfo);
        const proxy = new storage_proxy_StorageProxy(endpoint, ttl);
        endpoint.init(proxy, this);
        return proxy;
    }
    createStorageProxyMuxer(storeInfo) {
        const endpoint = new storage_endpoint_StorageEndpointImpl(storeInfo);
        const proxy = new storage_proxy_muxer_StorageProxyMuxer(endpoint);
        endpoint.init(proxy, this);
        return proxy;
    }
    registerStorageProxy(storageProxy, messagesCallback, idCallback) {
        this.apiPort.Register(storageProxy, messagesCallback, idCallback);
    }
    directStorageProxyMuxerRegister(storageProxyMuxer, messagesCallback, idCallback) {
        this.apiPort.DirectStoreMuxerRegister(storageProxyMuxer, messagesCallback, idCallback);
    }
    storageProxyMessage(storageProxy, message) {
        this.apiPort.ProxyMessage(storageProxy, message);
    }
    storageProxyMuxerMessage(storageProxyMuxer, message) {
        this.apiPort.StorageProxyMuxerMessage(storageProxyMuxer, message);
    }
    reportExceptionInHost(exception) {
        this.apiPort.ReportExceptionInHost(exception);
    }
    innerArcHandle(arcId, particleId) {
        const pec = this;
        return {
            async createHandle(type, name, hostParticle) {
                if (type === null) {
                    throw new Error(`Can't create handle with null Type`);
                }
                return new Promise((resolve, reject) => pec.apiPort.ArcCreateHandle(proxy => {
                    const handle = handleFor(Math.random() + '', proxy, pec.idGenerator, hostParticle, true, true, name);
                    resolve(handle);
                }, arcId, type, name));
            },
            async mapHandle(handle) {
                return new Promise((resolve, reject) => pec.apiPort.ArcMapHandle(id => {
                    resolve(id);
                }, arcId, handle)); // recipe handle vs not?
            },
            async createSlot(transformationParticle, transformationSlotName, handleId) {
                // handleId: the ID of a handle (returned by `createHandle` above) this slot is rendering; null - if not applicable.
                // TODO: support multiple handle IDs.
                return new Promise((resolve, reject) => pec.apiPort.ArcCreateSlot(hostedSlotId => resolve(hostedSlotId), arcId, transformationParticle, transformationSlotName, handleId));
            },
            async loadRecipe(recipe) {
                // TODO: do we want to return a promise on completion?
                return new Promise((resolve, reject) => pec.apiPort.ArcLoadRecipe(arcId, recipe, response => {
                    if (response.error) {
                        reject(new Error(response.error));
                    }
                    else {
                        resolve(response);
                    }
                }));
            }
        };
    }
    /**
     * Establishes a backing storage proxy that's connected to the provided backing storage key.
     */
    async getStorageProxyMuxer(storageKey, type) {
        type = new type_MuxType(type);
        if (!this.keyedProxyMuxers[storageKey]) {
            this.keyedProxyMuxers[storageKey] = new Promise((resolve, reject) => {
                this.apiPort.GetDirectStoreMuxer((storageProxyMuxer, newStorageKey) => {
                    if (storageKey !== newStorageKey) {
                        throw new Error('returned storage key should always match provided storage key for new storage stack');
                    }
                    this.keyedProxyMuxers[newStorageKey] = storageProxyMuxer;
                    resolve(storageProxyMuxer);
                }, storageKey, type);
            });
        }
        return this.keyedProxyMuxers[storageKey];
    }
    capabilities(hasInnerArcs) {
        const cap = {
            // remote `services` impl
            serviceRequest: (particle, args, callback) => {
                this.apiPort.ServiceRequest(particle, args, callback);
            },
            // SlotObserver (UiBroker) render path
            output: (particle, content) => {
                this.apiPort.Output(particle, content);
            }
        };
        if (hasInnerArcs) {
            // TODO: Particle doesn't have an id field; not sure if it needs one or innerArcHandle shouldn't have that arg.
            cap.constructInnerArc = async (particle) => {
                return new Promise((resolve, reject) => this.apiPort.ConstructInnerArc(arcId => resolve(this.innerArcHandle(arcId, undefined)), particle));
            };
        }
        return cap;
    }
    // tslint:disable-next-line: no-any
    async instantiateParticle(id, spec, proxies, proxyMuxers, reinstantiate) {
        let resolve;
        const p = new Promise(res => resolve = res);
        this.pendingLoads.push(p);
        const particle = await this.createParticleFromSpec(id, spec);
        const handleMap = new Map();
        const handleFactoryMap = new Map();
        proxies.forEach((proxy, name) => {
            this.createHandle(particle, spec, id, name, proxy, handleMap);
        });
        proxyMuxers.forEach((proxyMuxer, name) => {
            this.createHandleFactory(name, proxyMuxer, handleFactoryMap);
        });
        return [particle, async () => {
                if (reinstantiate) {
                    particle.setCreated();
                }
                await this.assignHandle(particle, spec, id, handleMap, handleFactoryMap, p);
                resolve();
            }];
    }
    async reloadParticles(ids) {
        // Delete old particles' caches
        ids.forEach(id => {
            const oldParticle = this.particles.get(id);
            if (oldParticle.spec.implBlobUrl)
                delete oldParticle.spec.implBlobUrl;
            if (oldParticle.spec.implFile.endsWith('.wasm') && this.wasmContainers[oldParticle.spec.implFile]) {
                // For WASM particles the container will be re-instantiated along with all of the particles
                this.wasmContainers[oldParticle.spec.implFile] = undefined;
            }
        });
        const result = [];
        // Go through the given array of particles one by one
        for (const id of ids) {
            let resolve;
            const p = new Promise(res => resolve = res);
            this.pendingLoads.push(p);
            // Get the old particle
            const oldParticle = this.particles.get(id);
            // Create a new particle and replace the old one
            const particle = await this.createParticleFromSpec(id, oldParticle.spec);
            const handleMap = new Map();
            const handleFactoryMap = new Map();
            const storageList = [];
            for (const oldHandle of oldParticle.handles.values()) {
                const storage = oldHandle.storage;
                storageList.push(storage);
                await storage.pause();
            }
            // Create new handles and disable the handles of the old particles
            oldParticle.handles.forEach((oldHandle) => {
                this.createHandle(particle, oldParticle.spec, id, oldHandle.name, oldHandle.storage, handleMap);
                oldHandle.disable(oldParticle);
            });
            oldParticle.handleFactories.forEach((oldHandleFactory) => {
                this.createHandleFactory(oldHandleFactory.name, oldHandleFactory.storageProxyMuxer, handleFactoryMap);
            });
            result.push([particle, async () => {
                    // Set the new handles to the new particle
                    await this.assignHandle(particle, oldParticle.spec, id, handleMap, handleFactoryMap, p);
                    storageList.forEach(storage => storage.unpause());
                    resolve();
                }]);
        }
        return result;
    }
    createHandle(particle, spec, id, name, proxy, handleMap) {
        const connSpec = spec.handleConnectionMap.get(name);
        const handle = handleFor(id, proxy, this.idGenerator, particle, connSpec.isInput, connSpec.isOutput, name);
        handleMap.set(name, handle);
    }
    createHandleFactory(name, proxyMuxer, handleFactoryMap) {
        const handleFactory = new entity_handle_factory_EntityHandleFactory(proxyMuxer);
        handleFactoryMap.set(name, handleFactory);
    }
    async assignHandle(particle, spec, id, handleMap, handleFactoryMap, p) {
        await particle.callSetHandles(handleMap, handleFactoryMap, err => {
            if (typeof err === 'string') {
                err = new Error(err); // Convert to a real error.
            }
            const exc = new UserException(err, 'setHandles', id, spec.name);
            this.apiPort.ReportExceptionInHost(exc);
        });
        const idx = this.pendingLoads.indexOf(p);
        this.pendingLoads.splice(idx, 1);
    }
    async createParticleFromSpec(id, spec) {
        let particle;
        if (spec.implFile && spec.implFile.endsWith('.wasm')) {
            particle = await this.loadWasmParticle(id, spec);
            particle.setCapabilities(this.capabilities(false));
        }
        else {
            const clazz = await this.loader.loadParticleClass(spec);
            particle = new clazz();
            particle.setCapabilities(this.capabilities(true));
        }
        this.particles.set(id, particle);
        return particle;
    }
    async loadWasmParticle(id, spec) {
        external_assert_default()(spec.name.length > 0);
        let container = this.wasmContainers[spec.implFile];
        if (!container) {
            const buffer = await this.loader.loadBinaryResource(spec.implFile);
            if (!buffer || buffer.byteLength === 0) {
                throw new Error(`Failed to load wasm binary '${spec.implFile}'`);
            }
            container = new wasm_WasmContainer(this, this.loader, this.apiPort);
            await container.initialize(buffer);
            this.wasmContainers[spec.implFile] = container;
        }
        // Particle constructor expects spec to be attached to the class object (and attaches it to
        // the particle instance at that time).
        wasm_WasmParticle.spec = spec;
        const particle = new wasm_WasmParticle(id, container);
        wasm_WasmParticle.spec = null;
        return particle;
    }
    get relevance() {
        const rMap = new Map();
        this.particles.forEach(p => {
            if (p.relevances.length === 0) {
                return;
            }
            rMap.set(p, p.relevances);
            p.relevances.length = 0; // truncate
        });
        return rMap;
    }
    get busy() {
        // TODO(shans): check each proxy's scheduler for busy signal too.
        if (this.pendingLoads.length > 0) {
            return true;
        }
        if ([...this.particles.values()].filter(particle => particle.busy).length > 0) {
            return true;
        }
        return false;
    }
    get idle() {
        if (!this.busy) {
            return Promise.resolve();
        }
        const busyParticlePromises = [...this.particles.values()].filter(particle => particle.busy).map(async (particle) => particle.idle);
        // TODO(shans): check each proxy's scheduler for idleness too.
        return Promise.all([...this.pendingLoads, ...busyParticlePromises]).then(() => this.idle);
    }
};
particle_execution_context_ParticleExecutionContext = particle_execution_context_decorate([
    SystemTrace
], particle_execution_context_ParticleExecutionContext);

StorageKeyParser.addDefaultParser(volatile_VolatileStorageKey.protocol, volatile_VolatileStorageKey.fromString);
//# sourceMappingURL=particle-execution-context.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/fake-pec-factory.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


// TODO: Make this generic so that it can also be used in-browser, or add a
// separate in-process browser pec-factory.
function FakePecFactory(loader) {
    return (pecId, idGenerator) => {
        const channel = new message_channel_MessageChannel();
        // Each PEC should get its own loader.
        // tslint requires that we capture the unused pec reference
        const pec = new particle_execution_context_ParticleExecutionContext(channel.port1, pecId, idGenerator, loader.clone());
        return channel.port2;
    };
}
//# sourceMappingURL=fake-pec-factory.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/recipe-resolver.js
/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


class recipe_resolver_ResolveWalker extends recipe_walker_RecipeWalker {
    constructor(tactic, arc, options) {
        super(tactic);
        this.arc = arc;
        this.options = options;
    }
    onHandle(recipe, handle) {
        const error = (label) => {
            if (this.options && this.options.errors) {
                this.options.errors.set(handle, label);
            }
            return [];
        };
        if (handle.fate === '`slot' || handle.fate === 'join') {
            return [];
        }
        if (handle.type.slandleType()) {
            return [];
        }
        const arc = this.arc;
        if ((handle.connections.length === 0 && !handle.isJoined) ||
            (handle.id && handle.storageKey) || (!handle.type) ||
            (!handle.fate)) {
            return error('No connections to handle or missing handle information');
        }
        let mappable;
        if (!handle.id) {
            // Handle doesn't have an ID, finding by type and tags.
            const counts = directionCounts(handle);
            switch (handle.fate) {
                case 'use':
                    mappable = arc.findStoresByType(handle.type, { tags: handle.tags });
                    break;
                case 'map':
                case 'copy':
                    mappable = arc.context.findStoresByType(handle.type, { tags: handle.tags, subtype: true });
                    break;
                case 'create':
                case '?':
                    mappable = [];
                    break;
                default:
                    throw new Error(`unexpected fate ${handle.fate}`);
            }
        }
        else if (!handle.storageKey) {
            // Handle specified by the ID, but not yet mapped to storage.
            let storeById;
            switch (handle.fate) {
                case 'use':
                    storeById = arc.findStoreById(handle.id);
                    break;
                case 'map':
                case 'copy':
                    storeById = arc.context.findStoreById(handle.id);
                    break;
                case 'create':
                case '?':
                    break;
                default:
                    throw new Error(`unexpected fate ${handle.fate}`);
            }
            if (storeById) {
                mappable = [storeById];
            }
            else {
                return error(`cannot find associated store with handle id '${handle.id}'`);
            }
        }
        if (mappable.length === 0) {
            return error('Cannot find a handle matching requested type and tags.');
        }
        mappable = mappable.filter(incomingHandle => {
            for (const existingHandle of recipe.handles) {
                if (incomingHandle.id === existingHandle.id &&
                    existingHandle !== handle) {
                    return false;
                }
            }
            return true;
        });
        if (mappable.length === 0) {
            // TODO(jopra): Reconsider this behaviour.
            // Tracked at https://github.com/PolymerLabs/arcs/issues/3389
            return error('The only handles matching the requested type and tags are already present in this recipe');
        }
        return mappable.map(store => ((recipe, updateHandle) => {
            updateHandle.mapToStorage(store);
            return 0;
        }));
    }
    onSlotConnection(_recipe, slotConnection) {
        const error = (label) => {
            if (this.options && this.options.errors) {
                this.options.errors.set(slotConnection, label);
            }
            return [];
        };
        const arc = this.arc;
        if (slotConnection.isConnected()) {
            return error('Slot connection is already connected');
        }
        const slotSpec = slotConnection.getSlotSpec();
        const particle = slotConnection.particle;
        const { local, remote } = findAllSlotCandidates(particle, slotSpec, arc);
        const allSlots = [...local, ...remote];
        if (allSlots.length !== 1) {
            return error('There are multiple matching slots (match is ambiguous)');
        }
        const selectedSlot = allSlots[0];
        return (recipe, slotConnection) => {
            connectSlotConnection(slotConnection, selectedSlot);
            return 1;
        };
    }
    onPotentialSlotConnection(_recipe, particle, slotSpec) {
        const error = (label) => {
            if (this.options && this.options.errors) {
                this.options.errors.set(particle, label);
            }
            return [];
        };
        const arc = this.arc;
        const { local, remote } = findAllSlotCandidates(particle, slotSpec, arc);
        const allSlots = [...local, ...remote];
        if (allSlots.length !== 1) {
            return error('There are multiple matching slots for this slot spec (match is ambiguous)');
        }
        const selectedSlot = allSlots[0];
        return (_recipe, particle, slotSpec) => {
            const newSlotConnection = particle.addSlotConnection(slotSpec.name);
            connectSlotConnection(newSlotConnection, selectedSlot);
            return 1;
        };
    }
    // TODO(lindner): add typeof checks here and figure out where handle is coming from.
    onObligation(recipe, obligation) {
        // TODO(jopra): Log errors from here.
        const fromParticle = obligation.from.instance;
        const toParticle = obligation.to.instance;
        for (const fromConnection of Object.values(fromParticle.connections)) {
            for (const toConnection of Object.values(toParticle.connections)) {
                if (fromConnection.handle && fromConnection.handle === toConnection.handle) {
                    return (recipe, obligation) => {
                        recipe.removeObligation(obligation);
                        return 1;
                    };
                }
            }
        }
        return [];
    }
}
class recipe_resolver_ResolveRecipeAction extends Action {
    constructor(arc) {
        super();
        this.arc = arc;
    }
    withOptions(options) {
        this.options = options;
    }
    async generate(inputParams) {
        return recipe_resolver_ResolveWalker.walk(this.getResults(inputParams), new recipe_resolver_ResolveWalker(recipe_resolver_ResolveWalker.Permuted, this.arc, this.options), this);
    }
}
// Provides basic recipe resolution for recipes against a particular arc.
class RecipeResolver {
    constructor(arc) {
        this.resolver = new recipe_resolver_ResolveRecipeAction(arc);
    }
    // Attempts to run basic resolution on the given recipe. Returns a new
    // instance of the recipe normalized and resolved if possible. Returns null if
    // normalization or attempting to resolve slot connection fails.
    async resolve(recipe, options) {
        recipe = recipe.clone();
        if (!recipe.normalize(options)) {
            console.warn(`could not normalize a recipe: ${[...options.errors.values()].join('\n')}.\n${recipe.toString()}`);
            return null;
        }
        this.resolver.withOptions(options); // Smuggle error data around
        const result = await this.resolver.generateFrom([{ result: recipe, score: 1 }]);
        if (result.length === 0) {
            if (options && options.errors) {
                options.errors.set(recipe, 'Resolver generated 0 recipes');
            }
            return null;
        }
        return result[0].result;
    }
}
//# sourceMappingURL=recipe-resolver.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/services.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class Services {
    static register(name, service) {
        Services.registry[name] = service;
    }
    static async request(request) {
        let { service: name, invoke, call } = request;
        if (call) {
            [name, invoke] = call.split('.');
        }
        const service = Services.registry[name];
        if (service) {
            if (service[invoke]) {
                return service[invoke](request);
            }
        }
        return null;
    }
}
Services.registry = {};
Object.freeze(Services);
Services.register('test', {
    async classify(request) {
        return { data: `it's a pig, that don't fly straight` };
    }
});
//# sourceMappingURL=services.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/particle-execution-host.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var particle_execution_host_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};














let particle_execution_host_ParticleExecutionHost = class ParticleExecutionHost {
    constructor({ slotComposer, arc, ports }) {
        this._portByParticle = new Map();
        this.nextIdentifier = 0;
        this.idleVersion = 0;
        this.particles = [];
        this.close = () => {
            this.apiPorts.forEach(apiPort => apiPort.close());
        };
        this.arc = arc;
        this.slotComposer = slotComposer;
        this.apiPorts = ports.map(port => new particle_execution_host_PECOuterPortImpl(port, arc));
    }
    choosePortForParticle(particle) {
        external_assert_default()(!this._portByParticle.has(particle), `port already found for particle '${particle.spec.name}'`);
        const port = this.apiPorts.find(port => particle.isExternalParticle() === port.supportsExternalParticle());
        external_assert_default()(!!port, `No port found for '${particle.spec.name}'`);
        this._portByParticle.set(particle, port);
        return this.getPort(particle);
    }
    getPort(particle) {
        external_assert_default()(this._portByParticle.has(particle), `Cannot get port for particle '${particle.spec.name}'`);
        return this._portByParticle.get(particle);
    }
    stop() {
        this.apiPorts.forEach(apiPort => apiPort.Stop());
    }
    get idle() {
        if (this.idlePromise == undefined) {
            this.idlePromise = new Promise((resolve, reject) => {
                this.idleResolve = resolve;
            });
        }
        this.idleVersion = this.nextIdentifier;
        this.apiPorts.forEach(apiPort => apiPort.AwaitIdle(this.nextIdentifier++));
        return this.idlePromise;
    }
    get messageCount() {
        return [...this.apiPorts.values()].map(apiPort => apiPort.messageCount).reduce((prev, current) => prev + current, 0);
    }
    sendEvent(particle, slotName, event) {
        this.getPort(particle).UIEvent(particle, slotName, event);
    }
    async instantiate(particle, stores, storeMuxers, reinstantiate) {
        this.particles.push(particle);
        const apiPort = this.choosePortForParticle(particle);
        for (const [name, store] of stores) {
            apiPort.DefineHandle(store, store, name, particle.getConnectionByName(name).handle.getTtl());
        }
        for (const [name, storeMuxer] of storeMuxers) {
            apiPort.DefineHandleFactory(storeMuxer, storeMuxer, name, particle.getConnectionByName(name).handle.getTtl());
        }
        apiPort.InstantiateParticle(particle, particle.id.toString(), particle.spec, stores, storeMuxers, reinstantiate);
    }
    reload(particles) {
        // Create a mapping from port to given list of particles
        const portMap = new Map();
        particles.forEach(particle => {
            const port = this.getPort(particle);
            let list = portMap.get(port);
            if (!list) {
                list = [particle];
                portMap.set(port, list);
            }
            else {
                list.push(particle);
            }
        });
        // Reload particles based on ports
        portMap.forEach((particles, port) => {
            port.ReloadParticles(particles, particles.map(p => p.id.toString()));
        });
    }
    resolveIfIdle(version, relevance) {
        if (version === this.idleVersion) {
            this.idlePromise = undefined;
            this.idleResolve(relevance);
        }
    }
};
particle_execution_host_ParticleExecutionHost = particle_execution_host_decorate([
    SystemTrace
], particle_execution_host_ParticleExecutionHost);

class particle_execution_host_PECOuterPortImpl extends api_channel_PECOuterPort {
    constructor(port, arc) {
        super(port, arc);
        this.storageListenerRemovalCallbacks = [];
        this.arc = arc;
        const clientClass = getClientClass();
        if (clientClass) {
            this.systemTraceClient = new clientClass();
        }
    }
    // Should be called when closing apiPorts or re-instantiating particles to
    // clean up stale resources such as registered storage listeners, etc.
    clear() {
        this.storageListenerRemovalCallbacks.forEach(cb => { cb(); });
    }
    async onRegister(store, messagesCallback, idCallback) {
        return this.arc.storageService.onRegister(store, this.SimpleCallback.bind(this, messagesCallback), this.SimpleCallback.bind(this, idCallback));
    }
    async onDirectStoreMuxerRegister(store, messagesCallback, idCallback) {
        return this.arc.storageService.onRegister(store, this.SimpleCallback.bind(this, messagesCallback), this.SimpleCallback.bind(this, idCallback));
    }
    async onProxyMessage(store, message) {
        return this.arc.storageService.onProxyMessage(store, message);
    }
    async onStorageProxyMuxerMessage(store, message) {
        return this.arc.storageService.onProxyMessage(store, message);
    }
    onIdle(version, relevance) {
        this.arc.peh.resolveIfIdle(version, relevance);
    }
    async onGetDirectStoreMuxer(callback, storageKey, type) {
        if (!storageKey) {
            // TODO(shanestephens): What should we do here?!
            throw new Error(`Don't know how to invent new storage keys for new storage stack when we only have type information`);
        }
        const key = StorageKeyParser.parse(storageKey);
        const store = new store_info_StoreInfo({ id: storageKey, exists: Exists.MayExist, type, storageKey: key });
        this.GetDirectStoreMuxerCallback(store, store, callback, type.toString(), storageKey);
    }
    onConstructInnerArc(callback, particle) {
        const arc = this.arc.createInnerArc(particle);
        this.ConstructArcCallback(callback, arc);
    }
    async onArcCreateHandle(callback, arc, type, name) {
        // At the moment, inner arcs are not persisted like their containers, but are instead
        // recreated when an arc is deserialized. As a consequence of this, dynamically
        // created handles for inner arcs must always be volatile to prevent storage
        // in firebase.
        const storageKey = new volatile_VolatileStorageKey(arc.id, String(Math.random()));
        // TODO(shanestephens): Remove this once singleton types are expressed directly in recipes.
        if (type instanceof type_EntityType || type instanceof type_ReferenceType || type instanceof type_InterfaceType) {
            type = new type_SingletonType(type);
        }
        const store = await arc.createStore(type, name, null, [], storageKey);
        // Store belongs to the inner arc, but the transformation particle,
        // which itself is in the outer arc gets access to it.
        this.CreateHandleCallback(store, store, callback, name, store.id);
    }
    onArcMapHandle(callback, arc, handle) {
        external_assert_default()(this.arc.findStoreById(handle.id), `Cannot map nonexistent handle ${handle.id}`);
        // TODO: create hosted handles map with specially generated ids instead of returning the real ones?
        this.MapHandleCallback({}, callback, handle.id);
    }
    onArcCreateSlot(callback, arc, transformationParticle, transformationSlotName, handleId) {
        let hostedSlotId;
        if (this.arc.peh.slotComposer) {
            hostedSlotId = this.arc.peh.slotComposer.createHostedSlot(arc, transformationParticle, transformationSlotName, handleId);
        }
        this.CreateSlotCallback({}, callback, hostedSlotId);
    }
    async onArcLoadRecipe(arc, recipe, callback) {
        try {
            const manifest = await manifest_Manifest.parse(recipe, { loader: arc.loader, fileName: '' });
            const successResponse = {
                providedSlotIds: {}
            };
            let error = undefined;
            // TODO(wkorman): Consider reporting an error or at least warning if
            // there's more than one recipe since currently we silently ignore them.
            let recipe0 = manifest.recipes[0];
            if (recipe0) {
                for (const slot of recipe0.slots) {
                    slot.id = slot.id || arc.generateID('slot').toString();
                    if (slot.sourceConnection) {
                        const particlelocalName = slot.sourceConnection.particle.localName;
                        if (particlelocalName) {
                            successResponse.providedSlotIds[`${particlelocalName}.${slot.name}`] = slot.id;
                        }
                    }
                }
                const missingHandles = [];
                for (const handle of recipe0.handles) {
                    const fromHandle = this.arc.findStoreById(handle.id) || manifest.findStoreById(handle.id);
                    if (fromHandle) {
                        handle.mapToStorage(fromHandle);
                    }
                    else {
                        missingHandles.push(handle);
                        continue;
                    }
                }
                if (missingHandles.length > 0) {
                    let recipeToResolve = recipe0;
                    // We're resolving both against the inner and the outer arc.
                    for (const resolver of [new RecipeResolver(arc /* inner */), new RecipeResolver(this.arc /* outer */)]) {
                        recipeToResolve = await resolver.resolve(recipeToResolve) || recipeToResolve;
                    }
                    if (recipeToResolve === recipe0) {
                        error = `Recipe couldn't load due to missing handles [recipe=${recipe0}, missingHandles=${missingHandles.join('\n')}].`;
                    }
                    else {
                        recipe0 = recipeToResolve;
                    }
                }
                if (!error) {
                    const options = { errors: new Map() };
                    // If we had missing handles but we made it here, then we ran recipe
                    // resolution which will have already normalized the recipe.
                    if ((missingHandles.length > 0) || recipe0.normalize(options)) {
                        if (recipe0.isResolved()) {
                            // Map handles from the external environment that aren't yet in the inner arc.
                            // TODO(shans): restrict these to only the handles that are listed on the particle.
                            for (const handle of recipe0.handles) {
                                if (!arc.findStoreById(handle.id)) {
                                    let type = handle.type;
                                    // TODO(shanestephens): Remove this once singleton types are expressed directly in recipes.
                                    if (type instanceof type_EntityType || type instanceof type_InterfaceType || type instanceof type_ReferenceType) {
                                        type = new type_SingletonType(type);
                                    }
                                    await arc.createStore(type, handle.localName, handle.id, handle.tags, handle.storageKey);
                                }
                            }
                            // TODO: pass tags through too, and reconcile with similar logic
                            // in Arc.deserialize.
                            for (const store of manifest.stores) {
                                await this.arc._registerStore(store, []);
                            }
                            // TODO: Awaiting this promise causes tests to fail...
                            const instantiateAndCaptureError = async () => {
                                try {
                                    await arc.instantiate(recipe0);
                                }
                                catch (e) {
                                    this.SimpleCallback(callback, { error: e.message + e.stack });
                                }
                            };
                            floatingPromiseToAudit(instantiateAndCaptureError());
                        }
                        else {
                            error = `Recipe is not resolvable:\n${recipe0.toString({ showUnresolved: true })}`;
                        }
                    }
                    else {
                        error = `Recipe ${recipe0} could not be normalized:\n${[...options.errors.values()].join('\n')}`;
                    }
                }
            }
            else {
                error = 'No recipe defined';
            }
            this.SimpleCallback(callback, error ? { error } : successResponse);
        }
        catch (e) {
            this.SimpleCallback(callback, { error: e.message + e.stack });
        }
    }
    onOutput(particle, content) {
        const composer = this.arc.peh.slotComposer;
        if (composer && composer['delegateOutput']) {
            composer['delegateOutput'](this.arc, particle, content);
        }
    }
    onReportExceptionInHost(exception) {
        if (!exception.particleName && exception.particleId) {
            exception.particleName = this.arc.loadedParticleInfo.get(exception.particleId).spec.name;
        }
        reportSystemException(this.arc, exception);
    }
    async onServiceRequest(particle, request, callback) {
        const response = await Services.request(request);
        this.SimpleCallback(callback, response);
    }
    onSystemTraceBegin(tag, cookie) {
        if (this.systemTraceClient) {
            this.systemTraceClient.asyncTraceBegin(tag, cookie);
        }
    }
    onSystemTraceEnd(tag, cookie) {
        if (this.systemTraceClient) {
            this.systemTraceClient.asyncTraceEnd(tag, cookie);
        }
    }
}
particle_execution_host_decorate([
    NoTrace
], particle_execution_host_PECOuterPortImpl.prototype, "onSystemTraceBegin", null);
particle_execution_host_decorate([
    NoTrace
], particle_execution_host_PECOuterPortImpl.prototype, "onSystemTraceEnd", null);
//# sourceMappingURL=particle-execution-host.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/arc-serializer.js
/**
 * @license
 * Copyright (c) 2019 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


class arc_serializer_ArcSerializer {
    constructor(arc) {
        this.handles = '';
        this.resources = '';
        this.interfaces = '';
        this.memoryResourceNames = new Map();
        this.arc = arc;
    }
    async serialize() {
        return `
meta
  name: '${this.arc.id}'
  ${this.serializeStorageKey()}

${await this.serializeVolatileMemory()}

${await this.serializeHandles()}

${this.serializeParticles()}

@active
${this.arc.activeRecipe.toString()}`;
    }
    async serializeVolatileMemory() {
        let resourceNum = 0;
        const builder = new IndentingStringBuilder();
        for (const [key, value] of this.arc.volatileMemory.entries.entries()) {
            this.memoryResourceNames.set(key, `VolatileMemoryResource${resourceNum}`);
            const data = { root: value.root.data, locations: {} };
            for (const [key, entry] of Object.entries(value.locations)) {
                data.locations[key] = entry.data;
            }
            builder.push(`resource VolatileMemoryResource${resourceNum++} // ${key}`);
            builder.withIndent().push('start', ...JSON.stringify(data).split('\n'));
        }
        return builder.toString();
    }
    async _serializeStore(store, name) {
        const type = store.type.getContainedType() || store.type;
        if (type instanceof type_InterfaceType) {
            this.interfaces += type.interfaceInfo.toManifestString() + '\n';
        }
        const key = store.storageKey;
        const tags = this.arc.storeTagsById[store.id] || new Set();
        const handleTags = [...tags];
        // TODO: handle ramdisk stores correctly?
        switch (key.protocol) {
            case 'reference-mode':
            case 'ramdisk':
            case 'firebase':
            case 'pouchdb':
                this.handles += store.toManifestString({ handleTags, overrides: { name } }) + '\n';
                break;
            case 'volatile': {
                const storageKey = key;
                this.handles += store.toManifestString({ handleTags, overrides: { name, source: this.memoryResourceNames.get(storageKey.unique), origin: 'resource', includeKey: storageKey.toString() } }) + '\n';
                break;
            }
            default:
                throw new Error(`unknown storageKey protocol ${key.protocol}`);
        }
    }
    async serializeHandles() {
        let id = 0;
        const handlesToSkip = new Set();
        for (const handle of this.arc.activeRecipe.handles) {
            if (handle.fate === 'map') {
                const url = this.arc.context.findManifestUrlForHandleId(handle.id);
                this.resources += `import '${url}'\n`;
            }
            else if (handle.immediateValue) {
                // Immediate value handles have values inlined in the recipe and are not serialized.
                handlesToSkip.add(handle.id);
            }
        }
        for (const store of this.arc.stores) {
            if (handlesToSkip.has(store.id)) {
                continue;
            }
            await this._serializeStore(store, `Store${id++}`);
        }
        return this.resources + this.interfaces + this.handles;
    }
    serializeParticles() {
        const particleSpecs = [];
        // Particles used directly.
        particleSpecs.push(...this.arc.activeRecipe.particles.map(entry => entry.spec));
        // Particles referenced in an immediate mode.
        particleSpecs.push(...this.arc.activeRecipe.handles
            .filter(h => h.immediateValue)
            .map(h => h.immediateValue));
        const results = [];
        particleSpecs.forEach(spec => {
            for (const connection of spec.handleConnections) {
                if (connection.type instanceof type_InterfaceType) {
                    results.push(connection.type.interfaceInfo.toManifestString());
                }
            }
            results.push(spec.toString());
        });
        return results.join('\n');
    }
    serializeStorageKey() {
        if (this.arc.storageKey) {
            return `storageKey: '${this.arc.storageKey}'\n`;
        }
        return '';
    }
}
//# sourceMappingURL=arc-serializer.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/arc.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var arc_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Arc_1;



















let arc_Arc = Arc_1 = class Arc {
    constructor({ id, context, storageService, pecFactories, slotComposer, loader, storageKey, speculative, innerArc, stub, capabilitiesResolver, inspectorFactory, modality }) {
        this._activeRecipe = newRecipe();
        this._recipeDeltas = [];
        this.dataChangeCallbacks = new Map();
        // storage keys for referenced handles
        this.storeInfoById = {};
        // Map from each store ID to a set of tags. public for debug access
        this.storeTagsById = {};
        // Map from each store to its description (originating in the manifest).
        this.storeDescriptions = new Map();
        this.innerArcsByParticle = new Map();
        this.instantiateMutex = new Mutex();
        this.idGenerator = id_IdGenerator.newSession();
        this.loadedParticleInfo = new Map();
        // Volatile storage local to this Arc instance.
        this.volatileMemory = new volatile_VolatileMemory();
        this._context = context;
        this.modality = modality;
        // TODO: pecFactories should not be optional. update all callers and fix here.
        this.pecFactories = pecFactories && pecFactories.length > 0 ? pecFactories.slice() : [FakePecFactory(loader).bind(null)];
        // TODO(sjmiles): currently some UiBrokers need to recover arc from composer in order to forward events
        if (slotComposer && !slotComposer['arc']) {
            slotComposer['arc'] = this;
        }
        this.id = id;
        this.isSpeculative = !!speculative; // undefined => false
        this.isInnerArc = !!innerArc; // undefined => false
        this.isStub = !!stub;
        this._loader = loader;
        this.inspectorFactory = inspectorFactory;
        this.inspector = inspectorFactory && inspectorFactory.create(this);
        this.storageKey = storageKey;
        const ports = this.pecFactories.map(f => f(this.generateID(), this.idGenerator));
        this.peh = new particle_execution_host_ParticleExecutionHost({ slotComposer, arc: this, ports });
        this.volatileStorageDriverProvider = new volatile_VolatileStorageDriverProvider(this);
        DriverFactory.register(this.volatileStorageDriverProvider);
        this.capabilitiesResolver = capabilitiesResolver;
        this.storageService = storageService;
    }
    get loader() {
        return this._loader;
    }
    set modality(modality) {
        this._modality = modality;
    }
    get modality() {
        let modalities = [];
        if (this._modality) {
            modalities.push(this._modality);
        }
        // TODO(sjmiles): Modality rules are unclear. Seems to me the Arc should declare it's own modality
        // but many tests fail without these conditionals. Note that a Modality can represent a set of modalities.
        if (!this.activeRecipe.isEmpty()) {
            modalities.push(this.activeRecipe.modality);
        }
        if (!modalities.length) {
            modalities = this.context.allRecipes.map(recipe => recipe.modality);
        }
        return modality_Modality.union(modalities);
    }
    dispose() {
        for (const innerArc of this.innerArcs) {
            innerArc.dispose();
        }
        // TODO: disconnect all associated store event handlers
        this.peh.stop();
        this.peh.close();
        // Slot contexts and consumers from inner and outer arcs can be interwoven. Slot composer
        // is therefore disposed in its entirety with an outer Arc's disposal.
        if (!this.isInnerArc && this.peh.slotComposer) {
            this.peh.slotComposer.dispose();
        }
        DriverFactory.unregister(this.volatileStorageDriverProvider);
    }
    // Returns a promise that spins sending a single `AwaitIdle` message until it
    // sees no other messages were sent.
    async _waitForIdle() {
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const messageCount = this.peh.messageCount;
            const innerArcsLength = this.innerArcs.length;
            // tslint:disable-next-line: no-any
            await Promise.all([this.peh.idle, ...this.innerArcs.map(async (arc) => arc.idle)]);
            // We're idle if no new inner arcs appeared and this.pec had exactly 2 messages,
            // one requesting the idle status, and one answering it.
            if (this.innerArcs.length === innerArcsLength
                && this.peh.messageCount === messageCount + 2)
                break;
        }
    }
    // Work around a bug in the way we track idleness. It could be:
    // - in the new storage stack
    // - in DomMultiplexer
    // - in the idleness detection code.
    get idle() {
        return this._idle.then(async () => this._idle);
    }
    get _idle() {
        if (this.waitForIdlePromise) {
            return this.waitForIdlePromise;
        }
        // Store one active completion promise for use by any subsequent callers.
        // We explicitly want to avoid, for example, multiple simultaneous
        // attempts to identify idle state each sending their own `AwaitIdle`
        // message and expecting settlement that will never arrive.
        const promise = this._waitForIdle().then(() => this.waitForIdlePromise = null);
        this.waitForIdlePromise = promise;
        return promise;
    }
    findInnerArcs(particle) {
        return this.innerArcsByParticle.get(particle) || [];
    }
    // Inner arcs of this arc's transformation particles.
    // Does *not* include inner arcs of this arc's inner arcs.
    get innerArcs() {
        return [].concat(...this.innerArcsByParticle.values());
    }
    // This arc and all its descendants.
    // *Does* include inner arcs of this arc's inner arcs.
    get allDescendingArcs() {
        return [this].concat(...this.innerArcs.map(arc => arc.allDescendingArcs));
    }
    createInnerArc(transformationParticle) {
        const id = this.generateID('inner');
        const innerArc = new Arc_1({ id, storageService: this.storageService, pecFactories: this.pecFactories, slotComposer: this.peh.slotComposer, loader: this._loader, context: this.context, innerArc: true, speculative: this.isSpeculative, inspectorFactory: this.inspectorFactory });
        let particleInnerArcs = this.innerArcsByParticle.get(transformationParticle);
        if (!particleInnerArcs) {
            particleInnerArcs = [];
            this.innerArcsByParticle.set(transformationParticle, particleInnerArcs);
        }
        particleInnerArcs.push(innerArc);
        return innerArc;
    }
    async serialize() {
        await this.idle;
        return new arc_serializer_ArcSerializer(this).serialize();
    }
    // Writes `serialization` to the ArcInfo child key under the Arc's storageKey.
    // This does not directly use serialize() as callers may want to modify the
    // contents of the serialized arc before persisting.
    async persistSerialization(serialization) {
        throw new Error('persistSerialization unimplemented, pending synthetic type support in new storage stack');
    }
    static async deserialize({ serialization, pecFactories, slotComposer, loader, fileName, context, inspectorFactory, storageService }) {
        const manifest = await manifest_Manifest.parse(serialization, { loader, fileName, context });
        const id = Id.fromString(manifest.meta.name);
        const storageKey = StorageKeyParser.parse(manifest.meta.storageKey);
        const arc = new Arc_1({ id, storageKey, slotComposer, pecFactories, loader, context, inspectorFactory, storageService });
        await Promise.all(manifest.stores.map(async (storeStub) => {
            const tags = [...manifest.storeTagsById[storeStub.id]];
            if (storeStub.storageKey instanceof volatile_VolatileStorageKey) {
                arc.volatileMemory.deserialize(storeStub.model, storeStub.storageKey.unique);
            }
            await arc._registerStore(storeStub, tags);
            arc.addStoreToRecipe(storeStub);
        }));
        const recipe = manifest.activeRecipe.clone();
        const options = { errors: new Map() };
        external_assert_default()(recipe.normalize(options), `Couldn't normalize recipe ${recipe.toString()}:\n${[...options.errors.values()].join('\n')}`);
        await arc.instantiate(recipe, true);
        // TODO(shanestephens): if we decide that merging a 'use' handle adds any tags on that handle to
        // the handle in the underlying recipe, then we can remove this from here.
        for (const handle of recipe.handles) {
            const newHandle = arc._activeRecipe.findHandleByID(handle.id);
            for (const tag of handle.tags) {
                if (newHandle.tags.includes(tag)) {
                    continue;
                }
                newHandle.tags.push(tag);
            }
        }
        return arc;
    }
    get context() {
        return this._context;
    }
    get activeRecipe() { return this._activeRecipe; }
    get allRecipes() { return [this.activeRecipe].concat(this.context.allRecipes); }
    get recipes() { return [this.activeRecipe]; }
    get recipeDeltas() { return this._recipeDeltas; }
    loadedParticleSpecs() {
        return [...this.loadedParticleInfo.values()].map(({ spec }) => spec);
    }
    async _instantiateParticle(recipeParticle, reinstantiate) {
        if (!recipeParticle.id) {
            recipeParticle.id = this.generateID('particle');
        }
        const info = await this._getParticleInstantiationInfo(recipeParticle);
        await this.peh.instantiate(recipeParticle, info.stores, info.storeMuxers, reinstantiate);
    }
    async _getParticleInstantiationInfo(recipeParticle) {
        const info = { spec: recipeParticle.spec, stores: new Map(), storeMuxers: new Map() };
        this.loadedParticleInfo.set(recipeParticle.id.toString(), info);
        // if supported, provide particle caching via a BlobUrl representing spec.implFile
        if (!recipeParticle.isExternalParticle()) {
            await this._provisionSpecUrl(recipeParticle.spec);
        }
        for (const [name, connection] of Object.entries(recipeParticle.connections)) {
            if (connection.handle.fate !== '`slot') {
                const store = this.findStoreById(connection.handle.id);
                external_assert_default()(store, `can't find store of id ${connection.handle.id}`);
                external_assert_default()(info.spec.handleConnectionMap.get(name) !== undefined, 'can\'t connect handle to a connection that doesn\'t exist');
                if (store.isMuxEntityStore()) {
                    info.storeMuxers.set(name, store);
                }
                else {
                    info.stores.set(name, store);
                }
            }
        }
        return info;
    }
    async _provisionSpecUrl(spec) {
        // if supported, construct spec.implBlobUrl for spec.implFile
        if (spec.implFile && !spec.implBlobUrl) {
            if (this.loader) {
                const url = await this.loader.provisionObjectUrl(spec.implFile);
                if (url) {
                    spec.setImplBlobUrl(url);
                }
            }
        }
    }
    generateID(component = '') {
        return this.idGenerator.newChildId(this.id, component);
    }
    get stores() {
        return Object.values(this.storeInfoById);
    }
    async getActiveStore(storeInfo) {
        return this.storageService.getActiveStore(storeInfo);
    }
    // Makes a copy of the arc used for speculative execution.
    async cloneForSpeculativeExecution() {
        const arc = new Arc_1({ id: this.generateID(),
            pecFactories: this.pecFactories,
            context: this.context,
            loader: this._loader,
            speculative: true,
            innerArc: this.isInnerArc,
            inspectorFactory: this.inspectorFactory,
            storageService: this.storageService });
        const storeMap = new Map();
        for (const storeInfo of this.stores) {
            // TODO(alicej): Should we be able to clone a StoreMux as well?
            const cloneInfo = new store_info_StoreInfo({
                storageKey: new volatile_VolatileStorageKey(this.id, storeInfo.id),
                exists: Exists.MayExist,
                type: storeInfo.type,
                id: storeInfo.id
            });
            await (await arc.getActiveStore(cloneInfo)).cloneFrom(await this.getActiveStore(storeInfo));
            storeMap.set(storeInfo, cloneInfo);
            if (this.storeDescriptions.has(storeInfo)) {
                arc.storeDescriptions.set(cloneInfo, this.storeDescriptions.get(storeInfo));
            }
        }
        this.loadedParticleInfo.forEach((info, id) => {
            const stores = new Map();
            info.stores.forEach((store, name) => stores.set(name, storeMap.get(store)));
            arc.loadedParticleInfo.set(id, { spec: info.spec, stores });
        });
        const { cloneMap } = this._activeRecipe.mergeInto(arc._activeRecipe);
        this._recipeDeltas.forEach(recipe => arc._recipeDeltas.push({
            particles: recipe.particles.map(p => cloneMap.get(p)),
            handles: recipe.handles.map(h => cloneMap.get(h)),
            slots: recipe.slots.map(s => cloneMap.get(s)),
            patterns: recipe.patterns
        }));
        for (const [particle, innerArcs] of this.innerArcsByParticle.entries()) {
            arc.innerArcsByParticle.set(cloneMap.get(particle), await Promise.all(innerArcs.map(async (arc) => arc.cloneForSpeculativeExecution())));
        }
        for (const v of storeMap.values()) {
            // FIXME: Tags
            await arc._registerStore(v, []);
        }
        return arc;
    }
    /**
     * Instantiates the given recipe in the Arc.
     *
     * Executes the following steps:
     *
     * - Merges the recipe into the Active Recipe
     * - Populates missing slots.
     * - Processes the Handles and creates stores for them.
     * - Instantiates the new Particles
     * - Passes these particles for initialization in the PEC
     *
     * Waits for completion of an existing Instantiate before returning.
     */
    async instantiate(recipe, reinstantiate = false) {
        external_assert_default()(recipe.isResolved(), `Cannot instantiate an unresolved recipe: ${recipe.toString({ showUnresolved: true })}`);
        external_assert_default()(recipe.isCompatible(this.modality), `Cannot instantiate recipe ${recipe.toString()} with [${recipe.modality.names}] modalities in '${this.modality.names}' arc`);
        const release = await this.instantiateMutex.acquire();
        try {
            await this._doInstantiate(recipe, reinstantiate);
        }
        finally {
            release();
        }
    }
    async mergeIntoActiveRecipe(recipe) {
        const { handles, particles, slots } = recipe.mergeInto(this._activeRecipe);
        // handles represents only the new handles; it doesn't include 'use' handles that have
        // resolved against the existing recipe.
        this._recipeDeltas.push({ particles, handles, slots, patterns: recipe.patterns });
        // TODO(mmandlis, jopra): Get rid of populating the missing local slot & slandle IDs here,
        // it should be done at planning stage.
        slots.forEach(slot => slot.id = slot.id || this.generateID('slot').toString());
        handles.forEach(handle => {
            if (handle.toSlot()) {
                handle.id = handle.id || this.generateID('slandle').toString();
            }
        });
        for (const recipeHandle of handles) {
            if (recipeHandle.fate === 'use') {
                throw new Error(`store '${recipeHandle.id}' with "use" fate was not found in recipe`);
            }
            if (['copy', 'create'].includes(recipeHandle.fate)) {
                let type = recipeHandle.type;
                if (recipeHandle.fate === 'create') {
                    external_assert_default()(type.maybeEnsureResolved(), `Can't assign resolved type to ${type}`);
                }
                type = type.resolvedType();
                external_assert_default()(type.isResolved(), `Can't create handle for unresolved type ${type}`);
                const storeId = recipeHandle.fate === 'create' && !!recipeHandle.id ? recipeHandle.id : this.generateID().toString();
                const volatileKey = recipeHandle.immediateValue
                    ? new volatile_VolatileStorageKey(this.id, '').childKeyForHandle(storeId)
                    : undefined;
                // TODO(shanestephens): Remove this once singleton types are expressed directly in recipes.
                if (type instanceof type_EntityType || type instanceof type_ReferenceType || type instanceof type_InterfaceType) {
                    type = new type_SingletonType(type);
                }
                const newStore = await this.createStoreInternal(type, /* name= */ null, storeId, recipeHandle.tags, volatileKey, recipeHandle.capabilities);
                if (recipeHandle.immediateValue) {
                    const particleSpec = recipeHandle.immediateValue;
                    const type = recipeHandle.type;
                    if (newStore.isSingletonInterfaceStore()) {
                        external_assert_default()(type instanceof type_InterfaceType && type.interfaceInfo.particleMatches(particleSpec));
                        const handle = await handleForStoreInfo(newStore, this, { ttl: recipeHandle.getTtl() });
                        await handle.set(particleSpec.clone());
                    }
                    else {
                        throw new Error(`Can't currently store immediate values in non-singleton stores`);
                    }
                }
                else if (['copy', 'map'].includes(recipeHandle.fate)) {
                    const copiedStoreRef = this.context.findStoreById(recipeHandle.id);
                    const copiedActiveStore = await this.getActiveStore(copiedStoreRef);
                    external_assert_default()(copiedActiveStore, `Cannot find store ${recipeHandle.id}`);
                    const activeStore = await this.getActiveStore(newStore);
                    await activeStore.cloneFrom(copiedActiveStore);
                    this._tagStore(newStore, this.context.findStoreTags(copiedStoreRef));
                    newStore.name = copiedStoreRef.name && `Copy of ${copiedStoreRef.name}`;
                    const copiedStoreDesc = this.getStoreDescription(copiedStoreRef);
                    if (copiedStoreDesc) {
                        this.storeDescriptions.set(newStore, copiedStoreDesc);
                    }
                }
                recipeHandle.id = newStore.id;
                recipeHandle.fate = 'use';
                recipeHandle.storageKey = newStore.storageKey;
                continue;
                // TODO: move the call to ParticleExecutionHost's DefineHandle to here
            }
            // TODO(shans/sjmiles): This shouldn't be possible, but at the moment the
            // shell pre-populates all arcs with a set of handles so if a recipe explicitly
            // asks for one of these there's a conflict. Ideally these will end up as a
            // part of the context and will be populated on-demand like everything else.
            if (this.storeInfoById[recipeHandle.id]) {
                continue;
            }
            if (recipeHandle.fate !== '`slot') {
                let storageKey = recipeHandle.storageKey;
                if (!storageKey) {
                    storageKey = this.keyForId(recipeHandle.id);
                }
                external_assert_default()(storageKey, `couldn't find storage key for handle '${recipeHandle}'`);
                let type = recipeHandle.type.resolvedType();
                external_assert_default()(type.isResolved());
                if (!type.isSingleton && !type.isCollectionType()) {
                    type = new type_SingletonType(type);
                }
                const store = new store_info_StoreInfo({ storageKey, exists: Exists.ShouldExist, type, id: recipeHandle.id });
                await this._registerStore(store, recipeHandle.tags);
            }
        }
        return { handles, particles, slots };
    }
    // Critical section for instantiate,
    async _doInstantiate(recipe, reinstantiate = false) {
        const { particles } = await this.mergeIntoActiveRecipe(recipe);
        await Promise.all(particles.map(recipeParticle => this._instantiateParticle(recipeParticle, reinstantiate)));
        if (this.inspector) {
            await this.inspector.recipeInstantiated(particles, this.activeRecipe.toString());
        }
    }
    addStoreToRecipe(storeInfo) {
        const handle = this.activeRecipe.newHandle();
        handle.mapToStorage(storeInfo);
        handle.fate = 'use';
        // TODO(shans): is this the right thing to do? This seems not to be the right thing to do!
        handle['_type'] = handle.mappedType;
    }
    // TODO(shanestephens): Once we stop auto-wrapping in singleton types below, convert this to return a well-typed store.
    async createStore(type, name, id, tags, storageKey, capabilities) {
        const store = await this.createStoreInternal(type, name, id, tags, storageKey, capabilities);
        this.addStoreToRecipe(store);
        return store;
    }
    async createStoreInternal(type, name, id, tags, storageKey, capabilities) {
        external_assert_default()(type instanceof type_Type, `can't createStore with type ${type} that isn't a Type`);
        if (type instanceof type_TupleType) {
            throw new Error('Tuple type is not yet supported');
        }
        if (id == undefined) {
            id = this.generateID().toString();
        }
        if (storageKey == undefined) {
            if (this.capabilitiesResolver) {
                storageKey = await this.capabilitiesResolver.createStorageKey(capabilities || capabilities_Capabilities.create(), type, id);
            }
            else if (this.storageKey) {
                storageKey = this.storageKey.childKeyForHandle(id);
            }
        }
        const hasVolatileTag = (tags) => tags && tags.includes('volatile');
        if (storageKey == undefined || hasVolatileTag(tags)) {
            storageKey = new volatile_VolatileStorageKey(this.id, id);
        }
        // Catch legacy cases that expected us to wrap entity types in a singleton.
        if (type.isEntity || type.isInterface || type.isReference) {
            throw new Error('unwrapped type provided to arc.createStore');
        }
        const existingStore = Object.values(this.storeInfoById).find(store => store.storageKey === storageKey);
        if (existingStore) {
            external_assert_default()(existingStore.id === id, `Different store ids for same storage key? Is this an error?`);
            return existingStore;
        }
        const store = new store_info_StoreInfo({ storageKey, type, exists: Exists.MayExist, id, name });
        await this._registerStore(store, tags);
        if (storageKey instanceof reference_mode_storage_key_ReferenceModeStorageKey) {
            const refContainedType = new type_ReferenceType(type.getContainedType());
            const refType = type.isSingleton ? new type_SingletonType(refContainedType) : new type_CollectionType(refContainedType);
            await this.createStore(refType, name ? name + '_referenceContainer' : null, null, [], storageKey.storageKey);
            await this.createStore(new type_CollectionType(type.getContainedType()), name ? name + '_backingStore' : null, null, [], storageKey.backingKey);
        }
        return store;
    }
    async _registerStore(store, tags) {
        external_assert_default()(!this.storeInfoById[store.id], `Store already registered '${store.id}'`);
        tags = tags || [];
        tags = Array.isArray(tags) ? tags : [tags];
        if (!(store.type.handleConstructor())) {
            throw new Error(`Type not supported by storage: '${store.type.tag}'`);
        }
        this.storeInfoById[store.id] = store;
        this.storeTagsById[store.id] = new Set(tags);
        const activeStore = await this.getActiveStore(store);
        activeStore.on(async () => this._onDataChange());
        this.context.registerStore(store, tags);
    }
    _tagStore(store, tags = new Set()) {
        external_assert_default()(this.storeInfoById[store.id] && this.storeTagsById[store.id], `Store not registered '${store.id}'`);
        tags.forEach(tag => this.storeTagsById[store.id].add(tag));
    }
    _onDataChange() {
        for (const callback of this.dataChangeCallbacks.values()) {
            callback();
        }
    }
    onDataChange(callback, registration) {
        this.dataChangeCallbacks.set(registration, callback);
    }
    clearDataChange(registration) {
        this.dataChangeCallbacks.delete(registration);
    }
    // Convert a type to a normalized key that we can use for
    // equality testing.
    //
    // TODO: we should be testing the schemas for compatiblity instead of using just the name.
    // TODO: now that this is only used to implement findStoresByType we can probably replace
    // the check there with a type system equality check or similar.
    static _typeToKey(type) {
        if (type.isSingleton) {
            type = type.getContainedType();
        }
        const elementType = type.getContainedType();
        if (elementType) {
            const key = this._typeToKey(elementType);
            if (key) {
                return `list:${key}`;
            }
        }
        else if (type instanceof type_EntityType) {
            return type.entitySchema.name;
        }
        else if (type instanceof type_InterfaceType) {
            // TODO we need to fix this too, otherwise all handles of interface type will
            // be of the 'same type' when searching by type.
            return type.interfaceInfo;
        }
        else if (type instanceof type_TypeVariable && type.isResolved()) {
            return Arc_1._typeToKey(type.resolvedType());
        }
        return null;
    }
    findStoresByType(type, options) {
        const typeKey = Arc_1._typeToKey(type);
        let stores = Object.values(this.storeInfoById).filter(handle => {
            if (typeKey) {
                const handleKey = Arc_1._typeToKey(handle.type);
                if (typeKey === handleKey) {
                    return true;
                }
            }
            else {
                if (type instanceof type_TypeVariable && !type.isResolved() && handle.type instanceof type_EntityType || handle.type instanceof type_SingletonType) {
                    return true;
                }
                // elementType will only be non-null if type is either Collection or BigCollection; the tag
                // comparison ensures that handle.type is the same sort of collection.
                const elementType = type.getContainedType();
                if (elementType && elementType instanceof type_TypeVariable && !elementType.isResolved() && type.tag === handle.type.tag) {
                    return true;
                }
            }
            return false;
        });
        if (options && options.tags && options.tags.length > 0) {
            stores = stores.filter(store => options.tags.filter(tag => !this.storeTagsById[store.id].has(tag)).length === 0);
        }
        // Quick check that a new handle can fulfill the type contract.
        // Rewrite of this method tracked by https://github.com/PolymerLabs/arcs/issues/1636.
        return stores.filter(s => {
            const isInterface = s.type.getContainedType() ? s.type.getContainedType() instanceof type_InterfaceType : s.type instanceof type_InterfaceType;
            return !!effectiveTypeForHandle(type, [{ type: s.type, direction: isInterface ? 'hosts' : 'reads writes' }]);
        });
    }
    findStoreById(id) {
        return this.storeInfoById[id];
    }
    findStoreTags(storeInfo) {
        return this.storeTagsById[storeInfo.id] || this._context.findStoreTags(storeInfo);
    }
    getStoreDescription(storeInfo) {
        external_assert_default()(storeInfo, 'Cannot fetch description for nonexistent store');
        return this.storeDescriptions.get(storeInfo) || storeInfo.description;
    }
    getVersionByStore({ includeArc = true, includeContext = false }) {
        const versionById = {};
        if (includeArc) {
            for (const id of Object.keys(this.storeInfoById)) {
                versionById[id] = this.storeInfoById[id].versionToken;
            }
        }
        if (includeContext) {
            this._context.allStores.forEach(handle => versionById[handle.id] = handle.versionToken);
        }
        return versionById;
    }
    keyForId(id) {
        return this.storeInfoById[id].storageKey;
    }
    toContextString() {
        const results = [];
        const storeInfos = Object.values(this.storeInfoById).sort(compareComparables);
        storeInfos.forEach(storeInfo => {
            results.push(storeInfo.toManifestString({ handleTags: [...this.storeTagsById[storeInfo.id]] }));
        });
        // TODO: include stores entities
        // TODO: include (remote) slots?
        if (!this._activeRecipe.isEmpty()) {
            results.push(this._activeRecipe.toString());
        }
        return results.join('\n');
    }
    get apiChannelMappingId() {
        return this.id.toString();
    }
};
arc_Arc = Arc_1 = arc_decorate([
    SystemTrace
], arc_Arc);

//# sourceMappingURL=arc.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/runtime-cache.js
/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class CacheKey {
    constructor(id) {
        this.identifier = id;
    }
}
class RuntimeCacheService {
    constructor() {
        this.map = new Map();
    }
    getOrCreateCache(name) {
        if (!this.map.has(name)) {
            this.map.set(name, new Map());
        }
        return this.map.get(name);
    }
}
//# sourceMappingURL=runtime-cache.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/slot-composer.js
/**
 * @license
 * Copyright (c) 2017 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


const { log: slot_composer_log, warn: slot_composer_warn } = logsFactory('SlotComposer', 'brown');
class slot_composer_SlotComposer {
    /**
     * |options| must contain:
     * - modalityName: the UI modality the slot-composer renders to (for example: dom).
     * - modalityHandler: the handler for UI modality the slot-composer renders to.
     * - rootContainer: the top level container to be used for slots.
     * and may contain:
     * - containerKind: the type of container wrapping each slot-context's container  (for example, div).
     */
    constructor(options) {
        this._contexts = [];
        const opts = {
            containers: { 'root': 'root-context' },
            ...options
        };
        // See SlotUtils::findAllSlotCandidates
        Object.keys(opts.containers).forEach(slotName => {
            const context = this.createContextForContainer(slotName);
            this._contexts.push(context);
        });
    }
    createContextForContainer(name) {
        return {
            id: `rootslotid-${name}`,
            name,
            tags: [`${name}`],
            spec: new ProvideSlotConnectionSpec({ name }),
            handles: []
        };
    }
    getAvailableContexts() {
        return this._contexts.concat(this.arc.activeRecipe.slots);
    }
    createHostedSlot(innerArc, particle, slotName, storeId) {
        // TODO(sjmiles): rationalize snatching off the zero-th entry
        const connection = particle.getSlandleConnections()[0];
        // TODO(sjmiles): this slot-id is created dynamically and was not available to the particle
        // who renderered the slot (i.e. the dom node or other container). The renderer identifies these
        // slots by entity-id (`subid`) instead. But `subid` is not unique, we need more information to
        // locate the output slot, so we embed the muxed-slot's id into our output-slot-id.
        return `${connection.targetSlot.id}___${innerArc.generateID('slot')}`;
    }
    dispose() {
        this.disposeObserver();
    }
    observeSlots(slotObserver) {
        this['slotObserver'] = slotObserver;
        slotObserver.dispatch = (pid, eventlet) => {
            console.log('slot-composer dispatch for pid', pid, eventlet);
            this.sendEvent(pid, eventlet);
        };
    }
    disposeObserver() {
        const observer = this['slotObserver'];
        if (observer) {
            observer.dispose();
        }
    }
    sendEvent(particleId, eventlet) {
        slot_composer_log('sendEvent:', particleId, eventlet);
        const arc = this.arc;
        if (arc && arc.activeRecipe) {
            const particle = arc.activeRecipe.findParticle(particleId);
            arc.peh.sendEvent(particle, '', eventlet);
        }
    }
    // TODO(sjmiles): could use more factoring
    delegateOutput(arc, particle, content) {
        const observer = this['slotObserver'];
        if (observer && content) {
            // we scan connections for container and slotMap
            const connections = particle.getSlandleConnections();
            // assemble a renderPacket to send to slot observer
            const packet = {};
            // identify parent container
            const container = connections[0];
            if (container) {
                Object.assign(packet, {
                    containerSlotName: container.targetSlot.name,
                    containerSlotId: container.targetSlot.id,
                });
            }
            // Set modality according to particle spec.
            const modality = particle.recipe.modality;
            if (!modality.all) {
                Object.assign(packet, {
                    modality: modality.names.join(',')
                });
            }
            // build slot id map
            const slotMap = {};
            connections.forEach(({ providedSlots }) => {
                Object.values(providedSlots).forEach(({ name, id }) => slotMap[name] = id);
            });
            // finalize packet
            const pid = particle.id.toString();
            Object.assign(packet, {
                particle: {
                    name: particle.name,
                    id: pid
                },
                slotMap,
                // TODO(sjmiles): there is no clear concept for a particle's output channel, so there is no proper ID
                // to use. The `particle.id` works for now, but it probably should be a combo of `particle.id` and the
                // consumed slot id (neither of which are unique by themselves).
                outputSlotId: pid,
                content
            });
            //console.log(`RenderEx:delegateOutput for %c[${particle.spec.name}]::[${particle.id}]`, 'color: darkgreen; font-weight: bold;');
            observer.observe(packet, arc);
        }
    }
}
//# sourceMappingURL=slot-composer.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/pec-industry-node.js
/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


const pecIndustry = loader => {
    return (pecId, idGenerator) => {
        const channel = new message_channel_MessageChannel();
        const _throwAway = new particle_execution_context_ParticleExecutionContext(channel.port1, pecId, idGenerator, loader);
        return channel.port2;
    };
};
//# sourceMappingURL=pec-industry-node.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/platform/pec-industry.js
/**
 * @license
 * Copyright 2019 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

//# sourceMappingURL=pec-industry.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/direct-storage-endpoint.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

class direct_storage_endpoint_DirectStorageEndpoint {
    constructor(store) {
        this.store = store;
        this.id = 0;
    }
    get storeInfo() { return this.store.storeInfo; }
    async onProxyMessage(message) {
        message.id = this.id;
        noAwait(this.store.onProxyMessage(message));
    }
    setCallback(callback) {
        this.id = this.store.on(callback);
    }
    reportExceptionInHost(exception) {
        this.store.reportExceptionInHost(exception);
    }
    getStorageFrontend() {
        const store = this.store;
        // TODO(shans): implement so that we can use references outside of the PEC.
        return {
            generateID() {
                return null;
            },
            idGenerator: null,
            getStorageProxyMuxer() {
                throw new Error('References not yet supported outside of the PEC');
            },
            registerStorageProxy(storageProxy, messagesCallback, idCallback) { },
            directStorageProxyMuxerRegister(storageProxyMuxer, messagesCallback, idCallback) { },
            storageProxyMessage(storageProxy, message) { },
            storageProxyMuxerMessage(storageProxyMuxer, message) { },
            reportExceptionInHost(exception) {
                store.reportExceptionInHost(exception);
            }
        };
    }
    async idle() { return this.store.idle(); }
    async close() {
        if (this.id) {
            return this.store.off(this.id);
        }
    }
}
//# sourceMappingURL=direct-storage-endpoint.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/storage/direct-storage-endpoint-manager.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */




class direct_storage_endpoint_manager_DirectStorageEndpointManager {
    constructor() {
        // All the stores, mapped by store ID
        this.activeStoresByKey = new Map();
    }
    async getActiveStore(storeInfo) {
        if (!this.activeStoresByKey.has(storeInfo.storageKey)) {
            if (active_store_ActiveStore.constructors.get(storeInfo.mode) == null) {
                throw new Error(`StorageMode ${storeInfo.mode} not yet implemented`);
            }
            const ctor = active_store_ActiveStore.constructors.get(storeInfo.mode);
            if (ctor == null) {
                throw new Error(`No constructor registered for mode ${storeInfo.mode}`);
            }
            this.activeStoresByKey.set(storeInfo.storageKey, await ctor.construct({
                storageKey: storeInfo.storageKey,
                exists: storeInfo.exists,
                type: storeInfo.type,
                storeInfo: storeInfo,
            }));
            storeInfo.exists = Exists.ShouldExist;
        }
        return this.activeStoresByKey.get(storeInfo.storageKey);
    }
    async onRegister(storeInfo, messagesCallback, idCallback) {
        const store = await this.getActiveStore(storeInfo);
        const id = store.on(async (data) => {
            messagesCallback(data);
        });
        idCallback(id);
    }
    async onProxyMessage(storeInfo, message) {
        return (await this.getActiveStore(storeInfo)).onProxyMessage(message);
    }
    getStorageEndpoint(storeInfo) {
        external_assert_default()(this.activeStoresByKey.has(storeInfo.storageKey));
        return new direct_storage_endpoint_DirectStorageEndpoint(this.activeStoresByKey.get(storeInfo.storageKey));
    }
}
//# sourceMappingURL=direct-storage-endpoint-manager.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/runtime/runtime.js
/**
 * @license
 * Copyright (c) 2018 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var runtime_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Runtime_1;



















const { warn: runtime_warn } = logsFactory('Runtime', 'orange');
// TODO(sjmiles): weird layering here due to dancing around global state (working on it)
let staticMemoryProvider;
const initDrivers = () => {
    volatile_VolatileStorageKey.register();
    staticMemoryProvider = new SimpleVolatileMemoryProvider();
    ramdisk_RamDiskStorageDriverProvider.register(staticMemoryProvider);
};
initDrivers();
const nob = Object.create(null);
let runtime_Runtime = Runtime_1 = class Runtime {
    constructor(opts = {}) {
        this.arcById = new Map();
        const rootMap = opts.rootPath && Runtime_1.mapFromRootPath(opts.rootPath) || nob;
        const urlMap = opts.urlMap || nob;
        const map = { ...rootMap, ...urlMap };
        this.loader = opts.loader || new loader_node_Loader(map);
        this.pecFactory = opts.pecFactory || pecIndustry(this.loader);
        this.composerClass = opts.composerClass || slot_composer_SlotComposer;
        this.cacheService = new RuntimeCacheService();
        this.memoryProvider = opts.memoryProvider || staticMemoryProvider;
        this.storageService = opts.storageService || new direct_storage_endpoint_manager_DirectStorageEndpointManager();
        this.context = opts.context || new manifest_Manifest({ id: 'manifest:default' });
        // user information. One persona per runtime for now.
    }
    static resetDrivers(noDefault) {
        DriverFactory.providers = new Set();
        StorageKeyParser.reset();
        capabilities_resolver_CapabilitiesResolver.reset();
        if (!noDefault) {
            initDrivers();
        }
    }
    static mapFromRootPath(root) {
        // TODO(sjmiles): this is a commonly-used map, but it's not generic enough to live here.
        // Shells that use this default should be provide it to `init` themselves.
        return {
            // important: path to `worker.js`
            'https://$worker/': `${root}/shells/lib/worker/dist/`,
            // these are optional (?)
            'https://$arcs/': `${root}/`,
            'https://$shells': `${root}/shells`,
            'https://$particles/': {
                root,
                path: '/particles/',
                buildDir: '/bazel-bin',
                buildOutputRegex: /\.wasm$/.source
            }
        };
    }
    getCacheService() {
        return this.cacheService;
    }
    getMemoryProvider() {
        return this.memoryProvider;
    }
    destroy() {
        workerPool.clear();
    }
    // TODO(shans): Clean up once old storage is removed.
    // Note that this incorrectly assumes every storage key can be of the form `prefix` + `arcId`.
    // Should ids be provided to the Arc constructor, or should they be constructed by the Arc?
    // How best to provide default storage to an arc given whatever we decide?
    newArc(name, storageKeyPrefix, options) {
        const id = (options && options.id) || id_IdGenerator.newSession().newArcId(name);
        const slotComposer = this.composerClass ? new this.composerClass() : null;
        const storageKey = storageKeyPrefix ? storageKeyPrefix(id) : new volatile_VolatileStorageKey(id, '');
        const factories = (options && options.storargeKeyFactories) || [new volatile_VolatileStorageKeyFactory()];
        const capabilitiesResolver = new capabilities_resolver_CapabilitiesResolver({ arcId: id, factories });
        const { loader, context, storageService } = this;
        return new arc_Arc({ id, storageKey, capabilitiesResolver, loader, slotComposer, context, storageService, ...options });
    }
    /**
     * Given an arc name, return either:
     * (1) the already running arc
     * (2) a deserialized arc (TODO: needs implementation)
     * (3) a newly created arc
     */
    runArc(name, storageKeyPrefix, options) {
        if (!this.arcById.has(name)) {
            // TODO: Support deserializing serialized arcs.
            this.arcById.set(name, this.newArc(name, storageKeyPrefix, options));
        }
        return this.arcById.get(name);
    }
    stop(name) {
        external_assert_default()(this.arcById.has(name), `Cannot stop nonexistent arc ${name}`);
        this.arcById.get(name).dispose();
        this.arcById.delete(name);
    }
    findArcByParticleId(particleId) {
        return [...this.arcById.values()].find(arc => !!arc.activeRecipe.findParticle(particleId));
    }
    /**
     * Given an arc, returns it's description as a string.
     */
    static async getArcDescription(arc) {
        // Verify that it's one of my arcs, and make this non-static, once I have
        // Runtime objects in the calling code.
        return (await description_Description.create(arc)).getArcDescription();
    }
    async parse(content, options) {
        const { loader, memoryProvider } = this;
        // TODO(sjmiles): this method of generating a manifest id is ad-hoc,
        // maybe should be using one of the id generators, or even better
        // we could eliminate it if the Manifest object takes care of this.
        const id = `in-memory-${Math.floor((Math.random() + 1) * 1e6)}.manifest`;
        // TODO(sjmiles): this is a virtual manifest, the fileName is invented
        const opts = { id, fileName: `./${id}`, loader, memoryProvider, ...options };
        return manifest_Manifest.parse(content, opts);
    }
    async parseFile(path, options) {
        const { memoryProvider } = this;
        const opts = { id: path, memoryProvider, ...options };
        return manifest_Manifest.load(path, opts.loader || this.loader, opts);
    }
    // TODO(sjmiles): static methods represent boilerplate.
    // There's no essential reason they are part of Runtime.
    static async resolveRecipe(arc, recipe) {
        if (this.normalize(recipe)) {
            if (recipe.isResolved()) {
                return recipe;
            }
            const resolver = new RecipeResolver(arc);
            const plan = await resolver.resolve(recipe);
            if (plan && plan.isResolved()) {
                return plan;
            }
            runtime_warn('failed to resolve:\n', (plan || recipe).toString({ showUnresolved: true }));
        }
        return null;
    }
    static normalize(recipe) {
        if (Runtime_1.isNormalized(recipe)) {
            return true;
        }
        const errors = new Map();
        if (recipe.normalize({ errors })) {
            return true;
        }
        runtime_warn('failed to normalize:\n', errors, recipe.toString());
        return false;
    }
    static isNormalized(recipe) {
        return Object.isFrozen(recipe);
    }
};
runtime_Runtime = Runtime_1 = runtime_decorate([
    SystemTrace
], runtime_Runtime);

//# sourceMappingURL=runtime.js.map
// EXTERNAL MODULE: /Users/sjmiles/Sites/projects/arcs/node_modules/protobufjs/index.js
var protobufjs = __webpack_require__(38);
var protobufjs_default = /*#__PURE__*/__webpack_require__.n(protobufjs);

// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/tools/runfiles-dir.oss.js
/**
 * @license
 * Copyright 2020 Google LLC.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
// A prefix that ought to be added when reading files bundled with the binary tool.
//
// This constant is overridden in Google internal repo to allow reading files bundled
// with the executable using the Bazel 'data' attribute.
const runfilesDir =  process.env['RUNFILES'] + '/' + process.env['BAZEL_WORKSPACE'] + '/third_party/arcs/';
//# sourceMappingURL=runfiles-dir.oss.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/tools/manifest-proto.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */


// These variables store classes that deal with protos, upper case name is justified.
// tslint:disable: variable-name
const RootNamespace = protobufjs_default.a.loadSync([
    runfilesDir + 'proto/annotation.proto',
    runfilesDir + 'proto/manifest.proto',
    runfilesDir + 'proto/policy.proto',
]);
const DirectionEnum = RootNamespace.lookupEnum('arcs.Direction');
const FateEnum = RootNamespace.lookupEnum('arcs.Fate');
const ManifestProto = RootNamespace.lookupType('arcs.ManifestProto');
const OperatorEnum = RootNamespace.lookupEnum('arcs.OPERATOR');
const PolicyFieldUsageEnum = RootNamespace.lookupEnum('arcs.PolicyFieldProto.UsageType');
const PolicyProto = RootNamespace.lookupType('arcs.PolicyProto');
const PolicyRetentionMediumEnum = RootNamespace.lookupEnum('arcs.PolicyRetentionProto.Medium');
const PrimitiveTypeEnum = RootNamespace.lookupEnum('arcs.PrimitiveTypeProto');
const TypeProto = RootNamespace.lookupType('arcs.TypeProto');
//# sourceMappingURL=manifest-proto.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/tools/kotlin-generation-utils.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * Default language formatting settings.
 */
const KT_DEFAULT = { indent: 4, lineLength: 100 };
/**
 * Collection of utilities for generating Kotlin code.
 */
class KotlinGenerationUtils {
    constructor(pref = KT_DEFAULT) {
        this.pref = pref;
    }
    /**
     * Formats a function application in Kotlin.
     *
     * @param name name of the function
     * @param args list of arguments to the function
     * @param opts additional options for formatting
     */
    applyFun(name, args, { 
    // Starting indentation level.
    startIndent = 0, 
    // Alternative name for the function with empty arguments.
    emptyName = name, 
    // Number of existing indents where the resulting code will be inserted.
    numberOfIndents = 0 } = {}) {
        if (args.length === 0)
            return `${emptyName}()`;
        return `${name}(${this.joinWithIndents(args, {
            startIndent: startIndent + name.length + 2,
            numberOfIndents: numberOfIndents + 1
        })})`;
    }
    /** Formats `mapOf` with correct indentation and defaults. */
    mapOf(args, startIndent = 0) {
        return this.applyFun('mapOf', args, { startIndent, emptyName: 'emptyMap' });
    }
    /** Formats `mutableMapOf` with correct indentation and defaults. */
    mutableMapOf(args, startIndent = 0) {
        return this.applyFun('mutableMapOf', args, { startIndent, emptyName: 'mutableMapOf' });
    }
    /** Formats `listOf` with correct indentation and defaults. */
    listOf(args, startIndent = 0) {
        return this.applyFun('listOf', args, { startIndent, emptyName: 'emptyList' });
    }
    /** Formats `setOf` with correct indentation and defaults. */
    setOf(args, startIndent = 0) {
        return this.applyFun('setOf', args, { startIndent, emptyName: 'emptySet' });
    }
    /**
     * Formats properties in Kotlin, including supporting delegates.
     *
     * @param name property name
     * @param block value assigned to property
     * @param startIndent starting whitespace
     * @param mutable determines 'val' vs 'var', default to 'val'
     * @param type (optional) type annotation associated with property
     * @param delegate (optional) name or object instance of delegate function
     */
    async property(name, block, { startIndent = 0, mutable = false, type = '', delegate = '' } = {}) {
        const decl = mutable ? 'var' : 'val';
        const typeStmt = type === '' ? '' : `: ${type}`;
        const lhs = `${decl} ${name}${typeStmt} `;
        let rhs = '';
        if (delegate !== '') {
            rhs += `by ${delegate} {\n`;
            rhs += this.indent(await block({ startIndent: startIndent + 4 })) + '\n';
            rhs += `}`;
        }
        else {
            rhs += `= `;
            rhs += await block({ startIndent: lhs.length + rhs.length + startIndent });
        }
        return `${lhs}${rhs}`;
    }
    /**
     * Joins a list of items, taking line length and indentation into account.
     *
     * @param items strings to join
     * @param opts additional options for formatting
     */
    joinWithIndents(items, { 
    // Starting indentation level.
    startIndent = 0, 
    // Number of existing indents where the resulting code will be inserted.
    numberOfIndents = 1 } = {}) {
        const candidate = items.join(', ');
        if (startIndent + candidate.length <= this.pref.lineLength)
            return candidate;
        return `\n${this.indent(items.join(',\n'), numberOfIndents)}\n${this.indent('', numberOfIndents - 1)}`;
    }
    /** Indent a codeblock with the preferred indentation. */
    indent(block, numberOfIndents = 1) {
        return leftPad(block, this.pref.indent * numberOfIndents);
    }
    /**
     * Joins a list of lines, indenting all but the first one.
     */
    indentFollowing(lines, numberOfIndents) {
        return lines
            .map((line, idx) => idx > 0 ? ' '.repeat(this.pref.indent * numberOfIndents) + line : line)
            .join('\n');
    }
}
/** Everyone's favorite NPM module, install not required. */
function leftPad(input, indent, skipFirst = false) {
    return input
        .split('\n')
        .map((line, idx) => (idx === 0 && skipFirst) ? line : ' '.repeat(indent) + line)
        .join('\n');
}
/** Quote a string. */
function quote(s) { return `"${s}"`; }
/** Quote a multi-line string. */
function multiLineQuote(s) { return `"""${s}"""`; }
/** Produces import statement if target is not within the same package. */
function tryImport(importName, packageName) {
    const nonWild = importName.replace('.*', '');
    return packageName === nonWild ? '' : `import ${importName}`;
}
/** Coalesces input string such that the first character is upper case. */
function upperFirst(s) {
    return s[0].toUpperCase() + s.slice(1);
}
//# sourceMappingURL=kotlin-generation-utils.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/tools/annotations-utils.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

function annotationToProtoPayload(annotation) {
    return {
        name: annotation.name,
        params: Object.entries(annotation.params).map(([name, value]) => {
            const valueField = typeof value === 'string' ? 'strValue'
                : typeof value === 'number' ? 'numValue' : 'boolValue';
            return { name, [valueField]: value };
        })
    };
}
// Encode the annotations in a kotlin list of kotlin Annotation.
function annotationsToKotlin(annotations) {
    const ktUtils = new KotlinGenerationUtils();
    const annotationStrs = [];
    for (const ref of annotations) {
        const paramMappings = Object.entries(ref.annotation.params).map(([name, type]) => {
            const paramToMapping = () => {
                switch (type) {
                    case 'Text':
                        return `AnnotationParam.Str(${quote(ref.params[name].toString())})`;
                    case 'Number':
                        return `AnnotationParam.Num(${ref.params[name]})`;
                    case 'Boolean':
                        return `AnnotationParam.Bool(${ref.params[name]})`;
                    default: throw new Error(`Unsupported param type ${type}`);
                }
            };
            return `"${name}" to ${paramToMapping()}`;
        });
        annotationStrs.push(ktUtils.applyFun('Annotation', [
            quote(ref.name),
            ktUtils.mapOf(paramMappings, 12)
        ]));
    }
    return ktUtils.listOf(annotationStrs);
}
//# sourceMappingURL=annotations-utils.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/tools/policy2proto.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */



function policyToProtoPayload(policy) {
    return {
        name: policy.name,
        targets: policy.targets.map(policyTargetToProtoPayload),
        configs: policy.configs.map(policyConfigToProtoPayload),
        description: policy.description,
        egressType: policy.egressType,
        annotations: policy.customAnnotations.map(annotationToProtoPayload),
    };
}
function policyTargetToProtoPayload(target) {
    return {
        schemaType: target.schemaName,
        maxAgeMs: target.maxAge ? target.maxAge.millis : null,
        retentions: target.retentions.map(retention => ({
            medium: convertToProtoEnum(retention.medium, PolicyRetentionMediumEnum),
            encryptionRequired: retention.encryptionRequired,
        })),
        fields: target.fields.map(policyFieldToProtoPayload),
        annotations: target.customAnnotations.map(annotationToProtoPayload),
    };
}
function policyFieldToProtoPayload(field) {
    return {
        name: field.name,
        usages: field.allowedUsages.map(usage => {
            let usageType = usage.usage;
            if (usageType === '*') {
                usageType = 'Any';
            }
            return {
                usage: convertToProtoEnum(usageType, PolicyFieldUsageEnum),
                redactionLabel: usage.label,
            };
        }),
        subfields: field.subfields.map(policyFieldToProtoPayload),
        annotations: field.customAnnotations.map(annotationToProtoPayload),
    };
}
function policyConfigToProtoPayload(config) {
    return {
        name: config.name,
        metadata: mapToDictionary(config.metadata),
    };
}
/**
 * Converts a TypeScript string-valued enum from PascalCase used for TS enum
 * values to UPPER_CAMEL_CASE used for proto enum values.
 */
function convertToProtoEnum(value, enumType) {
    if (value == null) {
        return null;
    }
    else if (typeof value !== 'string') {
        throw new Error(`Enum value must be a string, instead was: ${value}`);
    }
    let str = value;
    str = str[0].toUpperCase() + str.slice(1).replace(/([A-Z])/g, '_$1').toUpperCase();
    const protoEnumValue = enumType.values[str];
    if (protoEnumValue == null) {
        throw new Error(`Unknown enum value ${str} for enum ${enumType.name}.`);
    }
    return protoEnumValue;
}
//# sourceMappingURL=policy2proto.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/tools/manifest2proto.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */







globalThis.fetch = lib;
async function encodeManifestToProto(runtime, path) {
    const manifest = await runtime.parseFile(path, { throwImportErrors: true });
    if (manifest.errors.length != 0) {
      throw new Error("Parsing failed for " + path + "\n");
    }
    return encodePayload(await manifestToProtoPayload(manifest));
}
async function manifestToProtoPayload(manifest) {
    manifest.validateUniqueDefinitions();
    return makeManifestProtoPayload(manifest.allParticles, manifest.allRecipes, manifest.allPolicies);
}
async function encodePlansToProto(plans, manifest) {
    // In the recipe data structure every particle in a recipe currently has its own copy
    // of a particle spec. This copy is used in type inference and gets mutated as recipe
    // is type checked. As we need to encode particle specs without such mutations, below
    // we reach for ParticleSpecs from manifest.particles, instead of the ones hanging from
    // the recipe.particles.
    // This should be cleaned-up in the recipe data structure and type infrence code,
    // once that happens, we can remove the below hack.
    const specToId = (spec) => `${spec.name}:${spec.implFile}`;
    const planParticleIds = flatMap(plans, p => p.particles).map(p => specToId(p.spec));
    const particleSpecs = manifest.allParticles.filter(p => planParticleIds.includes(specToId(p)));
    return encodePayload(await makeManifestProtoPayload(particleSpecs, plans, /* policies= */ []));
}
async function makeManifestProtoPayload(particles, recipes, policies) {
    return {
        particleSpecs: await Promise.all(particles.map(p => particleSpecToProtoPayload(p))),
        recipes: await Promise.all(recipes.map(r => recipeToProtoPayload(r))),
        policies: policies.map(policyToProtoPayload),
    };
}
function encodePayload(payload) {
    const error = ManifestProto.verify(payload);
    if (error)
        throw new Error(error);
    return ManifestProto.encode(ManifestProto.create(payload)).finish();
}
async function particleSpecToProtoPayload(spec) {
    const connections = await Promise.all(spec.connections.map(async (connectionSpec) => handleConnectionSpecToProtoPayload(connectionSpec)));
    const claims = flatMap(spec.connections, connectionSpec => claimsToProtoPayload(spec, connectionSpec));
    const checks = flatMap(spec.connections, connectionSpec => checksToProtoPayload(spec, connectionSpec));
    return {
        name: spec.name,
        location: spec.implFile,
        connections,
        claims,
        checks,
        annotations: spec.annotations.map(a => annotationToProtoPayload(a)),
    };
}
async function handleConnectionSpecToProtoPayload(spec) {
    const directionOrdinal = DirectionEnum.values[spec.direction.replace(/ /g, '_').toUpperCase()];
    if (directionOrdinal === undefined) {
        throw new Error(`Handle connection direction ${spec.direction} is not supported`);
    }
    return {
        name: spec.name,
        direction: directionOrdinal,
        type: await typeToProtoPayload(spec.type),
        expression: spec.expression
    };
}
// Converts the claims in HandleConnectionSpec.
function claimsToProtoPayload(spec, connectionSpec) {
    if (!connectionSpec.claims) {
        return [];
    }
    const protos = [];
    for (const particleClaim of connectionSpec.claims) {
        const accessPath = accessPathProtoPayload(spec, connectionSpec, particleClaim.fieldPath);
        for (const claim of particleClaim.claims) {
            switch (claim.type) {
                case ClaimType.IsTag: {
                    let predicate = { label: { semanticTag: claim.tag } };
                    if (claim.isNot) {
                        predicate = { not: { predicate } };
                    }
                    protos.push({
                        assume: { accessPath, predicate }
                    });
                    break;
                }
                case ClaimType.DerivesFrom: {
                    protos.push({
                        derivesFrom: {
                            target: accessPath,
                            source: accessPathProtoPayload(spec, claim.parentHandle, claim.fieldPath),
                        }
                    });
                    break;
                }
                default:
                    throw new Error(`Unknown ClaimType for claim: ${JSON.stringify(claim)}.`);
            }
        }
    }
    return protos;
}
// Converts the checks in HandleConnectionSpec.
function checksToProtoPayload(spec, connectionSpec) {
    if (!connectionSpec.checks) {
        return [];
    }
    return connectionSpec.checks.map(check => {
        const accessPath = accessPathProtoPayload(spec, connectionSpec, check.fieldPath);
        const predicate = checkExpressionToProtoPayload(check.expression);
        return { accessPath, predicate };
    });
}
function checkExpressionToProtoPayload(expression) {
    switch (expression.type) {
        case 'and': {
            const children = expression.children.map(child => {
                return checkExpressionToProtoPayload(child);
            });
            return children.reduce((acc, cur) => {
                return (acc == null)
                    ? cur
                    : {
                        and: {
                            conjunct0: acc,
                            conjunct1: cur
                        }
                    };
            }, null);
        }
        case 'or': {
            const children = expression.children.map(child => {
                return checkExpressionToProtoPayload(child);
            });
            return children.reduce((acc, cur) => {
                return (acc == null)
                    ? cur
                    : {
                        or: {
                            disjunct0: acc,
                            disjunct1: cur
                        }
                    };
            }, null);
        }
        default: {
            const condition = expression;
            switch (condition.type) {
                case CheckType.HasTag: {
                    const tag = { semanticTag: condition.tag };
                    if (condition.isNot) {
                        return {
                            not: { predicate: { label: tag } }
                        };
                    }
                    else {
                        return { label: tag };
                    }
                }
                case CheckType.Implication:
                    return {
                        implies: {
                            antecedent: checkExpressionToProtoPayload(condition.antecedent),
                            consequent: checkExpressionToProtoPayload(condition.consequent),
                        },
                    };
                case CheckType.IsFromHandle:
                case CheckType.IsFromOutput:
                case CheckType.IsFromStore:
                    throw new Error(`Unsupported CheckType for check: ${JSON.stringify(condition)}.`);
                default:
                    throw new Error(`Unknown CheckType for check: ${JSON.stringify(condition)}.`);
            }
        }
    }
}
/** Constructs an AccessPathProto payload. */
function accessPathProtoPayload(spec, connectionSpec, fieldPath) {
    const accessPath = {
        handle: {
            particleSpec: spec.name,
            handleConnection: connectionSpec.name
        }
    };
    if (fieldPath.length) {
        accessPath.selectors = fieldPath.map(field => ({ field }));
    }
    return accessPath;
}
async function recipeToProtoPayload(recipe) {
    recipe.normalize();
    const handleToProtoPayload = new Map();
    for (const h of recipe.handles) {
        // After type inference which runs as a part of the recipe.normalize() above
        // all handle types are constrained type variables. We force these type variables
        // to their resolution by called maybeEnsureResolved(), so that handle types
        // are encoded with concrete types, instead of variables.
        if (h.type === undefined) {
            throw new Error(`Type of handle '${h.localName}' in recipe '${recipe.name}' could not be resolved.`);
        }
        h.type.maybeEnsureResolved();
        handleToProtoPayload.set(h, await recipeHandleToProtoPayload(h));
    }
    return {
        name: recipe.name,
        particles: await Promise.all(recipe.particles.map(p => recipeParticleToProtoPayload(p, handleToProtoPayload))),
        handles: [...handleToProtoPayload.values()],
        annotations: recipe.annotations.map(a => annotationToProtoPayload(a))
    };
}
async function recipeParticleToProtoPayload(particle, handleMap) {
    return {
        specName: particle.name,
        connections: await Promise.all(Object.entries(particle.connections).map(async ([name, connection]) => ({
            name,
            handle: handleMap.get(connection.handle).name,
            type: await typeToProtoPayload(connection.type)
        })))
    };
}
async function recipeHandleToProtoPayload(handle) {
    const fateOrdinal = FateEnum.values[handle.fate.toUpperCase()];
    if (fateOrdinal === undefined) {
        throw new Error(`Handle fate ${handle.fate} is not supported`);
    }
    const toName = handle => handle.localName || `handle${handle.recipe.handles.indexOf(handle)}`;
    const handleData = {
        name: toName(handle),
        id: handle.id,
        tags: handle.tags,
        fate: fateOrdinal,
        type: await typeToProtoPayload(handle.type || handle.mappedType),
        annotations: handle.annotations.map(annotationToProtoPayload)
    };
    if (handle.storageKey) {
        handleData['storageKey'] = handle.storageKey.toString();
    }
    if (handle.fate === 'join' && handle.joinedHandles) {
        handleData['associatedHandles'] = handle.joinedHandles.map(toName);
    }
    return handleData;
}
async function typeToProtoPayload(type) {
    if (type.hasVariable && type.isResolved()) {
        // We encode the resolution of the resolved type variables directly.
        // This allows us to encode handle types and connection types directly
        // and only encode type variables where they are not yet resolved,
        // e.g. in particle specs of generic particles.
        type = type.resolvedType();
    }
    switch (type.tag) {
        case 'Entity': {
            const entity = {
                entity: {
                    schema: await schemaToProtoPayload(type.getEntitySchema()),
                },
            };
            if (type.getEntitySchema().refinement) {
                entity['refinement'] = refinementToProtoPayload(type.getEntitySchema().refinement);
            }
            return entity;
        }
        case 'Collection': return {
            collection: {
                collectionType: await typeToProtoPayload(type.collectionType)
            }
        };
        case 'Reference': return {
            reference: {
                referredType: await typeToProtoPayload(type.referredType)
            }
        };
        case 'Tuple': return {
            tuple: {
                elements: await Promise.all(type.innerTypes.map(typeToProtoPayload))
            }
        };
        case 'Singleton': return {
            singleton: {
                singletonType: await typeToProtoPayload(type.getContainedType())
            }
        };
        case 'Count': return {
            count: {}
        };
        case 'TypeVariable': {
            const constraintType = type.canReadSubset || type.canWriteSuperset;
            const name = { name: type.variable.name };
            const constraint = { constraint: { maxAccess: type.variable.resolveToMaxType || false } };
            if (constraintType) {
                constraint.constraint['constraintType'] = await typeToProtoPayload(constraintType);
            }
            return { variable: { ...name, ...constraint } };
        }
        default: throw new Error(`Type '${type.tag}' is not supported.`);
    }
}
async function schemaToProtoPayload(schema) {
    return {
        names: schema.names,
        fields: objectFromEntries(await Promise.all(Object.entries(schema.fields).map(async ([key, value]) => [key, await schemaFieldToProtoPayload(value)]))),
        hash: await schema.hash()
    };
}
async function schemaFieldToProtoPayload(fieldType) {
    // TODO(b/162033274): factor this into schema-field.
    switch (fieldType.kind) {
        case 'schema-primitive':
        case 'kotlin-primitive': {
            const primitive = PrimitiveTypeEnum.values[fieldType.getType().toUpperCase()];
            if (primitive === undefined) {
                throw new Error(`Primitive field type ${fieldType.getType()} is not supported.`);
            }
            return { primitive };
        }
        case 'schema-collection': {
            return {
                collection: {
                    collectionType: await schemaFieldToProtoPayload(fieldType.getFieldType())
                }
            };
        }
        case 'schema-tuple': {
            return {
                tuple: {
                    elements: await Promise.all(fieldType.getFieldTypes().map(schemaFieldToProtoPayload))
                }
            };
        }
        case 'schema-reference': {
            return {
                reference: {
                    referredType: await schemaFieldToProtoPayload(fieldType.getFieldType())
                }
            };
        }
        case 'type-name': {
            return typeToProtoPayload(fieldType.getEntityType());
        }
        case 'schema-nested': {
            // Nested inlined entity. Wraps a 'schema-inline' object. Mark it as an
            // inline entity.
            const entityType = await schemaFieldToProtoPayload(fieldType.getFieldType());
            entityType.entity.inline = true;
            return entityType;
        }
        case 'schema-inline': {
            // Not actually a nested inline entity (if it were, it would be wrapped in
            // a schema-nested object), so just encode as a regular entity.
            return typeToProtoPayload(fieldType.getEntityType());
        }
        case 'schema-ordered-list': {
            return {
                list: { elementType: await schemaFieldToProtoPayload(fieldType.getFieldType()) }
            };
        }
        // TODO(b/154947220) support schema-unions
        case 'schema-union':
        default: throw new Error(`Schema field kind ${fieldType.kind} is not supported.`);
    }
}
function refinementToProtoPayload(refinement) {
    refinement.normalize();
    const literal = refinement.toLiteral();
    return refinementExpressionLiteralToProtoPayload(literal.expression);
}
function toOpProto(op) {
    const opEnum = [
        Op.AND, Op.OR,
        Op.LT, Op.GT, Op.LTE, Op.GTE,
        Op.ADD, Op.SUB, Op.MUL, Op.DIV,
        Op.NOT, Op.NEG,
        Op.EQ, Op.NEQ,
    ].indexOf(op);
    if (opEnum === -1)
        throw new Error(`Op type '${op}' is not supported.`);
    return opEnum;
}
function refinementExpressionLiteralToProtoPayload(expr) {
    switch (expr.kind) {
        case 'BinaryExpressionNode': return {
            binary: {
                leftExpr: refinementExpressionLiteralToProtoPayload(expr.leftExpr),
                rightExpr: refinementExpressionLiteralToProtoPayload(expr.rightExpr),
                operator: toOpProto(expr.operator)
            }
        };
        case 'UnaryExpressionNode': return {
            unary: {
                expr: refinementExpressionLiteralToProtoPayload(expr.expr),
                operator: toOpProto(expr.operator),
            }
        };
        case 'FieldNamePrimitiveNode': return {
            field: expr.value
        };
        case 'QueryArgumentPrimitiveNode': return {
            queryArgument: expr.value
        };
        case 'NumberPrimitiveNode': return {
            number: expr.value
        };
        case 'BooleanPrimitiveNode': return {
            boolean: expr.value
        };
        case 'TextPrimitiveNode': return {
            text: expr.value
        };
        default:
            throw new Error(`Unknown node type ${expr['kind']}`);
    }
}
// Someday could be replace with Object.fromEntries when it's widely available:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries
function objectFromEntries(entries) {
    return entries.reduce((object, [key, value]) => {
        object[key] = value;
        return object;
    }, {});
}
//# sourceMappingURL=manifest2proto.js.map
// CONCATENATED MODULE: /Users/sjmiles/Sites/projects/arcs/build/tools/manifest2proto-cli.js
/**
 * @license
 * Copyright (c) 2020 Google Inc. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * Code distributed by Google as part of this project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */






const manifest2proto_cli_opts = minimist_default()(process.argv.slice(2), {
    string: ['outdir', 'outfile'],
    boolean: ['quiet'],
    alias: { d: 'outdir', f: 'outfile', q: 'quiet' },
    default: { outdir: '.' }
});
if (manifest2proto_cli_opts.help || manifest2proto_cli_opts._.length === 0) {
    console.log(`
Usage
  $ tools/sigh manifest2proto [options] path/to/manifest.arcs

Description
  Serializes manifests to a protobuf file.

Options
  --outfile, -f output filename; required
  --outdir, -d  output directory; defaults to '.'
  --quiet, -q   suppress log output
  --help        usage info
`);
    process.exit(0);
}
// if (!opts.outfile) {
//   console.error(`Parameter --outfile is required.`);
//   process.exit(1);
// }
// // TODO(alxr): Support proto generation from multiple manifests
// if (opts._.length > 1) {
//   console.error(`Only a single manifest is allowed`);
//   process.exit(1);
// }
// if (opts._.some((file) => !file.endsWith('.arcs'))) {
//   console.error(`Only Arcs manifests ('*.arcs') are allowed.`);
//   process.exit(1);
// }
async function main() {
    try {
        external_fs_default.a.mkdirSync(manifest2proto_cli_opts.outdir, { recursive: true });
        //const buffer = null;
        const runtime = new runtime_Runtime({ rootPath: '../..', urlMap: PATHS });
        const buffer = await encodeManifestToProto(runtime, manifest2proto_cli_opts._[0]);
        const outPath = external_path_default.a.join(manifest2proto_cli_opts.outdir, manifest2proto_cli_opts.outfile);
        if (!manifest2proto_cli_opts.quiet) {
            console.log(outPath);
        }
        const outFile = external_fs_default.a.openSync(outPath, 'w');
        external_fs_default.a.writeSync(outFile, Buffer.from(buffer));
        external_fs_default.a.closeSync(outFile);
    }
    catch (e) {
        console.error(e);
        process.exit(1);
    }
}
void main();
//# sourceMappingURL=manifest2proto-cli.js.map

/***/ })
/******/ ]);

